
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000200 	.word	0x20000200
 8000004:	08000191 	.word	0x08000191
 8000008:	080040e1 	.word	0x080040e1
 800000c:	08000193 	.word	0x08000193
 8000010:	08000193 	.word	0x08000193
 8000014:	08000193 	.word	0x08000193
 8000018:	08000193 	.word	0x08000193
 800001c:	08000193 	.word	0x08000193
 8000020:	08000193 	.word	0x08000193
 8000024:	08000193 	.word	0x08000193
 8000028:	08000193 	.word	0x08000193
 800002c:	08000193 	.word	0x08000193
 8000030:	08000193 	.word	0x08000193
 8000034:	08000193 	.word	0x08000193
 8000038:	08000193 	.word	0x08000193
 800003c:	08000193 	.word	0x08000193
 8000040:	08000193 	.word	0x08000193
 8000044:	08000193 	.word	0x08000193
 8000048:	08000193 	.word	0x08000193
 800004c:	08000193 	.word	0x08000193
 8000050:	08000193 	.word	0x08000193
 8000054:	08000193 	.word	0x08000193
 8000058:	08000193 	.word	0x08000193
 800005c:	08000193 	.word	0x08000193
 8000060:	08000193 	.word	0x08000193
 8000064:	08000193 	.word	0x08000193
 8000068:	08000193 	.word	0x08000193
 800006c:	08000193 	.word	0x08000193
 8000070:	08000193 	.word	0x08000193
 8000074:	08000193 	.word	0x08000193
 8000078:	08000193 	.word	0x08000193
 800007c:	08001241 	.word	0x08001241
 8000080:	08000193 	.word	0x08000193
 8000084:	08000193 	.word	0x08000193
 8000088:	08000193 	.word	0x08000193
 800008c:	08000193 	.word	0x08000193
 8000090:	08000193 	.word	0x08000193
 8000094:	08000193 	.word	0x08000193
 8000098:	08000193 	.word	0x08000193
 800009c:	08000193 	.word	0x08000193
 80000a0:	08000193 	.word	0x08000193
 80000a4:	08000193 	.word	0x08000193
 80000a8:	08000193 	.word	0x08000193
 80000ac:	08001221 	.word	0x08001221
 80000b0:	08001201 	.word	0x08001201
 80000b4:	08000193 	.word	0x08000193
 80000b8:	08000193 	.word	0x08000193
 80000bc:	08000193 	.word	0x08000193

Disassembly of section .text:

080000c0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80000c0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80000c2:	4824      	ldr	r0, [pc, #144]	; (8000154 <endfiniloop+0x6>)
                msr     MSP, r0
 80000c4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80000c8:	4823      	ldr	r0, [pc, #140]	; (8000158 <endfiniloop+0xa>)
                msr     PSP, r0
 80000ca:	f380 8809 	msr	PSP, r0

                /* CPU mode initialization as configured.*/
                movs    r0, #CRT0_CONTROL_INIT
 80000ce:	2002      	movs	r0, #2
                msr     CONTROL, r0
 80000d0:	f380 8814 	msr	CONTROL, r0
                isb
 80000d4:	f3bf 8f6f 	isb	sy
                str     r0, [r1]
#endif

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 80000d8:	f001 f942 	bl	8001360 <__core_init>
#endif

                /* Early initialization..*/
                bl      __early_init
 80000dc:	f000 ffe0 	bl	80010a0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80000e0:	481e      	ldr	r0, [pc, #120]	; (800015c <endfiniloop+0xe>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80000e2:	491f      	ldr	r1, [pc, #124]	; (8000160 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 80000e4:	4a1b      	ldr	r2, [pc, #108]	; (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
msloop:
                cmp     r1, r2
 80000e6:	4291      	cmp	r1, r2
                bge     endmsloop
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
                str     r0, [r1]
 80000ea:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000ec:	3104      	adds	r1, #4
                b       msloop
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
endmsloop:
                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80000f0:	491c      	ldr	r1, [pc, #112]	; (8000164 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 80000f2:	4a19      	ldr	r2, [pc, #100]	; (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
psloop:
                cmp     r1, r2
 80000f4:	4291      	cmp	r1, r2
                bge     endpsloop
 80000f6:	da02      	bge.n	80000fe <endpsloop>
                str     r0, [r1]
 80000f8:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000fa:	3104      	adds	r1, #4
                b       psloop
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata
 80000fe:	491a      	ldr	r1, [pc, #104]	; (8000168 <endfiniloop+0x1a>)
                ldr     r2, =_data
 8000100:	4a1a      	ldr	r2, [pc, #104]	; (800016c <endfiniloop+0x1e>)
                ldr     r3, =_edata
 8000102:	4b1b      	ldr	r3, [pc, #108]	; (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
dloop:
                cmp     r2, r3
 8000104:	429a      	cmp	r2, r3
                bge     enddloop
 8000106:	da04      	bge.n	8000112 <enddloop>
                ldr     r0, [r1]
 8000108:	6808      	ldr	r0, [r1, #0]
                str     r0, [r2]
 800010a:	6010      	str	r0, [r2, #0]
                adds    r1, #4
 800010c:	3104      	adds	r1, #4
                adds    r2, #4
 800010e:	3204      	adds	r2, #4
                b       dloop
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000112:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000114:	4917      	ldr	r1, [pc, #92]	; (8000174 <endfiniloop+0x26>)
                ldr     r2, =_bss_end
 8000116:	4a18      	ldr	r2, [pc, #96]	; (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
bloop:
                cmp     r1, r2
 8000118:	4291      	cmp	r1, r2
                bge     endbloop
 800011a:	da02      	bge.n	8000122 <endbloop>
                str     r0, [r1]
 800011c:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 800011e:	3104      	adds	r1, #4
                b       bloop
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
endbloop:
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000122:	f001 f8e5 	bl	80012f0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000126:	f001 f913 	bl	8001350 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800012a:	4c14      	ldr	r4, [pc, #80]	; (800017c <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end
 800012c:	4d14      	ldr	r5, [pc, #80]	; (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
initloop:
                cmp     r4, r5
 800012e:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000130:	da03      	bge.n	800013a <endinitloop>
                ldr     r1, [r4]
 8000132:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000134:	4788      	blx	r1
                adds    r4, #4
 8000136:	3404      	adds	r4, #4
                b       initloop
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 800013a:	f002 ffa1 	bl	8003080 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800013e:	4c11      	ldr	r4, [pc, #68]	; (8000184 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end
 8000140:	4d11      	ldr	r5, [pc, #68]	; (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
finiloop:
                cmp     r4, r5
 8000142:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000144:	da03      	bge.n	800014e <endfiniloop>
                ldr     r1, [r4]
 8000146:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000148:	4788      	blx	r1
                adds    r4, #4
 800014a:	3404      	adds	r4, #4
                b       finiloop
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                ldr     r1, =__default_exit
 800014e:	490f      	ldr	r1, [pc, #60]	; (800018c <endfiniloop+0x3e>)
                bx      r1
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
                /* Interrupts are globally masked initially.*/
                cpsid   i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000154:	20000200 	.word	0x20000200
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000158:	20000400 	.word	0x20000400

                /* Early initialization..*/
                bl      __early_init

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800015c:	55555555 	.word	0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000160:	20000000 	.word	0x20000000
                b       msloop
endmsloop:
                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000164:	20000200 	.word	0x20000200
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata
 8000168:	080070e4 	.word	0x080070e4
                ldr     r2, =_data
 800016c:	20000400 	.word	0x20000400
                ldr     r3, =_edata
 8000170:	20000430 	.word	0x20000430

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 8000174:	20000430 	.word	0x20000430
                ldr     r2, =_bss_end
 8000178:	20000f5c 	.word	0x20000f5c
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800017c:	080000c0 	.word	0x080000c0
                ldr     r5, =__init_array_end
 8000180:	080000c0 	.word	0x080000c0
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000184:	080000c0 	.word	0x080000c0
                ldr     r5, =__fini_array_end
 8000188:	080000c0 	.word	0x080000c0
                b       finiloop
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                ldr     r1, =__default_exit
 800018c:	08001341 	.word	0x08001341

08000190 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000190:	e796      	b.n	80000c0 <_crt0_entry>

08000192 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 8000192:	f000 f800 	bl	8000196 <_unhandled_exception>

08000196 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000196:	e7fe      	b.n	8000196 <_unhandled_exception>

08000198 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, lr}
 8000198:	b5f0      	push	{r4, r5, r6, r7, lr}
                mov     r4, r8
 800019a:	4644      	mov	r4, r8
                mov     r5, r9
 800019c:	464d      	mov	r5, r9
                mov     r6, r10
 800019e:	4656      	mov	r6, sl
                mov     r7, r11
 80001a0:	465f      	mov	r7, fp
                push    {r4, r5, r6, r7}
 80001a2:	b4f0      	push	{r4, r5, r6, r7}
                
                mov     r3, sp
 80001a4:	466b      	mov	r3, sp
                str     r3, [r1, #CONTEXT_OFFSET]
 80001a6:	60cb      	str	r3, [r1, #12]
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80001a8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80001aa:	469d      	mov	sp, r3
                
                pop     {r4, r5, r6, r7}
 80001ac:	bcf0      	pop	{r4, r5, r6, r7}
                mov     r8, r4
 80001ae:	46a0      	mov	r8, r4
                mov     r9, r5
 80001b0:	46a9      	mov	r9, r5
                mov     r10, r6
 80001b2:	46b2      	mov	sl, r6
                mov     r11, r7
 80001b4:	46bb      	mov	fp, r7
                pop     {r4, r5, r6, r7, pc}
 80001b6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b8 <_port_thread_start>:
                bl      _dbg_check_unlock
#endif
#if CH_DBG_STATISTICS
                bl      _stats_stop_measure_crit_thd
#endif
                cpsie   i
 80001b8:	b662      	cpsie	i
                mov     r0, r5
 80001ba:	1c28      	adds	r0, r5, #0
                blx     r4
 80001bc:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80001be:	2000      	movs	r0, #0
                bl      chThdExit
 80001c0:	f000 fbf6 	bl	80009b0 <chThdExit>

080001c4 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 80001c4:	f000 f984 	bl	80004d0 <chSchDoReschedule>

080001c8 <_port_exit_from_isr>:
#if CH_DBG_STATISTICS
                bl      _stats_stop_measure_crit_thd
#endif
                .globl  _port_exit_from_isr
_port_exit_from_isr:
                ldr     r2, .L2
 80001c8:	4a01      	ldr	r2, [pc, #4]	; (80001d0 <_port_exit_from_isr+0x8>)
                ldr     r3, .L3
 80001ca:	4b02      	ldr	r3, [pc, #8]	; (80001d4 <_port_exit_from_isr+0xc>)
                str     r3, [r2, #0]
 80001cc:	6013      	str	r3, [r2, #0]
#if CORTEX_ALTERNATE_SWITCH
                cpsie   i
#endif
.L1:            b       .L1
 80001ce:	e7fe      	b.n	80001ce <_port_exit_from_isr+0x6>
 80001d0:	e000ed04 	.word	0xe000ed04
 80001d4:	80000000 	.word	0x80000000

080001d8 <__aeabi_uidiv>:
 80001d8:	2200      	movs	r2, #0
 80001da:	0843      	lsrs	r3, r0, #1
 80001dc:	428b      	cmp	r3, r1
 80001de:	d374      	bcc.n	80002ca <__aeabi_uidiv+0xf2>
 80001e0:	0903      	lsrs	r3, r0, #4
 80001e2:	428b      	cmp	r3, r1
 80001e4:	d35f      	bcc.n	80002a6 <__aeabi_uidiv+0xce>
 80001e6:	0a03      	lsrs	r3, r0, #8
 80001e8:	428b      	cmp	r3, r1
 80001ea:	d344      	bcc.n	8000276 <__aeabi_uidiv+0x9e>
 80001ec:	0b03      	lsrs	r3, r0, #12
 80001ee:	428b      	cmp	r3, r1
 80001f0:	d328      	bcc.n	8000244 <__aeabi_uidiv+0x6c>
 80001f2:	0c03      	lsrs	r3, r0, #16
 80001f4:	428b      	cmp	r3, r1
 80001f6:	d30d      	bcc.n	8000214 <__aeabi_uidiv+0x3c>
 80001f8:	22ff      	movs	r2, #255	; 0xff
 80001fa:	0209      	lsls	r1, r1, #8
 80001fc:	ba12      	rev	r2, r2
 80001fe:	0c03      	lsrs	r3, r0, #16
 8000200:	428b      	cmp	r3, r1
 8000202:	d302      	bcc.n	800020a <__aeabi_uidiv+0x32>
 8000204:	1212      	asrs	r2, r2, #8
 8000206:	0209      	lsls	r1, r1, #8
 8000208:	d065      	beq.n	80002d6 <__aeabi_uidiv+0xfe>
 800020a:	0b03      	lsrs	r3, r0, #12
 800020c:	428b      	cmp	r3, r1
 800020e:	d319      	bcc.n	8000244 <__aeabi_uidiv+0x6c>
 8000210:	e000      	b.n	8000214 <__aeabi_uidiv+0x3c>
 8000212:	0a09      	lsrs	r1, r1, #8
 8000214:	0bc3      	lsrs	r3, r0, #15
 8000216:	428b      	cmp	r3, r1
 8000218:	d301      	bcc.n	800021e <__aeabi_uidiv+0x46>
 800021a:	03cb      	lsls	r3, r1, #15
 800021c:	1ac0      	subs	r0, r0, r3
 800021e:	4152      	adcs	r2, r2
 8000220:	0b83      	lsrs	r3, r0, #14
 8000222:	428b      	cmp	r3, r1
 8000224:	d301      	bcc.n	800022a <__aeabi_uidiv+0x52>
 8000226:	038b      	lsls	r3, r1, #14
 8000228:	1ac0      	subs	r0, r0, r3
 800022a:	4152      	adcs	r2, r2
 800022c:	0b43      	lsrs	r3, r0, #13
 800022e:	428b      	cmp	r3, r1
 8000230:	d301      	bcc.n	8000236 <__aeabi_uidiv+0x5e>
 8000232:	034b      	lsls	r3, r1, #13
 8000234:	1ac0      	subs	r0, r0, r3
 8000236:	4152      	adcs	r2, r2
 8000238:	0b03      	lsrs	r3, r0, #12
 800023a:	428b      	cmp	r3, r1
 800023c:	d301      	bcc.n	8000242 <__aeabi_uidiv+0x6a>
 800023e:	030b      	lsls	r3, r1, #12
 8000240:	1ac0      	subs	r0, r0, r3
 8000242:	4152      	adcs	r2, r2
 8000244:	0ac3      	lsrs	r3, r0, #11
 8000246:	428b      	cmp	r3, r1
 8000248:	d301      	bcc.n	800024e <__aeabi_uidiv+0x76>
 800024a:	02cb      	lsls	r3, r1, #11
 800024c:	1ac0      	subs	r0, r0, r3
 800024e:	4152      	adcs	r2, r2
 8000250:	0a83      	lsrs	r3, r0, #10
 8000252:	428b      	cmp	r3, r1
 8000254:	d301      	bcc.n	800025a <__aeabi_uidiv+0x82>
 8000256:	028b      	lsls	r3, r1, #10
 8000258:	1ac0      	subs	r0, r0, r3
 800025a:	4152      	adcs	r2, r2
 800025c:	0a43      	lsrs	r3, r0, #9
 800025e:	428b      	cmp	r3, r1
 8000260:	d301      	bcc.n	8000266 <__aeabi_uidiv+0x8e>
 8000262:	024b      	lsls	r3, r1, #9
 8000264:	1ac0      	subs	r0, r0, r3
 8000266:	4152      	adcs	r2, r2
 8000268:	0a03      	lsrs	r3, r0, #8
 800026a:	428b      	cmp	r3, r1
 800026c:	d301      	bcc.n	8000272 <__aeabi_uidiv+0x9a>
 800026e:	020b      	lsls	r3, r1, #8
 8000270:	1ac0      	subs	r0, r0, r3
 8000272:	4152      	adcs	r2, r2
 8000274:	d2cd      	bcs.n	8000212 <__aeabi_uidiv+0x3a>
 8000276:	09c3      	lsrs	r3, r0, #7
 8000278:	428b      	cmp	r3, r1
 800027a:	d301      	bcc.n	8000280 <__aeabi_uidiv+0xa8>
 800027c:	01cb      	lsls	r3, r1, #7
 800027e:	1ac0      	subs	r0, r0, r3
 8000280:	4152      	adcs	r2, r2
 8000282:	0983      	lsrs	r3, r0, #6
 8000284:	428b      	cmp	r3, r1
 8000286:	d301      	bcc.n	800028c <__aeabi_uidiv+0xb4>
 8000288:	018b      	lsls	r3, r1, #6
 800028a:	1ac0      	subs	r0, r0, r3
 800028c:	4152      	adcs	r2, r2
 800028e:	0943      	lsrs	r3, r0, #5
 8000290:	428b      	cmp	r3, r1
 8000292:	d301      	bcc.n	8000298 <__aeabi_uidiv+0xc0>
 8000294:	014b      	lsls	r3, r1, #5
 8000296:	1ac0      	subs	r0, r0, r3
 8000298:	4152      	adcs	r2, r2
 800029a:	0903      	lsrs	r3, r0, #4
 800029c:	428b      	cmp	r3, r1
 800029e:	d301      	bcc.n	80002a4 <__aeabi_uidiv+0xcc>
 80002a0:	010b      	lsls	r3, r1, #4
 80002a2:	1ac0      	subs	r0, r0, r3
 80002a4:	4152      	adcs	r2, r2
 80002a6:	08c3      	lsrs	r3, r0, #3
 80002a8:	428b      	cmp	r3, r1
 80002aa:	d301      	bcc.n	80002b0 <__aeabi_uidiv+0xd8>
 80002ac:	00cb      	lsls	r3, r1, #3
 80002ae:	1ac0      	subs	r0, r0, r3
 80002b0:	4152      	adcs	r2, r2
 80002b2:	0883      	lsrs	r3, r0, #2
 80002b4:	428b      	cmp	r3, r1
 80002b6:	d301      	bcc.n	80002bc <__aeabi_uidiv+0xe4>
 80002b8:	008b      	lsls	r3, r1, #2
 80002ba:	1ac0      	subs	r0, r0, r3
 80002bc:	4152      	adcs	r2, r2
 80002be:	0843      	lsrs	r3, r0, #1
 80002c0:	428b      	cmp	r3, r1
 80002c2:	d301      	bcc.n	80002c8 <__aeabi_uidiv+0xf0>
 80002c4:	004b      	lsls	r3, r1, #1
 80002c6:	1ac0      	subs	r0, r0, r3
 80002c8:	4152      	adcs	r2, r2
 80002ca:	1a41      	subs	r1, r0, r1
 80002cc:	d200      	bcs.n	80002d0 <__aeabi_uidiv+0xf8>
 80002ce:	4601      	mov	r1, r0
 80002d0:	4152      	adcs	r2, r2
 80002d2:	4610      	mov	r0, r2
 80002d4:	4770      	bx	lr
 80002d6:	e7ff      	b.n	80002d8 <__aeabi_uidiv+0x100>
 80002d8:	b501      	push	{r0, lr}
 80002da:	2000      	movs	r0, #0
 80002dc:	f000 f80c 	bl	80002f8 <__aeabi_idiv0>
 80002e0:	bd02      	pop	{r1, pc}
 80002e2:	46c0      	nop			; (mov r8, r8)

080002e4 <__aeabi_uidivmod>:
 80002e4:	2900      	cmp	r1, #0
 80002e6:	d0f7      	beq.n	80002d8 <__aeabi_uidiv+0x100>
 80002e8:	b503      	push	{r0, r1, lr}
 80002ea:	f7ff ff75 	bl	80001d8 <__aeabi_uidiv>
 80002ee:	bc0e      	pop	{r1, r2, r3}
 80002f0:	4342      	muls	r2, r0
 80002f2:	1a89      	subs	r1, r1, r2
 80002f4:	4718      	bx	r3
 80002f6:	46c0      	nop			; (mov r8, r8)

080002f8 <__aeabi_idiv0>:
 80002f8:	4770      	bx	lr
 80002fa:	46c0      	nop			; (mov r8, r8)
 80002fc:	0000      	movs	r0, r0
	...

08000300 <wakeup.lto_priv.149>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000300:	b672      	cpsid	i
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8000302:	2320      	movs	r3, #32
 8000304:	5cc3      	ldrb	r3, [r0, r3]
 8000306:	2b07      	cmp	r3, #7
 8000308:	d80c      	bhi.n	8000324 <wakeup.lto_priv.149+0x24>
 800030a:	4a12      	ldr	r2, [pc, #72]	; (8000354 <wakeup.lto_priv.149+0x54>)
 800030c:	009b      	lsls	r3, r3, #2
 800030e:	58d3      	ldr	r3, [r2, r3]
 8000310:	469f      	mov	pc, r3
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8000312:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8000314:	6893      	ldr	r3, [r2, #8]
 8000316:	3301      	adds	r3, #1
 8000318:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800031a:	6802      	ldr	r2, [r0, #0]
 800031c:	6843      	ldr	r3, [r0, #4]
 800031e:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8000320:	6802      	ldr	r2, [r0, #0]
 8000322:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8000324:	2301      	movs	r3, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000326:	2200      	movs	r2, #0
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8000328:	425b      	negs	r3, r3
 800032a:	6243      	str	r3, [r0, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800032c:	3321      	adds	r3, #33	; 0x21
 800032e:	54c2      	strb	r2, [r0, r3]
 8000330:	6882      	ldr	r2, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000332:	4b09      	ldr	r3, [pc, #36]	; (8000358 <wakeup.lto_priv.149+0x58>)
  do {
    cp = cp->queue.next;
 8000334:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8000336:	6899      	ldr	r1, [r3, #8]
 8000338:	4291      	cmp	r1, r2
 800033a:	d2fb      	bcs.n	8000334 <wakeup.lto_priv.149+0x34>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800033c:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800033e:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8000340:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8000342:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8000344:	6058      	str	r0, [r3, #4]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000346:	b662      	cpsie	i
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8000348:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800034a:	2200      	movs	r2, #0
 800034c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800034e:	601a      	str	r2, [r3, #0]
 8000350:	e7e8      	b.n	8000324 <wakeup.lto_priv.149+0x24>
 8000352:	46c0      	nop			; (mov r8, r8)
 8000354:	0800544c 	.word	0x0800544c
 8000358:	20000e84 	.word	0x20000e84
 800035c:	46c0      	nop			; (mov r8, r8)
 800035e:	46c0      	nop			; (mov r8, r8)

08000360 <_idle_thread.lto_priv.63>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000360:	e7fe      	b.n	8000360 <_idle_thread.lto_priv.63>
 8000362:	46c0      	nop			; (mov r8, r8)
 8000364:	46c0      	nop			; (mov r8, r8)
 8000366:	46c0      	nop			; (mov r8, r8)
 8000368:	46c0      	nop			; (mov r8, r8)
 800036a:	46c0      	nop			; (mov r8, r8)
 800036c:	46c0      	nop			; (mov r8, r8)
 800036e:	46c0      	nop			; (mov r8, r8)

08000370 <notify2.lto_priv.60>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000370:	23c0      	movs	r3, #192	; 0xc0
 8000372:	4a02      	ldr	r2, [pc, #8]	; (800037c <notify2.lto_priv.60+0xc>)
 8000374:	6811      	ldr	r1, [r2, #0]
 8000376:	430b      	orrs	r3, r1
 8000378:	6013      	str	r3, [r2, #0]
}
 800037a:	4770      	bx	lr
 800037c:	40004400 	.word	0x40004400

08000380 <notify1.lto_priv.59>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000380:	23c0      	movs	r3, #192	; 0xc0
 8000382:	4a02      	ldr	r2, [pc, #8]	; (800038c <notify1.lto_priv.59+0xc>)
 8000384:	6811      	ldr	r1, [r2, #0]
 8000386:	430b      	orrs	r3, r1
 8000388:	6013      	str	r3, [r2, #0]
}
 800038a:	4770      	bx	lr
 800038c:	40013800 	.word	0x40013800

08000390 <_ctl.lto_priv.72>:
#else
    break;
#endif
  }
  return MSG_OK;
}
 8000390:	2000      	movs	r0, #0
 8000392:	4770      	bx	lr
 8000394:	46c0      	nop			; (mov r8, r8)
 8000396:	46c0      	nop			; (mov r8, r8)
 8000398:	46c0      	nop			; (mov r8, r8)
 800039a:	46c0      	nop			; (mov r8, r8)
 800039c:	46c0      	nop			; (mov r8, r8)
 800039e:	46c0      	nop			; (mov r8, r8)

080003a0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80003a0:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 80003a2:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80003a4:	1c06      	adds	r6, r0, #0
 80003a6:	1c0d      	adds	r5, r1, #0
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80003a8:	42a0      	cmp	r0, r4
 80003aa:	d00e      	beq.n	80003ca <chEvtBroadcastFlagsI+0x2a>
  /*lint -restore*/
    elp->flags |= flags;
 80003ac:	68e3      	ldr	r3, [r4, #12]
 80003ae:	432b      	orrs	r3, r5
 80003b0:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80003b2:	2d00      	cmp	r5, #0
 80003b4:	d002      	beq.n	80003bc <chEvtBroadcastFlagsI+0x1c>
 80003b6:	6923      	ldr	r3, [r4, #16]
 80003b8:	422b      	tst	r3, r5
 80003ba:	d003      	beq.n	80003c4 <chEvtBroadcastFlagsI+0x24>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 80003bc:	6860      	ldr	r0, [r4, #4]
 80003be:	68a1      	ldr	r1, [r4, #8]
 80003c0:	f003 fed6 	bl	8004170 <chEvtSignalI>
    }
    elp = elp->next;
 80003c4:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80003c6:	42a6      	cmp	r6, r4
 80003c8:	d1f0      	bne.n	80003ac <chEvtBroadcastFlagsI+0xc>
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
  }
}
 80003ca:	bd70      	pop	{r4, r5, r6, pc}
 80003cc:	46c0      	nop			; (mov r8, r8)
 80003ce:	46c0      	nop			; (mov r8, r8)

080003d0 <chEvtAddEvents>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80003d0:	b672      	cpsid	i
 *
 * @iclass
 */
static inline eventmask_t chEvtAddEventsI(eventmask_t events) {

  return currp->epending |= events;
 80003d2:	4b03      	ldr	r3, [pc, #12]	; (80003e0 <chEvtAddEvents+0x10>)
 80003d4:	699b      	ldr	r3, [r3, #24]
 80003d6:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80003d8:	4310      	orrs	r0, r2
 80003da:	6358      	str	r0, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80003dc:	b662      	cpsie	i
  chSysLock();
  newevt = chEvtAddEventsI(events);
  chSysUnlock();

  return newevt;
}
 80003de:	4770      	bx	lr
 80003e0:	20000e84 	.word	0x20000e84
 80003e4:	46c0      	nop			; (mov r8, r8)
 80003e6:	46c0      	nop			; (mov r8, r8)
 80003e8:	46c0      	nop			; (mov r8, r8)
 80003ea:	46c0      	nop			; (mov r8, r8)
 80003ec:	46c0      	nop			; (mov r8, r8)
 80003ee:	46c0      	nop			; (mov r8, r8)

080003f0 <chEvtUnregister>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80003f0:	b672      	cpsid	i
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 80003f2:	1c02      	adds	r2, r0, #0
 80003f4:	e002      	b.n	80003fc <chEvtUnregister+0xc>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->next == elp) {
 80003f6:	428b      	cmp	r3, r1
 80003f8:	d005      	beq.n	8000406 <chEvtUnregister+0x16>
 80003fa:	1c1a      	adds	r2, r3, #0
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
 80003fc:	6813      	ldr	r3, [r2, #0]
 80003fe:	4283      	cmp	r3, r0
 8000400:	d1f9      	bne.n	80003f6 <chEvtUnregister+0x6>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000402:	b662      	cpsie	i
      break;
    }
    p = p->next;
  }
  chSysUnlock();
}
 8000404:	4770      	bx	lr
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->next == elp) {
      p->next = elp->next;
 8000406:	680b      	ldr	r3, [r1, #0]
 8000408:	6013      	str	r3, [r2, #0]
 800040a:	e7fa      	b.n	8000402 <chEvtUnregister+0x12>
 800040c:	46c0      	nop			; (mov r8, r8)
 800040e:	46c0      	nop			; (mov r8, r8)

08000410 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8000410:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000412:	b672      	cpsid	i
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 8000414:	4c0f      	ldr	r4, [pc, #60]	; (8000454 <chThdYield+0x44>)
 8000416:	6820      	ldr	r0, [r4, #0]
 8000418:	69a1      	ldr	r1, [r4, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 800041a:	6883      	ldr	r3, [r0, #8]
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 800041c:	688a      	ldr	r2, [r1, #8]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 800041e:	4293      	cmp	r3, r2
 8000420:	d201      	bcs.n	8000426 <chThdYield+0x16>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000422:	b662      	cpsie	i

  chSysLock();
  chSchDoYieldS();
  chSysUnlock();
}
 8000424:	bd38      	pop	{r3, r4, r5, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000426:	6803      	ldr	r3, [r0, #0]
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000428:	2501      	movs	r5, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 800042a:	605c      	str	r4, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800042c:	6023      	str	r3, [r4, #0]
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800042e:	61a0      	str	r0, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 8000430:	2420      	movs	r4, #32
 8000432:	5505      	strb	r5, [r0, r4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000434:	2500      	movs	r5, #0
 8000436:	550d      	strb	r5, [r1, r4]
 8000438:	e000      	b.n	800043c <chThdYield+0x2c>
 800043a:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
 800043c:	689c      	ldr	r4, [r3, #8]
 800043e:	42a2      	cmp	r2, r4
 8000440:	d9fb      	bls.n	800043a <chThdYield+0x2a>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000442:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000444:	600b      	str	r3, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 8000446:	604a      	str	r2, [r1, #4]
  tp->queue.prev->queue.next = tp;
 8000448:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 800044a:	6059      	str	r1, [r3, #4]

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800044c:	f7ff fea4 	bl	8000198 <_port_switch>
 8000450:	e7e7      	b.n	8000422 <chThdYield+0x12>
 8000452:	46c0      	nop			; (mov r8, r8)
 8000454:	20000e84 	.word	0x20000e84
 8000458:	46c0      	nop			; (mov r8, r8)
 800045a:	46c0      	nop			; (mov r8, r8)
 800045c:	46c0      	nop			; (mov r8, r8)
 800045e:	46c0      	nop			; (mov r8, r8)

08000460 <chThdCreateSuspendedI>:
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8000460:	6882      	ldr	r2, [r0, #8]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8000462:	6841      	ldr	r1, [r0, #4]
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8000464:	1c13      	adds	r3, r2, #0
 8000466:	3b48      	subs	r3, #72	; 0x48
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8000468:	b510      	push	{r4, lr}
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 800046a:	61d9      	str	r1, [r3, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800046c:	1c11      	adds	r1, r2, #0
 800046e:	6904      	ldr	r4, [r0, #16]
 8000470:	396c      	subs	r1, #108	; 0x6c
 8000472:	60d9      	str	r1, [r3, #12]
 8000474:	610c      	str	r4, [r1, #16]
 8000476:	6944      	ldr	r4, [r0, #20]
 8000478:	614c      	str	r4, [r1, #20]
 800047a:	4c10      	ldr	r4, [pc, #64]	; (80004bc <chThdCreateSuspendedI+0x5c>)
 800047c:	620c      	str	r4, [r1, #32]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 800047e:	6801      	ldr	r1, [r0, #0]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000480:	2402      	movs	r4, #2

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8000482:	6199      	str	r1, [r3, #24]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8000484:	2120      	movs	r1, #32

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8000486:	68c0      	ldr	r0, [r0, #12]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000488:	6098      	str	r0, [r3, #8]
  tp->state     = CH_STATE_WTSTART;
 800048a:	545c      	strb	r4, [r3, r1]
  tp->flags     = CH_FLAG_MODE_STATIC;
 800048c:	2100      	movs	r1, #0
 800048e:	341f      	adds	r4, #31
 8000490:	5519      	strb	r1, [r3, r4]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000492:	63d8      	str	r0, [r3, #60]	; 0x3c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000494:	2001      	movs	r0, #1
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8000496:	6399      	str	r1, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000498:	6359      	str	r1, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800049a:	3122      	adds	r1, #34	; 0x22
 800049c:	5458      	strb	r0, [r3, r1]
  tp->name      = name;
  REG_INSERT(tp);
 800049e:	4908      	ldr	r1, [pc, #32]	; (80004c0 <chThdCreateSuspendedI+0x60>)
 80004a0:	6948      	ldr	r0, [r1, #20]
 80004a2:	6119      	str	r1, [r3, #16]
 80004a4:	6158      	str	r0, [r3, #20]
 80004a6:	6103      	str	r3, [r0, #16]
 80004a8:	614b      	str	r3, [r1, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 80004aa:	1c11      	adds	r1, r2, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 80004ac:	3a1c      	subs	r2, #28
 80004ae:	3920      	subs	r1, #32
 80004b0:	6009      	str	r1, [r1, #0]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 80004b2:	1c18      	adds	r0, r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80004b4:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 80004b6:	6052      	str	r2, [r2, #4]
 80004b8:	bd10      	pop	{r4, pc}
 80004ba:	46c0      	nop			; (mov r8, r8)
 80004bc:	080001b9 	.word	0x080001b9
 80004c0:	20000e84 	.word	0x20000e84
 80004c4:	46c0      	nop			; (mov r8, r8)
 80004c6:	46c0      	nop			; (mov r8, r8)
 80004c8:	46c0      	nop			; (mov r8, r8)
 80004ca:	46c0      	nop			; (mov r8, r8)
 80004cc:	46c0      	nop			; (mov r8, r8)
 80004ce:	46c0      	nop			; (mov r8, r8)

080004d0 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 80004d0:	4a0d      	ldr	r2, [pc, #52]	; (8000508 <chSchDoReschedule+0x38>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 80004d2:	b510      	push	{r4, lr}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80004d4:	6810      	ldr	r0, [r2, #0]
  thread_t *otp = currp;
 80004d6:	6991      	ldr	r1, [r2, #24]

  tqp->next             = tp->queue.next;
 80004d8:	6803      	ldr	r3, [r0, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80004da:	2401      	movs	r4, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80004dc:	605a      	str	r2, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80004de:	6013      	str	r3, [r2, #0]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80004e0:	6190      	str	r0, [r2, #24]
  currp->state = CH_STATE_CURRENT;
 80004e2:	2220      	movs	r2, #32
 80004e4:	5484      	strb	r4, [r0, r2]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80004e6:	2400      	movs	r4, #0
 80004e8:	548c      	strb	r4, [r1, r2]
 80004ea:	688a      	ldr	r2, [r1, #8]
 80004ec:	e000      	b.n	80004f0 <chSchDoReschedule+0x20>
 80004ee:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 80004f0:	689c      	ldr	r4, [r3, #8]
 80004f2:	4294      	cmp	r4, r2
 80004f4:	d8fb      	bhi.n	80004ee <chSchDoReschedule+0x1e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80004f6:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80004f8:	600b      	str	r3, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 80004fa:	604a      	str	r2, [r1, #4]
  tp->queue.prev->queue.next = tp;
 80004fc:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 80004fe:	6059      	str	r1, [r3, #4]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000500:	f7ff fe4a 	bl	8000198 <_port_switch>
}
 8000504:	bd10      	pop	{r4, pc}
 8000506:	46c0      	nop			; (mov r8, r8)
 8000508:	20000e84 	.word	0x20000e84
 800050c:	46c0      	nop			; (mov r8, r8)
 800050e:	46c0      	nop			; (mov r8, r8)

08000510 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8000510:	b538      	push	{r3, r4, r5, lr}
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8000512:	4c0f      	ldr	r4, [pc, #60]	; (8000550 <chSchRescheduleS+0x40>)
 8000514:	6820      	ldr	r0, [r4, #0]
 8000516:	69a1      	ldr	r1, [r4, #24]

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000518:	6883      	ldr	r3, [r0, #8]
 800051a:	688a      	ldr	r2, [r1, #8]
 800051c:	4293      	cmp	r3, r2
 800051e:	d800      	bhi.n	8000522 <chSchRescheduleS+0x12>
    chSchDoRescheduleAhead();
  }
}
 8000520:	bd38      	pop	{r3, r4, r5, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000522:	6803      	ldr	r3, [r0, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000524:	2501      	movs	r5, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8000526:	605c      	str	r4, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000528:	6023      	str	r3, [r4, #0]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800052a:	61a0      	str	r0, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 800052c:	2420      	movs	r4, #32
 800052e:	5505      	strb	r5, [r0, r4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000530:	2500      	movs	r5, #0
 8000532:	550d      	strb	r5, [r1, r4]
 8000534:	e000      	b.n	8000538 <chSchRescheduleS+0x28>
 8000536:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 8000538:	689c      	ldr	r4, [r3, #8]
 800053a:	42a2      	cmp	r2, r4
 800053c:	d3fb      	bcc.n	8000536 <chSchRescheduleS+0x26>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800053e:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8000540:	600b      	str	r3, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 8000542:	604a      	str	r2, [r1, #4]
  tp->queue.prev->queue.next = tp;
 8000544:	6011      	str	r1, [r2, #0]
  cp->queue.prev             = tp;
 8000546:	6059      	str	r1, [r3, #4]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000548:	f7ff fe26 	bl	8000198 <_port_switch>
 800054c:	e7e8      	b.n	8000520 <chSchRescheduleS+0x10>
 800054e:	46c0      	nop			; (mov r8, r8)
 8000550:	20000e84 	.word	0x20000e84
 8000554:	46c0      	nop			; (mov r8, r8)
 8000556:	46c0      	nop			; (mov r8, r8)
 8000558:	46c0      	nop			; (mov r8, r8)
 800055a:	46c0      	nop			; (mov r8, r8)
 800055c:	46c0      	nop			; (mov r8, r8)
 800055e:	46c0      	nop			; (mov r8, r8)

08000560 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8000560:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000562:	b672      	cpsid	i

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 8000564:	4b07      	ldr	r3, [pc, #28]	; (8000584 <chThdSetPriority+0x24>)
 8000566:	699b      	ldr	r3, [r3, #24]
 8000568:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 800056a:	689a      	ldr	r2, [r3, #8]
 800056c:	4294      	cmp	r4, r2
 800056e:	d001      	beq.n	8000574 <chThdSetPriority+0x14>
 8000570:	4282      	cmp	r2, r0
 8000572:	d200      	bcs.n	8000576 <chThdSetPriority+0x16>
    currp->prio = newprio;
 8000574:	6098      	str	r0, [r3, #8]
  }
  currp->realprio = newprio;
 8000576:	63d8      	str	r0, [r3, #60]	; 0x3c
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
 8000578:	f7ff ffca 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800057c:	b662      	cpsie	i
  chSysUnlock();

  return oldprio;
}
 800057e:	1c20      	adds	r0, r4, #0
 8000580:	bd10      	pop	{r4, pc}
 8000582:	46c0      	nop			; (mov r8, r8)
 8000584:	20000e84 	.word	0x20000e84
 8000588:	46c0      	nop			; (mov r8, r8)
 800058a:	46c0      	nop			; (mov r8, r8)
 800058c:	46c0      	nop			; (mov r8, r8)
 800058e:	46c0      	nop			; (mov r8, r8)

08000590 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000590:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8000592:	4b14      	ldr	r3, [pc, #80]	; (80005e4 <chSchWakeupS+0x54>)

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8000594:	6882      	ldr	r2, [r0, #8]
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 8000596:	699d      	ldr	r5, [r3, #24]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8000598:	6241      	str	r1, [r0, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800059a:	68ac      	ldr	r4, [r5, #8]
 800059c:	42a2      	cmp	r2, r4
 800059e:	d80c      	bhi.n	80005ba <chSchWakeupS+0x2a>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80005a0:	2400      	movs	r4, #0
 80005a2:	2120      	movs	r1, #32
 80005a4:	5444      	strb	r4, [r0, r1]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 80005a6:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80005a8:	6899      	ldr	r1, [r3, #8]
 80005aa:	428a      	cmp	r2, r1
 80005ac:	d9fb      	bls.n	80005a6 <chSchWakeupS+0x16>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80005ae:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80005b0:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 80005b2:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 80005b4:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 80005b6:	6058      	str	r0, [r3, #4]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 80005b8:	bd38      	pop	{r3, r4, r5, pc}
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80005ba:	2220      	movs	r2, #32
 80005bc:	2100      	movs	r1, #0
 80005be:	54a9      	strb	r1, [r5, r2]
  cp = (thread_t *)&ch.rlist.queue;
 80005c0:	1c1a      	adds	r2, r3, #0
  do {
    cp = cp->queue.next;
 80005c2:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 80005c4:	6891      	ldr	r1, [r2, #8]
 80005c6:	428c      	cmp	r4, r1
 80005c8:	d9fb      	bls.n	80005c2 <chSchWakeupS+0x32>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80005ca:	6851      	ldr	r1, [r2, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80005cc:	602a      	str	r2, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 80005ce:	6069      	str	r1, [r5, #4]
  tp->queue.prev->queue.next = tp;
 80005d0:	600d      	str	r5, [r1, #0]
  cp->queue.prev             = tp;
 80005d2:	6055      	str	r5, [r2, #4]
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80005d4:	6198      	str	r0, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
 80005d6:	2201      	movs	r2, #1
 80005d8:	2320      	movs	r3, #32

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80005da:	1c29      	adds	r1, r5, #0
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 80005dc:	54c2      	strb	r2, [r0, r3]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80005de:	f7ff fddb 	bl	8000198 <_port_switch>
 80005e2:	e7e9      	b.n	80005b8 <chSchWakeupS+0x28>
 80005e4:	20000e84 	.word	0x20000e84
 80005e8:	46c0      	nop			; (mov r8, r8)
 80005ea:	46c0      	nop			; (mov r8, r8)
 80005ec:	46c0      	nop			; (mov r8, r8)
 80005ee:	46c0      	nop			; (mov r8, r8)

080005f0 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 80005f0:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80005f2:	b672      	cpsid	i

  chSysLock();
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");
  if (++sp->cnt <= (cnt_t)0) {
 80005f4:	6883      	ldr	r3, [r0, #8]
 80005f6:	3301      	adds	r3, #1
 80005f8:	6083      	str	r3, [r0, #8]
 80005fa:	2b00      	cmp	r3, #0
 80005fc:	dd01      	ble.n	8000602 <chSemSignal+0x12>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80005fe:	b662      	cpsie	i
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
  }
  chSysUnlock();
}
 8000600:	bd08      	pop	{r3, pc}
 8000602:	1c03      	adds	r3, r0, #0
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8000604:	6800      	ldr	r0, [r0, #0]
  chSysLock();
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");
  if (++sp->cnt <= (cnt_t)0) {
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
 8000606:	2100      	movs	r1, #0

  tqp->next             = tp->queue.next;
 8000608:	6802      	ldr	r2, [r0, #0]
 800060a:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800060c:	6053      	str	r3, [r2, #4]
 800060e:	f7ff ffbf 	bl	8000590 <chSchWakeupS>
 8000612:	e7f4      	b.n	80005fe <chSemSignal+0xe>
 8000614:	46c0      	nop			; (mov r8, r8)
 8000616:	46c0      	nop			; (mov r8, r8)
 8000618:	46c0      	nop			; (mov r8, r8)
 800061a:	46c0      	nop			; (mov r8, r8)
 800061c:	46c0      	nop			; (mov r8, r8)
 800061e:	46c0      	nop			; (mov r8, r8)

08000620 <chSchGoSleepS>:
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8000620:	2220      	movs	r2, #32
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 8000622:	4b07      	ldr	r3, [pc, #28]	; (8000640 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000624:	b510      	push	{r4, lr}
  thread_t *otp = currp;
 8000626:	6999      	ldr	r1, [r3, #24]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8000628:	5488      	strb	r0, [r1, r2]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800062a:	6818      	ldr	r0, [r3, #0]

  tqp->next             = tp->queue.next;
 800062c:	6804      	ldr	r4, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800062e:	6063      	str	r3, [r4, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000630:	601c      	str	r4, [r3, #0]
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000632:	6198      	str	r0, [r3, #24]
  currp->state = CH_STATE_CURRENT;
 8000634:	2301      	movs	r3, #1
 8000636:	5483      	strb	r3, [r0, r2]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000638:	f7ff fdae 	bl	8000198 <_port_switch>
}
 800063c:	bd10      	pop	{r4, pc}
 800063e:	46c0      	nop			; (mov r8, r8)
 8000640:	20000e84 	.word	0x20000e84
 8000644:	46c0      	nop			; (mov r8, r8)
 8000646:	46c0      	nop			; (mov r8, r8)
 8000648:	46c0      	nop			; (mov r8, r8)
 800064a:	46c0      	nop			; (mov r8, r8)
 800064c:	46c0      	nop			; (mov r8, r8)
 800064e:	46c0      	nop			; (mov r8, r8)

08000650 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8000650:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000652:	b672      	cpsid	i
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8000654:	6883      	ldr	r3, [r0, #8]
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->u.rdymsg;
  }

  return MSG_OK;
 8000656:	2200      	movs	r2, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8000658:	3b01      	subs	r3, #1
 800065a:	6083      	str	r3, [r0, #8]
 800065c:	2b00      	cmp	r3, #0
 800065e:	db02      	blt.n	8000666 <chSemWait+0x16>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000660:	b662      	cpsie	i
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8000662:	1c10      	adds	r0, r2, #0
 8000664:	bd10      	pop	{r4, pc}
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    currp->u.wtsemp = sp;
 8000666:	4c07      	ldr	r4, [pc, #28]	; (8000684 <chSemWait+0x34>)
 8000668:	69a3      	ldr	r3, [r4, #24]
 800066a:	6258      	str	r0, [r3, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 800066c:	6842      	ldr	r2, [r0, #4]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 800066e:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
 8000670:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8000672:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 8000674:	6043      	str	r3, [r0, #4]
    sem_insert(currp, &sp->queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 8000676:	2005      	movs	r0, #5
 8000678:	f7ff ffd2 	bl	8000620 <chSchGoSleepS>

    return currp->u.rdymsg;
 800067c:	69a3      	ldr	r3, [r4, #24]
 800067e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000680:	e7ee      	b.n	8000660 <chSemWait+0x10>
 8000682:	46c0      	nop			; (mov r8, r8)
 8000684:	20000e84 	.word	0x20000e84
 8000688:	46c0      	nop			; (mov r8, r8)
 800068a:	46c0      	nop			; (mov r8, r8)
 800068c:	46c0      	nop			; (mov r8, r8)
 800068e:	46c0      	nop			; (mov r8, r8)

08000690 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8000690:	2200      	movs	r2, #0
 8000692:	2320      	movs	r3, #32
 8000694:	54c2      	strb	r2, [r0, r3]
 8000696:	6882      	ldr	r2, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8000698:	4b05      	ldr	r3, [pc, #20]	; (80006b0 <chSchReadyI+0x20>)
  do {
    cp = cp->queue.next;
 800069a:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800069c:	6899      	ldr	r1, [r3, #8]
 800069e:	4291      	cmp	r1, r2
 80006a0:	d2fb      	bcs.n	800069a <chSchReadyI+0xa>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80006a2:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80006a4:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 80006a6:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 80006a8:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 80006aa:	6058      	str	r0, [r3, #4]

  return tp;
}
 80006ac:	4770      	bx	lr
 80006ae:	46c0      	nop			; (mov r8, r8)
 80006b0:	20000e84 	.word	0x20000e84
 80006b4:	46c0      	nop			; (mov r8, r8)
 80006b6:	46c0      	nop			; (mov r8, r8)
 80006b8:	46c0      	nop			; (mov r8, r8)
 80006ba:	46c0      	nop			; (mov r8, r8)
 80006bc:	46c0      	nop			; (mov r8, r8)
 80006be:	46c0      	nop			; (mov r8, r8)

080006c0 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 80006c0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 80006c2:	4b11      	ldr	r3, [pc, #68]	; (8000708 <chMtxUnlockS+0x48>)
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80006c4:	6804      	ldr	r4, [r0, #0]
 80006c6:	699d      	ldr	r5, [r3, #24]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 80006c8:	68c3      	ldr	r3, [r0, #12]
 80006ca:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80006cc:	42a0      	cmp	r0, r4
 80006ce:	d018      	beq.n	8000702 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 80006d0:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80006d2:	2b00      	cmp	r3, #0
 80006d4:	d009      	beq.n	80006ea <chMtxUnlockS+0x2a>
 80006d6:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80006d8:	4293      	cmp	r3, r2
 80006da:	d003      	beq.n	80006e4 <chMtxUnlockS+0x24>
            (lmp->queue.next->prio > newprio)) {
 80006dc:	6892      	ldr	r2, [r2, #8]
 80006de:	4291      	cmp	r1, r2
 80006e0:	d200      	bcs.n	80006e4 <chMtxUnlockS+0x24>
 80006e2:	1c11      	adds	r1, r2, #0
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 80006e4:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80006e6:	2b00      	cmp	r3, #0
 80006e8:	d1f5      	bne.n	80006d6 <chMtxUnlockS+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80006ea:	6822      	ldr	r2, [r4, #0]
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 80006ec:	60a9      	str	r1, [r5, #8]
 80006ee:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80006f0:	6050      	str	r0, [r2, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 80006f2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 80006f4:	6084      	str	r4, [r0, #8]
      mp->next = tp->mtxlist;
 80006f6:	60c2      	str	r2, [r0, #12]
      tp->mtxlist = mp;
 80006f8:	63a0      	str	r0, [r4, #56]	; 0x38
      (void) chSchReadyI(tp);
 80006fa:	1c20      	adds	r0, r4, #0
 80006fc:	f7ff ffc8 	bl	8000690 <chSchReadyI>
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8000700:	bd38      	pop	{r3, r4, r5, pc}
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
    }
    else {
      mp->owner = NULL;
 8000702:	2300      	movs	r3, #0
 8000704:	6083      	str	r3, [r0, #8]
 8000706:	e7fb      	b.n	8000700 <chMtxUnlockS+0x40>
 8000708:	20000e84 	.word	0x20000e84
 800070c:	46c0      	nop			; (mov r8, r8)
 800070e:	46c0      	nop			; (mov r8, r8)

08000710 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8000710:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 8000712:	4b13      	ldr	r3, [pc, #76]	; (8000760 <chMtxUnlock+0x50>)
 8000714:	699d      	ldr	r5, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000716:	b672      	cpsid	i
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8000718:	68c3      	ldr	r3, [r0, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800071a:	6804      	ldr	r4, [r0, #0]
 800071c:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800071e:	42a0      	cmp	r0, r4
 8000720:	d01b      	beq.n	800075a <chMtxUnlock+0x4a>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8000722:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8000724:	2b00      	cmp	r3, #0
 8000726:	d009      	beq.n	800073c <chMtxUnlock+0x2c>
 8000728:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800072a:	4293      	cmp	r3, r2
 800072c:	d003      	beq.n	8000736 <chMtxUnlock+0x26>
            (lmp->queue.next->prio > newprio)) {
 800072e:	6892      	ldr	r2, [r2, #8]
 8000730:	4291      	cmp	r1, r2
 8000732:	d200      	bcs.n	8000736 <chMtxUnlock+0x26>
 8000734:	1c11      	adds	r1, r2, #0
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8000736:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8000738:	2b00      	cmp	r3, #0
 800073a:	d1f5      	bne.n	8000728 <chMtxUnlock+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800073c:	6822      	ldr	r2, [r4, #0]
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 800073e:	60a9      	str	r1, [r5, #8]
 8000740:	6002      	str	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000742:	6050      	str	r0, [r2, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8000744:	6ba2      	ldr	r2, [r4, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8000746:	6084      	str	r4, [r0, #8]
      mp->next = tp->mtxlist;
 8000748:	60c2      	str	r2, [r0, #12]
      tp->mtxlist = mp;
 800074a:	63a0      	str	r0, [r4, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 800074c:	1c20      	adds	r0, r4, #0
 800074e:	f7ff ff9f 	bl	8000690 <chSchReadyI>
      chSchRescheduleS();
 8000752:	f7ff fedd 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000756:	b662      	cpsie	i
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 8000758:	bd38      	pop	{r3, r4, r5, pc}
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 800075a:	2300      	movs	r3, #0
 800075c:	6083      	str	r3, [r0, #8]
 800075e:	e7fa      	b.n	8000756 <chMtxUnlock+0x46>
 8000760:	20000e84 	.word	0x20000e84
 8000764:	46c0      	nop			; (mov r8, r8)
 8000766:	46c0      	nop			; (mov r8, r8)
 8000768:	46c0      	nop			; (mov r8, r8)
 800076a:	46c0      	nop			; (mov r8, r8)
 800076c:	46c0      	nop			; (mov r8, r8)
 800076e:	46c0      	nop			; (mov r8, r8)

08000770 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8000770:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8000772:	6882      	ldr	r2, [r0, #8]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8000774:	4b2f      	ldr	r3, [pc, #188]	; (8000834 <chMtxLockS+0xc4>)
 8000776:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8000778:	2a00      	cmp	r2, #0
 800077a:	d056      	beq.n	800082a <chMtxLockS+0xba>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800077c:	68a1      	ldr	r1, [r4, #8]
 800077e:	6893      	ldr	r3, [r2, #8]
 8000780:	1c05      	adds	r5, r0, #0
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8000782:	2620      	movs	r6, #32
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8000784:	4299      	cmp	r1, r3
 8000786:	d907      	bls.n	8000798 <chMtxLockS+0x28>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 8000788:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800078a:	5d93      	ldrb	r3, [r2, r6]
 800078c:	2b06      	cmp	r3, #6
 800078e:	d033      	beq.n	80007f8 <chMtxLockS+0x88>
 8000790:	2b07      	cmp	r3, #7
 8000792:	d01d      	beq.n	80007d0 <chMtxLockS+0x60>
 8000794:	2b00      	cmp	r3, #0
 8000796:	d012      	beq.n	80007be <chMtxLockS+0x4e>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000798:	1c2b      	adds	r3, r5, #0
 800079a:	e003      	b.n	80007a4 <chMtxLockS+0x34>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800079c:	689a      	ldr	r2, [r3, #8]
 800079e:	68a1      	ldr	r1, [r4, #8]
 80007a0:	428a      	cmp	r2, r1
 80007a2:	d302      	bcc.n	80007aa <chMtxLockS+0x3a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 80007a4:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80007a6:	429d      	cmp	r5, r3
 80007a8:	d1f8      	bne.n	800079c <chMtxLockS+0x2c>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80007aa:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 80007ac:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 80007ae:	6062      	str	r2, [r4, #4]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 80007b0:	2006      	movs	r0, #6
  tp->queue.prev->queue.next = tp;
 80007b2:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80007b4:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 80007b6:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 80007b8:	f7ff ff32 	bl	8000620 <chSchGoSleepS>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
 80007bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 80007be:	6811      	ldr	r1, [r2, #0]
 80007c0:	6853      	ldr	r3, [r2, #4]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 80007c2:	1c10      	adds	r0, r2, #0
 80007c4:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80007c6:	6811      	ldr	r1, [r2, #0]
 80007c8:	604b      	str	r3, [r1, #4]
 80007ca:	f7ff ff61 	bl	8000690 <chSchReadyI>
 80007ce:	e7e3      	b.n	8000798 <chMtxLockS+0x28>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 80007d0:	6853      	ldr	r3, [r2, #4]
 80007d2:	6810      	ldr	r0, [r2, #0]
 80007d4:	6018      	str	r0, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80007d6:	6810      	ldr	r0, [r2, #0]
 80007d8:	6043      	str	r3, [r0, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 80007da:	6a50      	ldr	r0, [r2, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80007dc:	1c03      	adds	r3, r0, #0
 80007de:	e002      	b.n	80007e6 <chMtxLockS+0x76>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80007e0:	689e      	ldr	r6, [r3, #8]
 80007e2:	428e      	cmp	r6, r1
 80007e4:	d302      	bcc.n	80007ec <chMtxLockS+0x7c>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 80007e6:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80007e8:	4298      	cmp	r0, r3
 80007ea:	d1f9      	bne.n	80007e0 <chMtxLockS+0x70>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80007ec:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 80007ee:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 80007f0:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 80007f2:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 80007f4:	605a      	str	r2, [r3, #4]
 80007f6:	e7cf      	b.n	8000798 <chMtxLockS+0x28>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 80007f8:	6853      	ldr	r3, [r2, #4]
 80007fa:	6810      	ldr	r0, [r2, #0]
 80007fc:	6018      	str	r0, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80007fe:	6810      	ldr	r0, [r2, #0]
 8000800:	6043      	str	r3, [r0, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8000802:	6a50      	ldr	r0, [r2, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000804:	1c03      	adds	r3, r0, #0
 8000806:	e002      	b.n	800080e <chMtxLockS+0x9e>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000808:	689f      	ldr	r7, [r3, #8]
 800080a:	428f      	cmp	r7, r1
 800080c:	d302      	bcc.n	8000814 <chMtxLockS+0xa4>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800080e:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8000810:	4298      	cmp	r0, r3
 8000812:	d1f9      	bne.n	8000808 <chMtxLockS+0x98>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8000814:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8000816:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8000818:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 800081a:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 800081c:	605a      	str	r2, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 800081e:	6882      	ldr	r2, [r0, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8000820:	68a1      	ldr	r1, [r4, #8]
 8000822:	6893      	ldr	r3, [r2, #8]
 8000824:	428b      	cmp	r3, r1
 8000826:	d3af      	bcc.n	8000788 <chMtxLockS+0x18>
 8000828:	e7b6      	b.n	8000798 <chMtxLockS+0x28>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 800082a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 800082c:	6084      	str	r4, [r0, #8]
    mp->next = ctp->mtxlist;
 800082e:	60c3      	str	r3, [r0, #12]
    ctp->mtxlist = mp;
 8000830:	63a0      	str	r0, [r4, #56]	; 0x38
 8000832:	e7c3      	b.n	80007bc <chMtxLockS+0x4c>
 8000834:	20000e84 	.word	0x20000e84
 8000838:	46c0      	nop			; (mov r8, r8)
 800083a:	46c0      	nop			; (mov r8, r8)
 800083c:	46c0      	nop			; (mov r8, r8)
 800083e:	46c0      	nop			; (mov r8, r8)

08000840 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8000840:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000842:	b672      	cpsid	i

  chSysLock();
  chMtxLockS(mp);
 8000844:	f7ff ff94 	bl	8000770 <chMtxLockS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000848:	b662      	cpsie	i
  chSysUnlock();
}
 800084a:	bd08      	pop	{r3, pc}
 800084c:	46c0      	nop			; (mov r8, r8)
 800084e:	46c0      	nop			; (mov r8, r8)

08000850 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8000850:	b570      	push	{r4, r5, r6, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000852:	b672      	cpsid	i

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  tp->refs--;
 8000854:	2222      	movs	r2, #34	; 0x22
 8000856:	5c83      	ldrb	r3, [r0, r2]
 8000858:	3b01      	subs	r3, #1
 800085a:	5483      	strb	r3, [r0, r2]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800085c:	6a02      	ldr	r2, [r0, #32]
 800085e:	4b2d      	ldr	r3, [pc, #180]	; (8000914 <chThdRelease+0xc4>)
 8000860:	4013      	ands	r3, r2
 8000862:	2b0f      	cmp	r3, #15
 8000864:	d001      	beq.n	800086a <chThdRelease+0x1a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000866:	b662      	cpsie	i
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
 8000868:	bd70      	pop	{r4, r5, r6, pc}

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
 800086a:	6902      	ldr	r2, [r0, #16]
 800086c:	6943      	ldr	r3, [r0, #20]
 800086e:	611a      	str	r2, [r3, #16]
 8000870:	6902      	ldr	r2, [r0, #16]
 8000872:	6153      	str	r3, [r2, #20]
 8000874:	b662      	cpsie	i
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8000876:	2321      	movs	r3, #33	; 0x21
 8000878:	2203      	movs	r2, #3
 800087a:	5cc3      	ldrb	r3, [r0, r3]
 800087c:	4013      	ands	r3, r2
 800087e:	2b01      	cmp	r3, #1
 8000880:	d009      	beq.n	8000896 <chThdRelease+0x46>
 8000882:	2b02      	cmp	r3, #2
 8000884:	d1f0      	bne.n	8000868 <chThdRelease+0x18>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8000886:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8000888:	69c2      	ldr	r2, [r0, #28]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800088a:	b672      	cpsid	i
  chDbgCheckClassI();
  chDbgCheck((mp != NULL) &&
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 800088c:	6819      	ldr	r1, [r3, #0]
 800088e:	6011      	str	r1, [r2, #0]
  mp->next = php;
 8000890:	601a      	str	r2, [r3, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000892:	b662      	cpsie	i
 8000894:	e7e8      	b.n	8000868 <chThdRelease+0x18>
 8000896:	69c4      	ldr	r4, [r0, #28]
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8000898:	3c08      	subs	r4, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800089a:	6863      	ldr	r3, [r4, #4]
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 800089c:	6826      	ldr	r6, [r4, #0]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 800089e:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80008a0:	08db      	lsrs	r3, r3, #3

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 80008a2:	1d35      	adds	r5, r6, #4
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80008a4:	360c      	adds	r6, #12
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80008a6:	6063      	str	r3, [r4, #4]
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80008a8:	1c30      	adds	r0, r6, #0
 80008aa:	f7ff ffc9 	bl	8000840 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 80008ae:	1c2b      	adds	r3, r5, #0
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 80008b0:	429d      	cmp	r5, r3
 80008b2:	d004      	beq.n	80008be <chThdRelease+0x6e>
 80008b4:	429c      	cmp	r4, r3
 80008b6:	d802      	bhi.n	80008be <chThdRelease+0x6e>
 80008b8:	681b      	ldr	r3, [r3, #0]
 80008ba:	429d      	cmp	r5, r3
 80008bc:	d1fa      	bne.n	80008b4 <chThdRelease+0x64>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80008be:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 80008c0:	2a00      	cmp	r2, #0
 80008c2:	d003      	beq.n	80008cc <chThdRelease+0x7c>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80008c4:	4294      	cmp	r4, r2
 80008c6:	d301      	bcc.n	80008cc <chThdRelease+0x7c>
 80008c8:	1c13      	adds	r3, r2, #0
 80008ca:	e7f1      	b.n	80008b0 <chThdRelease+0x60>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80008cc:	6861      	ldr	r1, [r4, #4]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 80008ce:	6022      	str	r2, [r4, #0]
      H_NEXT(qp) = hp;
 80008d0:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80008d2:	1c4a      	adds	r2, r1, #1
 80008d4:	00d2      	lsls	r2, r2, #3
 80008d6:	6820      	ldr	r0, [r4, #0]
 80008d8:	18a2      	adds	r2, r4, r2
 80008da:	4282      	cmp	r2, r0
 80008dc:	d009      	beq.n	80008f2 <chThdRelease+0xa2>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 80008de:	6859      	ldr	r1, [r3, #4]
 80008e0:	1c4a      	adds	r2, r1, #1
 80008e2:	00d2      	lsls	r2, r2, #3
 80008e4:	189a      	adds	r2, r3, r2
 80008e6:	4294      	cmp	r4, r2
 80008e8:	d00b      	beq.n	8000902 <chThdRelease+0xb2>
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80008ea:	1c30      	adds	r0, r6, #0
 80008ec:	f7ff ff10 	bl	8000710 <chMtxUnlock>
 80008f0:	e7ba      	b.n	8000868 <chThdRelease+0x18>
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80008f2:	6850      	ldr	r0, [r2, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80008f4:	6812      	ldr	r2, [r2, #0]
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80008f6:	4684      	mov	ip, r0
 80008f8:	4461      	add	r1, ip
 80008fa:	3101      	adds	r1, #1
 80008fc:	6061      	str	r1, [r4, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80008fe:	6022      	str	r2, [r4, #0]
 8000900:	e7ed      	b.n	80008de <chThdRelease+0x8e>
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8000902:	6862      	ldr	r2, [r4, #4]
 8000904:	4694      	mov	ip, r2
        H_NEXT(qp) = H_NEXT(hp);
 8000906:	6822      	ldr	r2, [r4, #0]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8000908:	4461      	add	r1, ip
 800090a:	3101      	adds	r1, #1
 800090c:	6059      	str	r1, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 800090e:	601a      	str	r2, [r3, #0]
 8000910:	e7eb      	b.n	80008ea <chThdRelease+0x9a>
 8000912:	46c0      	nop			; (mov r8, r8)
 8000914:	00ff00ff 	.word	0x00ff00ff
 8000918:	46c0      	nop			; (mov r8, r8)
 800091a:	46c0      	nop			; (mov r8, r8)
 800091c:	46c0      	nop			; (mov r8, r8)
 800091e:	46c0      	nop			; (mov r8, r8)

08000920 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8000920:	b538      	push	{r3, r4, r5, lr}
 8000922:	1c04      	adds	r4, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000924:	b672      	cpsid	i
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
#endif

  if (tp->state != CH_STATE_FINAL) {
 8000926:	2320      	movs	r3, #32
 8000928:	5cc3      	ldrb	r3, [r0, r3]
 800092a:	2b0f      	cmp	r3, #15
 800092c:	d007      	beq.n	800093e <chThdWait+0x1e>
    list_insert(currp, &tp->waiting);
 800092e:	4b07      	ldr	r3, [pc, #28]	; (800094c <chThdWait+0x2c>)
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->queue.next = tlp->next;
 8000930:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8000932:	699b      	ldr	r3, [r3, #24]
 8000934:	601a      	str	r2, [r3, #0]
  tlp->next = tp;
 8000936:	6283      	str	r3, [r0, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTEXIT);
 8000938:	2009      	movs	r0, #9
 800093a:	f7ff fe71 	bl	8000620 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
 800093e:	6a65      	ldr	r5, [r4, #36]	; 0x24
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000940:	b662      	cpsie	i
  chSysUnlock();

#if CH_CFG_USE_REGISTRY == TRUE
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
 8000942:	1c20      	adds	r0, r4, #0
 8000944:	f7ff ff84 	bl	8000850 <chThdRelease>
#endif

  return msg;
}
 8000948:	1c28      	adds	r0, r5, #0
 800094a:	bd38      	pop	{r3, r4, r5, pc}
 800094c:	20000e84 	.word	0x20000e84

08000950 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8000950:	b508      	push	{r3, lr}
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 8000952:	6883      	ldr	r3, [r0, #8]
 8000954:	3301      	adds	r3, #1
 8000956:	6083      	str	r3, [r0, #8]
 8000958:	2b00      	cmp	r3, #0
 800095a:	dd00      	ble.n	800095e <chSemSignalI+0xe>
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 800095c:	bd08      	pop	{r3, pc}
 800095e:	1c03      	adds	r3, r0, #0
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8000960:	6800      	ldr	r0, [r0, #0]

  tqp->next             = tp->queue.next;
 8000962:	6802      	ldr	r2, [r0, #0]
 8000964:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000966:	6053      	str	r3, [r2, #4]

  if (++sp->cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 8000968:	2300      	movs	r3, #0
 800096a:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 800096c:	f7ff fe90 	bl	8000690 <chSchReadyI>
 8000970:	e7f4      	b.n	800095c <chSemSignalI+0xc>
 8000972:	46c0      	nop			; (mov r8, r8)
 8000974:	46c0      	nop			; (mov r8, r8)
 8000976:	46c0      	nop			; (mov r8, r8)
 8000978:	46c0      	nop			; (mov r8, r8)
 800097a:	46c0      	nop			; (mov r8, r8)
 800097c:	46c0      	nop			; (mov r8, r8)
 800097e:	46c0      	nop			; (mov r8, r8)

08000980 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8000980:	b570      	push	{r4, r5, r6, lr}
 8000982:	1c05      	adds	r5, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000984:	b672      	cpsid	i
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 8000986:	2602      	movs	r6, #2
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
 8000988:	6884      	ldr	r4, [r0, #8]
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 800098a:	4276      	negs	r6, r6
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 800098c:	3401      	adds	r4, #1
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
 800098e:	6081      	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
 8000990:	2c00      	cmp	r4, #0
 8000992:	dc09      	bgt.n	80009a8 <chSemReset+0x28>

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->prev;
 8000994:	6868      	ldr	r0, [r5, #4]
 8000996:	3401      	adds	r4, #1

  tqp->prev             = tp->queue.prev;
 8000998:	6843      	ldr	r3, [r0, #4]
 800099a:	606b      	str	r3, [r5, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
 800099c:	601d      	str	r5, [r3, #0]
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 800099e:	f7ff fe77 	bl	8000690 <chSchReadyI>
 80009a2:	6246      	str	r6, [r0, #36]	; 0x24
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 80009a4:	2c01      	cmp	r4, #1
 80009a6:	d1f5      	bne.n	8000994 <chSemReset+0x14>
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
  chSchRescheduleS();
 80009a8:	f7ff fdb2 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80009ac:	b662      	cpsie	i
  chSysUnlock();
}
 80009ae:	bd70      	pop	{r4, r5, r6, pc}

080009b0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80009b0:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80009b2:	b672      	cpsid	i
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 80009b4:	4b0f      	ldr	r3, [pc, #60]	; (80009f4 <chThdExit+0x44>)
 80009b6:	699c      	ldr	r4, [r3, #24]
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80009b8:	1c25      	adds	r5, r4, #0
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 80009ba:	6260      	str	r0, [r4, #36]	; 0x24
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80009bc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80009be:	3528      	adds	r5, #40	; 0x28
 80009c0:	42a8      	cmp	r0, r5
 80009c2:	d006      	beq.n	80009d2 <chThdExit+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 80009c4:	6803      	ldr	r3, [r0, #0]
 80009c6:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 80009c8:	f7ff fe62 	bl	8000690 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80009cc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80009ce:	42a8      	cmp	r0, r5
 80009d0:	d1f8      	bne.n	80009c4 <chThdExit+0x14>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80009d2:	2322      	movs	r3, #34	; 0x22
 80009d4:	5ce3      	ldrb	r3, [r4, r3]
 80009d6:	2b00      	cmp	r3, #0
 80009d8:	d108      	bne.n	80009ec <chThdExit+0x3c>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 80009da:	2321      	movs	r3, #33	; 0x21
 80009dc:	5ce3      	ldrb	r3, [r4, r3]

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80009de:	079b      	lsls	r3, r3, #30
 80009e0:	d104      	bne.n	80009ec <chThdExit+0x3c>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 80009e2:	6922      	ldr	r2, [r4, #16]
 80009e4:	6963      	ldr	r3, [r4, #20]
 80009e6:	611a      	str	r2, [r3, #16]
 80009e8:	6922      	ldr	r2, [r4, #16]
 80009ea:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80009ec:	200f      	movs	r0, #15
 80009ee:	f7ff fe17 	bl	8000620 <chSchGoSleepS>
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 80009f2:	bd38      	pop	{r3, r4, r5, pc}
 80009f4:	20000e84 	.word	0x20000e84
 80009f8:	46c0      	nop			; (mov r8, r8)
 80009fa:	46c0      	nop			; (mov r8, r8)
 80009fc:	46c0      	nop			; (mov r8, r8)
 80009fe:	46c0      	nop			; (mov r8, r8)

08000a00 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000a00:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000a02:	4645      	mov	r5, r8
 8000a04:	464e      	mov	r6, r9
 8000a06:	4657      	mov	r7, sl
 8000a08:	b4e0      	push	{r5, r6, r7}
  USART_TypeDef *u = sdp->usart;
 8000a0a:	6d46      	ldr	r6, [r0, #84]	; 0x54
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 8000a0c:	1c04      	adds	r4, r0, #0
  USART_TypeDef *u = sdp->usart;
  uint32_t cr1 = u->CR1;
 8000a0e:	6833      	ldr	r3, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8000a10:	69f5      	ldr	r5, [r6, #28]
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint32_t cr1 = u->CR1;
 8000a12:	4698      	mov	r8, r3
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
  u->ICR = isr;
 8000a14:	6235      	str	r5, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000a16:	072b      	lsls	r3, r5, #28
 8000a18:	d000      	beq.n	8000a1c <serve_interrupt+0x1c>
 8000a1a:	e096      	b.n	8000b4a <serve_interrupt+0x14a>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8000a1c:	05eb      	lsls	r3, r5, #23
 8000a1e:	d500      	bpl.n	8000a22 <serve_interrupt+0x22>
 8000a20:	e08b      	b.n	8000b3a <serve_interrupt+0x13a>
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
 8000a22:	06ab      	lsls	r3, r5, #26
 8000a24:	d53e      	bpl.n	8000aa4 <serve_interrupt+0xa4>

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 8000a26:	1d23      	adds	r3, r4, #4
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 8000a28:	275c      	movs	r7, #92	; 0x5c
 8000a2a:	4699      	mov	r9, r3
 8000a2c:	e01f      	b.n	8000a6e <serve_interrupt+0x6e>
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 8000a2e:	6a23      	ldr	r3, [r4, #32]
 8000a30:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000a32:	4293      	cmp	r3, r2
 8000a34:	d02a      	beq.n	8000a8c <serve_interrupt+0x8c>
    iqp->q_counter++;
 8000a36:	6962      	ldr	r2, [r4, #20]
 8000a38:	3201      	adds	r2, #1
 8000a3a:	6162      	str	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 8000a3c:	1c5a      	adds	r2, r3, #1
 8000a3e:	6222      	str	r2, [r4, #32]
 8000a40:	701d      	strb	r5, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8000a42:	6a23      	ldr	r3, [r4, #32]
 8000a44:	69e2      	ldr	r2, [r4, #28]
 8000a46:	4293      	cmp	r3, r2
 8000a48:	d301      	bcc.n	8000a4e <serve_interrupt+0x4e>
      iqp->q_wrptr = iqp->q_buffer;
 8000a4a:	69a3      	ldr	r3, [r4, #24]
 8000a4c:	6223      	str	r3, [r4, #32]
    }

    osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
 8000a4e:	1c23      	adds	r3, r4, #0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000a50:	68e0      	ldr	r0, [r4, #12]
 8000a52:	330c      	adds	r3, #12
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000a54:	4283      	cmp	r3, r0
 8000a56:	d006      	beq.n	8000a66 <serve_interrupt+0x66>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000a58:	6802      	ldr	r2, [r0, #0]
 8000a5a:	60e2      	str	r2, [r4, #12]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000a5c:	6053      	str	r3, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000a5e:	2300      	movs	r3, #0
 8000a60:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000a62:	f7ff fe15 	bl	8000690 <chSchReadyI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a66:	b662      	cpsie	i
    osalSysUnlockFromISR();

    isr = u->ISR;
 8000a68:	69f5      	ldr	r5, [r6, #28]
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
 8000a6a:	06ab      	lsls	r3, r5, #26
 8000a6c:	d51a      	bpl.n	8000aa4 <serve_interrupt+0xa4>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000a6e:	b672      	cpsid	i
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 8000a70:	8cb3      	ldrh	r3, [r6, #36]	; 0x24
 8000a72:	5de5      	ldrb	r5, [r4, r7]
 8000a74:	401d      	ands	r5, r3
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000a76:	6963      	ldr	r3, [r4, #20]
 8000a78:	2b00      	cmp	r3, #0
 8000a7a:	d1d8      	bne.n	8000a2e <serve_interrupt+0x2e>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000a7c:	4648      	mov	r0, r9
 8000a7e:	2104      	movs	r1, #4
 8000a80:	f7ff fc8e 	bl	80003a0 <chEvtBroadcastFlagsI>
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  /* Queue space check.*/
  if (!iqIsFullI(iqp)) {
 8000a84:	6a23      	ldr	r3, [r4, #32]
 8000a86:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8000a88:	4293      	cmp	r3, r2
 8000a8a:	d1d4      	bne.n	8000a36 <serve_interrupt+0x36>
 8000a8c:	6962      	ldr	r2, [r4, #20]
 8000a8e:	2a00      	cmp	r2, #0
 8000a90:	d0d1      	beq.n	8000a36 <serve_interrupt+0x36>
 8000a92:	2180      	movs	r1, #128	; 0x80
 8000a94:	4648      	mov	r0, r9
 8000a96:	00c9      	lsls	r1, r1, #3
 8000a98:	f7ff fc82 	bl	80003a0 <chEvtBroadcastFlagsI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000a9c:	b662      	cpsie	i
    osalSysUnlockFromISR();

    isr = u->ISR;
 8000a9e:	69f5      	ldr	r5, [r6, #28]
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
 8000aa0:	06ab      	lsls	r3, r5, #26
 8000aa2:	d4e4      	bmi.n	8000a6e <serve_interrupt+0x6e>
     situations:
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
 8000aa4:	2380      	movs	r3, #128	; 0x80
 8000aa6:	4642      	mov	r2, r8
 8000aa8:	4213      	tst	r3, r2
 8000aaa:	d035      	beq.n	8000b18 <serve_interrupt+0x118>
    while (isr & USART_ISR_TXE) {
 8000aac:	422b      	tst	r3, r5
 8000aae:	d033      	beq.n	8000b18 <serve_interrupt+0x118>

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8000ab0:	2300      	movs	r3, #0
    b = *oqp->q_rdptr++;
    if (oqp->q_rdptr >= oqp->q_top) {
      oqp->q_rdptr = oqp->q_buffer;
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
 8000ab2:	1c27      	adds	r7, r4, #0
 8000ab4:	469a      	mov	sl, r3
 8000ab6:	3380      	adds	r3, #128	; 0x80
 8000ab8:	3730      	adds	r7, #48	; 0x30
 8000aba:	4699      	mov	r9, r3
 8000abc:	e01b      	b.n	8000af6 <serve_interrupt+0xf6>

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
    uint8_t b;

    oqp->q_counter++;
 8000abe:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000ac0:	3201      	adds	r2, #1
 8000ac2:	63a2      	str	r2, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
 8000ac4:	1c5a      	adds	r2, r3, #1
 8000ac6:	64a2      	str	r2, [r4, #72]	; 0x48
 8000ac8:	781d      	ldrb	r5, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 8000aca:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8000acc:	429a      	cmp	r2, r3
 8000ace:	d301      	bcc.n	8000ad4 <serve_interrupt+0xd4>
      oqp->q_rdptr = oqp->q_buffer;
 8000ad0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000ad2:	64a3      	str	r3, [r4, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8000ad4:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8000ad6:	42b8      	cmp	r0, r7
 8000ad8:	d006      	beq.n	8000ae8 <serve_interrupt+0xe8>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000ada:	6803      	ldr	r3, [r0, #0]
 8000adc:	6323      	str	r3, [r4, #48]	; 0x30
  tqp->next->queue.prev = (thread_t *)tqp;
 8000ade:	605f      	str	r7, [r3, #4]
 8000ae0:	4653      	mov	r3, sl
 8000ae2:	6243      	str	r3, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 8000ae4:	f7ff fdd4 	bl	8000690 <chSchReadyI>
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
        osalSysUnlockFromISR();
        break;
      }
      u->TDR = b;
 8000ae8:	b2ad      	uxth	r5, r5
 8000aea:	8535      	strh	r5, [r6, #40]	; 0x28
 8000aec:	b662      	cpsie	i
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
    while (isr & USART_ISR_TXE) {
 8000aee:	464b      	mov	r3, r9
        break;
      }
      u->TDR = b;
      osalSysUnlockFromISR();

      isr = u->ISR;
 8000af0:	69f5      	ldr	r5, [r6, #28]
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
    while (isr & USART_ISR_TXE) {
 8000af2:	422b      	tst	r3, r5
 8000af4:	d010      	beq.n	8000b18 <serve_interrupt+0x118>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000af6:	b672      	cpsid	i
msg_t oqGetI(output_queue_t *oqp) {

  osalDbgCheckClassI();

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 8000af8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8000afa:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8000afc:	429a      	cmp	r2, r3
 8000afe:	d1de      	bne.n	8000abe <serve_interrupt+0xbe>
 8000b00:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8000b02:	2a00      	cmp	r2, #0
 8000b04:	d0db      	beq.n	8000abe <serve_interrupt+0xbe>
      msg_t b;

      osalSysLockFromISR();
      b = oqGetI(&sdp->oqueue);
      if (b < MSG_OK) {
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 8000b06:	1d20      	adds	r0, r4, #4
 8000b08:	2108      	movs	r1, #8
 8000b0a:	f7ff fc49 	bl	80003a0 <chEvtBroadcastFlagsI>
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8000b0e:	2380      	movs	r3, #128	; 0x80
 8000b10:	4642      	mov	r2, r8
 8000b12:	439a      	bics	r2, r3
 8000b14:	6032      	str	r2, [r6, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000b16:	b662      	cpsie	i
      isr = u->ISR;
    }
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
 8000b18:	2740      	movs	r7, #64	; 0x40
 8000b1a:	4643      	mov	r3, r8
 8000b1c:	421f      	tst	r7, r3
 8000b1e:	d007      	beq.n	8000b30 <serve_interrupt+0x130>
 8000b20:	422f      	tst	r7, r5
 8000b22:	d005      	beq.n	8000b30 <serve_interrupt+0x130>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000b24:	b672      	cpsid	i
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue)) {
 8000b26:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8000b28:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8000b2a:	4293      	cmp	r3, r2
 8000b2c:	d023      	beq.n	8000b76 <serve_interrupt+0x176>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000b2e:	b662      	cpsie	i
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
      u->CR1 = cr1 & ~USART_CR1_TCIE;
    }
    osalSysUnlockFromISR();
  }
}
 8000b30:	bc1c      	pop	{r2, r3, r4}
 8000b32:	4690      	mov	r8, r2
 8000b34:	4699      	mov	r9, r3
 8000b36:	46a2      	mov	sl, r4
 8000b38:	bdf0      	pop	{r4, r5, r6, r7, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000b3a:	b672      	cpsid	i
 8000b3c:	2180      	movs	r1, #128	; 0x80
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 8000b3e:	1d20      	adds	r0, r4, #4
 8000b40:	0089      	lsls	r1, r1, #2
 8000b42:	f7ff fc2d 	bl	80003a0 <chEvtBroadcastFlagsI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000b46:	b662      	cpsie	i
 8000b48:	e76b      	b.n	8000a22 <serve_interrupt+0x22>
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
 8000b4a:	0729      	lsls	r1, r5, #28
    sts |= SD_OVERRUN_ERROR;
 8000b4c:	0fc9      	lsrs	r1, r1, #31
 8000b4e:	01c9      	lsls	r1, r1, #7
  if (isr & USART_ISR_PE)
 8000b50:	07eb      	lsls	r3, r5, #31
 8000b52:	d501      	bpl.n	8000b58 <serve_interrupt+0x158>
    sts |= SD_PARITY_ERROR;
 8000b54:	2320      	movs	r3, #32
 8000b56:	4319      	orrs	r1, r3
  if (isr & USART_ISR_FE)
 8000b58:	07ab      	lsls	r3, r5, #30
 8000b5a:	d501      	bpl.n	8000b60 <serve_interrupt+0x160>
    sts |= SD_FRAMING_ERROR;
 8000b5c:	2340      	movs	r3, #64	; 0x40
 8000b5e:	4319      	orrs	r1, r3
  if (isr & USART_ISR_NE)
 8000b60:	076b      	lsls	r3, r5, #29
 8000b62:	d502      	bpl.n	8000b6a <serve_interrupt+0x16a>
    sts |= SD_NOISE_ERROR;
 8000b64:	2380      	movs	r3, #128	; 0x80
 8000b66:	005b      	lsls	r3, r3, #1
 8000b68:	4319      	orrs	r1, r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000b6a:	b672      	cpsid	i
  osalSysLockFromISR();
  chnAddFlagsI(sdp, sts);
 8000b6c:	1d20      	adds	r0, r4, #4
 8000b6e:	f7ff fc17 	bl	80003a0 <chEvtBroadcastFlagsI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000b72:	b662      	cpsie	i
 8000b74:	e752      	b.n	8000a1c <serve_interrupt+0x1c>
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue)) {
 8000b76:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000b78:	2b00      	cmp	r3, #0
 8000b7a:	d0d8      	beq.n	8000b2e <serve_interrupt+0x12e>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 8000b7c:	1d20      	adds	r0, r4, #4
 8000b7e:	2110      	movs	r1, #16
 8000b80:	f7ff fc0e 	bl	80003a0 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000b84:	4643      	mov	r3, r8
 8000b86:	43bb      	bics	r3, r7
 8000b88:	6033      	str	r3, [r6, #0]
 8000b8a:	e7d0      	b.n	8000b2e <serve_interrupt+0x12e>
 8000b8c:	46c0      	nop			; (mov r8, r8)
 8000b8e:	46c0      	nop			; (mov r8, r8)

08000b90 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8000b90:	4b1b      	ldr	r3, [pc, #108]	; (8000c00 <chVTDoResetI+0x70>)
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000b92:	b510      	push	{r4, lr}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8000b94:	69da      	ldr	r2, [r3, #28]
 8000b96:	4282      	cmp	r2, r0
 8000b98:	d00f      	beq.n	8000bba <chVTDoResetI+0x2a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000b9a:	6841      	ldr	r1, [r0, #4]
 8000b9c:	6802      	ldr	r2, [r0, #0]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000b9e:	331c      	adds	r3, #28

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000ba0:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 8000ba2:	6802      	ldr	r2, [r0, #0]
 8000ba4:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 8000ba6:	2100      	movs	r1, #0
 8000ba8:	60c1      	str	r1, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000baa:	429a      	cmp	r2, r3
 8000bac:	d004      	beq.n	8000bb8 <chVTDoResetI+0x28>
      vtp->next->delta += vtp->delta;
 8000bae:	6891      	ldr	r1, [r2, #8]
 8000bb0:	6883      	ldr	r3, [r0, #8]
 8000bb2:	468c      	mov	ip, r1
 8000bb4:	4463      	add	r3, ip
 8000bb6:	6093      	str	r3, [r2, #8]
    }
#endif
  }
  port_timer_set_alarm(chTimeAddX(ch.vtlist.lasttime, delta));
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000bb8:	bd10      	pop	{r4, pc}
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000bba:	1c18      	adds	r0, r3, #0
  vtp->func = NULL;
 8000bbc:	2400      	movs	r4, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8000bbe:	6811      	ldr	r1, [r2, #0]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000bc0:	301c      	adds	r0, #28

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8000bc2:	61d9      	str	r1, [r3, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000bc4:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
 8000bc6:	60d4      	str	r4, [r2, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000bc8:	4281      	cmp	r1, r0
 8000bca:	d015      	beq.n	8000bf8 <chVTDoResetI+0x68>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8000bcc:	6888      	ldr	r0, [r1, #8]
 8000bce:	6892      	ldr	r2, [r2, #8]
 8000bd0:	4684      	mov	ip, r0
 8000bd2:	4462      	add	r2, ip
 8000bd4:	608a      	str	r2, [r1, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8000bd6:	6a99      	ldr	r1, [r3, #40]	; 0x28
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000bd8:	2380      	movs	r3, #128	; 0x80
 8000bda:	05db      	lsls	r3, r3, #23
 8000bdc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8000bde:	1a5b      	subs	r3, r3, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8000be0:	429a      	cmp	r2, r3
 8000be2:	d9e9      	bls.n	8000bb8 <chVTDoResetI+0x28>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8000be4:	1ad0      	subs	r0, r2, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8000be6:	2801      	cmp	r0, #1
 8000be8:	d904      	bls.n	8000bf4 <chVTDoResetI+0x64>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000bea:	2380      	movs	r3, #128	; 0x80

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)((systime_t)-1));
#endif

  return systime + (systime_t)interval;
 8000bec:	1852      	adds	r2, r2, r1
 8000bee:	05db      	lsls	r3, r3, #23
 8000bf0:	635a      	str	r2, [r3, #52]	; 0x34
 8000bf2:	e7e1      	b.n	8000bb8 <chVTDoResetI+0x28>
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8000bf4:	1c9a      	adds	r2, r3, #2
 8000bf6:	e7f8      	b.n	8000bea <chVTDoResetI+0x5a>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000bf8:	2380      	movs	r3, #128	; 0x80
 8000bfa:	05db      	lsls	r3, r3, #23
 8000bfc:	60dc      	str	r4, [r3, #12]
 8000bfe:	e7db      	b.n	8000bb8 <chVTDoResetI+0x28>
 8000c00:	20000e84 	.word	0x20000e84
 8000c04:	46c0      	nop			; (mov r8, r8)
 8000c06:	46c0      	nop			; (mov r8, r8)
 8000c08:	46c0      	nop			; (mov r8, r8)
 8000c0a:	46c0      	nop			; (mov r8, r8)
 8000c0c:	46c0      	nop			; (mov r8, r8)
 8000c0e:	46c0      	nop			; (mov r8, r8)

08000c10 <chVTDoSetI>:
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8000c10:	6103      	str	r3, [r0, #16]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000c12:	2380      	movs	r3, #128	; 0x80
 8000c14:	05db      	lsls	r3, r3, #23
  vtp->func = vtfunc;
 8000c16:	60c2      	str	r2, [r0, #12]
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8000c18:	b570      	push	{r4, r5, r6, lr}
 8000c1a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8000c1c:	2901      	cmp	r1, #1
 8000c1e:	d925      	bls.n	8000c6c <chVTDoSetI+0x5c>
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000c20:	4c1d      	ldr	r4, [pc, #116]	; (8000c98 <chVTDoSetI+0x88>)
 8000c22:	1c25      	adds	r5, r4, #0
 8000c24:	69e3      	ldr	r3, [r4, #28]
 8000c26:	351c      	adds	r5, #28
 8000c28:	42ab      	cmp	r3, r5
 8000c2a:	d026      	beq.n	8000c7a <chVTDoSetI+0x6a>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8000c2c:	6aa5      	ldr	r5, [r4, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8000c2e:	1b52      	subs	r2, r2, r5
 8000c30:	1889      	adds	r1, r1, r2

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8000c32:	428a      	cmp	r2, r1
 8000c34:	d815      	bhi.n	8000c62 <chVTDoSetI+0x52>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 8000c36:	689a      	ldr	r2, [r3, #8]
 8000c38:	4291      	cmp	r1, r2
 8000c3a:	d203      	bcs.n	8000c44 <chVTDoSetI+0x34>
 8000c3c:	e018      	b.n	8000c70 <chVTDoSetI+0x60>
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
    p = p->next;
 8000c3e:	681b      	ldr	r3, [r3, #0]
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
 8000c40:	1a89      	subs	r1, r1, r2
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8000c42:	689a      	ldr	r2, [r3, #8]
 8000c44:	428a      	cmp	r2, r1
 8000c46:	d3fa      	bcc.n	8000c3e <chVTDoSetI+0x2e>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8000c48:	685a      	ldr	r2, [r3, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8000c4a:	6003      	str	r3, [r0, #0]
  vtp->prev = vtp->next->prev;
 8000c4c:	6042      	str	r2, [r0, #4]
  vtp->prev->next = vtp;
 8000c4e:	6010      	str	r0, [r2, #0]
  p->prev = vtp;
 8000c50:	6058      	str	r0, [r3, #4]
  vtp->delta = delta;
 8000c52:	6081      	str	r1, [r0, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8000c54:	689a      	ldr	r2, [r3, #8]
 8000c56:	1a51      	subs	r1, r2, r1
 8000c58:	6099      	str	r1, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 8000c5a:	2301      	movs	r3, #1
 8000c5c:	425b      	negs	r3, r3
 8000c5e:	6263      	str	r3, [r4, #36]	; 0x24
}
 8000c60:	bd70      	pop	{r4, r5, r6, pc}

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8000c62:	689a      	ldr	r2, [r3, #8]
      p = p->next;
 8000c64:	681b      	ldr	r3, [r3, #0]

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8000c66:	1a89      	subs	r1, r1, r2
 8000c68:	689a      	ldr	r2, [r3, #8]
 8000c6a:	e7eb      	b.n	8000c44 <chVTDoSetI+0x34>
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8000c6c:	2102      	movs	r1, #2
 8000c6e:	e7d7      	b.n	8000c20 <chVTDoSetI+0x10>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000c70:	2680      	movs	r6, #128	; 0x80

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)((systime_t)-1));
#endif

  return systime + (systime_t)interval;
 8000c72:	194d      	adds	r5, r1, r5
 8000c74:	05f6      	lsls	r6, r6, #23
 8000c76:	6375      	str	r5, [r6, #52]	; 0x34
 8000c78:	e7e4      	b.n	8000c44 <chVTDoSetI+0x34>
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 8000c7a:	62a2      	str	r2, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
 8000c7c:	61e0      	str	r0, [r4, #28]
      ch.vtlist.prev = vtp;
 8000c7e:	6220      	str	r0, [r4, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8000c80:	6003      	str	r3, [r0, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8000c82:	6043      	str	r3, [r0, #4]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000c84:	2380      	movs	r3, #128	; 0x80
      vtp->delta = delay;
 8000c86:	6081      	str	r1, [r0, #8]
 8000c88:	1889      	adds	r1, r1, r2
  STM32_ST_TIM->SR     = 0;
 8000c8a:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000c8c:	05db      	lsls	r3, r3, #23
 8000c8e:	6359      	str	r1, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000c90:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000c92:	3202      	adds	r2, #2
 8000c94:	60da      	str	r2, [r3, #12]
 8000c96:	e7e3      	b.n	8000c60 <chVTDoSetI+0x50>
 8000c98:	20000e84 	.word	0x20000e84
 8000c9c:	46c0      	nop			; (mov r8, r8)
 8000c9e:	46c0      	nop			; (mov r8, r8)

08000ca0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8000ca0:	b530      	push	{r4, r5, lr}
 8000ca2:	1c05      	adds	r5, r0, #0
 8000ca4:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
 8000ca6:	1c4b      	adds	r3, r1, #1
 8000ca8:	d012      	beq.n	8000cd0 <chSchGoSleepTimeoutS+0x30>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
 8000caa:	4c0b      	ldr	r4, [pc, #44]	; (8000cd8 <chSchGoSleepTimeoutS+0x38>)
 8000cac:	a801      	add	r0, sp, #4
 8000cae:	69a3      	ldr	r3, [r4, #24]
 8000cb0:	4a0a      	ldr	r2, [pc, #40]	; (8000cdc <chSchGoSleepTimeoutS+0x3c>)
 8000cb2:	f7ff ffad 	bl	8000c10 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000cb6:	1c28      	adds	r0, r5, #0
 8000cb8:	f7ff fcb2 	bl	8000620 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000cbc:	9b04      	ldr	r3, [sp, #16]
 8000cbe:	2b00      	cmp	r3, #0
 8000cc0:	d002      	beq.n	8000cc8 <chSchGoSleepTimeoutS+0x28>
      chVTDoResetI(&vt);
 8000cc2:	a801      	add	r0, sp, #4
 8000cc4:	f7ff ff64 	bl	8000b90 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8000cc8:	69a3      	ldr	r3, [r4, #24]
 8000cca:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 8000ccc:	b007      	add	sp, #28
 8000cce:	bd30      	pop	{r4, r5, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000cd0:	f7ff fca6 	bl	8000620 <chSchGoSleepS>
 8000cd4:	4c00      	ldr	r4, [pc, #0]	; (8000cd8 <chSchGoSleepTimeoutS+0x38>)
 8000cd6:	e7f7      	b.n	8000cc8 <chSchGoSleepTimeoutS+0x28>
 8000cd8:	20000e84 	.word	0x20000e84
 8000cdc:	08000301 	.word	0x08000301

08000ce0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8000ce0:	b508      	push	{r3, lr}

  if (TIME_IMMEDIATE == timeout) {
 8000ce2:	2900      	cmp	r1, #0
 8000ce4:	d00a      	beq.n	8000cfc <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000ce6:	4b07      	ldr	r3, [pc, #28]	; (8000d04 <chThdEnqueueTimeoutS+0x24>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8000ce8:	6842      	ldr	r2, [r0, #4]
 8000cea:	699b      	ldr	r3, [r3, #24]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 8000cec:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
 8000cee:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 8000cf0:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 8000cf2:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000cf4:	2004      	movs	r0, #4
 8000cf6:	f7ff ffd3 	bl	8000ca0 <chSchGoSleepTimeoutS>
}
 8000cfa:	bd08      	pop	{r3, pc}
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
 8000cfc:	2001      	movs	r0, #1
 8000cfe:	4240      	negs	r0, r0
 8000d00:	e7fb      	b.n	8000cfa <chThdEnqueueTimeoutS+0x1a>
 8000d02:	46c0      	nop			; (mov r8, r8)
 8000d04:	20000e84 	.word	0x20000e84
 8000d08:	46c0      	nop			; (mov r8, r8)
 8000d0a:	46c0      	nop			; (mov r8, r8)
 8000d0c:	46c0      	nop			; (mov r8, r8)
 8000d0e:	46c0      	nop			; (mov r8, r8)

08000d10 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8000d10:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000d12:	465f      	mov	r7, fp
 8000d14:	4656      	mov	r6, sl
 8000d16:	4644      	mov	r4, r8
 8000d18:	464d      	mov	r5, r9
 8000d1a:	b4f0      	push	{r4, r5, r6, r7}
 8000d1c:	469b      	mov	fp, r3
  qnotify_t nfy = oqp->q_notify;
 8000d1e:	69c3      	ldr	r3, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8000d20:	b083      	sub	sp, #12
 8000d22:	1c04      	adds	r4, r0, #0
 8000d24:	4688      	mov	r8, r1
 8000d26:	9201      	str	r2, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 8000d28:	469a      	mov	sl, r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d2a:	b672      	cpsid	i

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8000d2c:	1e17      	subs	r7, r2, #0
 8000d2e:	d020      	beq.n	8000d72 <oqWriteTimeout+0x62>
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
 8000d30:	68a3      	ldr	r3, [r4, #8]
 8000d32:	1c3d      	adds	r5, r7, #0
 8000d34:	42bb      	cmp	r3, r7
 8000d36:	d200      	bcs.n	8000d3a <oqWriteTimeout+0x2a>
    n = oqGetEmptyI(oqp);
 8000d38:	68a5      	ldr	r5, [r4, #8]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000d3a:	6960      	ldr	r0, [r4, #20]
 8000d3c:	6923      	ldr	r3, [r4, #16]
  /*lint -restore*/
  if (n < s1) {
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000d3e:	4641      	mov	r1, r8
    n = oqGetEmptyI(oqp);
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000d40:	1a1e      	subs	r6, r3, r0
  /*lint -restore*/
  if (n < s1) {
 8000d42:	42ae      	cmp	r6, r5
 8000d44:	d83a      	bhi.n	8000dbc <oqWriteTimeout+0xac>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
    oqp->q_wrptr += n;
  }
  else if (n > s1) {
 8000d46:	d31f      	bcc.n	8000d88 <oqWriteTimeout+0x78>
    s2 = n - s1;
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
    oqp->q_wrptr = oqp->q_buffer + s2;
  }
  else { /* n == s1 */
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000d48:	1c2a      	adds	r2, r5, #0
 8000d4a:	f004 fb41 	bl	80053d0 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8000d4e:	68e3      	ldr	r3, [r4, #12]
 8000d50:	6163      	str	r3, [r4, #20]
  }

  oqp->q_counter -= n;
 8000d52:	68a3      	ldr	r3, [r4, #8]
 8000d54:	1b5b      	subs	r3, r3, r5
 8000d56:	60a3      	str	r3, [r4, #8]

  while (n > 0U) {
    size_t done;

    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
 8000d58:	2d00      	cmp	r5, #0
 8000d5a:	d028      	beq.n	8000dae <oqWriteTimeout+0x9e>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 8000d5c:	4653      	mov	r3, sl
 8000d5e:	2b00      	cmp	r3, #0
 8000d60:	d001      	beq.n	8000d66 <oqWriteTimeout+0x56>
        nfy(oqp);
 8000d62:	1c20      	adds	r0, r4, #0
 8000d64:	47d0      	blx	sl
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d66:	b662      	cpsie	i
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 8000d68:	1b7f      	subs	r7, r7, r5
      bp += done;
 8000d6a:	44a8      	add	r8, r5
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d6c:	b672      	cpsid	i

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8000d6e:	2f00      	cmp	r7, #0
 8000d70:	d1de      	bne.n	8000d30 <oqWriteTimeout+0x20>
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be written in a single atomic operation.*/
  if (n > oqGetEmptyI(oqp)) {
 8000d72:	2700      	movs	r7, #0
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d74:	b662      	cpsie	i
      osalSysLock();
    }
  }

  osalSysUnlock();
  return max - n;
 8000d76:	9b01      	ldr	r3, [sp, #4]
 8000d78:	1bd8      	subs	r0, r3, r7
}
 8000d7a:	b003      	add	sp, #12
 8000d7c:	bc3c      	pop	{r2, r3, r4, r5}
 8000d7e:	4690      	mov	r8, r2
 8000d80:	4699      	mov	r9, r3
 8000d82:	46a2      	mov	sl, r4
 8000d84:	46ab      	mov	fp, r5
 8000d86:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (n < s1) {
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
    oqp->q_wrptr += n;
  }
  else if (n > s1) {
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000d88:	1c32      	adds	r2, r6, #0
 8000d8a:	f004 fb21 	bl	80053d0 <memcpy>
    bp += s1;
 8000d8e:	1c31      	adds	r1, r6, #0
    s2 = n - s1;
 8000d90:	1bab      	subs	r3, r5, r6
 8000d92:	4699      	mov	r9, r3
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8000d94:	1c1a      	adds	r2, r3, #0
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
    oqp->q_wrptr += n;
  }
  else if (n > s1) {
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
    bp += s1;
 8000d96:	4441      	add	r1, r8
    s2 = n - s1;
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8000d98:	68e0      	ldr	r0, [r4, #12]
 8000d9a:	f004 fb19 	bl	80053d0 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8000d9e:	68e3      	ldr	r3, [r4, #12]
 8000da0:	444b      	add	r3, r9
 8000da2:	6163      	str	r3, [r4, #20]
  else { /* n == s1 */
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
    oqp->q_wrptr = oqp->q_buffer;
  }

  oqp->q_counter -= n;
 8000da4:	68a3      	ldr	r3, [r4, #8]
 8000da6:	1b5b      	subs	r3, r3, r5
 8000da8:	60a3      	str	r3, [r4, #8]

  while (n > 0U) {
    size_t done;

    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
 8000daa:	2d00      	cmp	r5, #0
 8000dac:	d1d6      	bne.n	8000d5c <oqWriteTimeout+0x4c>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              sysinterval_t timeout) {

  return chThdEnqueueTimeoutS(tqp, timeout);
 8000dae:	1c20      	adds	r0, r4, #0
 8000db0:	4659      	mov	r1, fp
 8000db2:	f7ff ff95 	bl	8000ce0 <chThdEnqueueTimeoutS>
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8000db6:	2800      	cmp	r0, #0
 8000db8:	d0ba      	beq.n	8000d30 <oqWriteTimeout+0x20>
 8000dba:	e7db      	b.n	8000d74 <oqWriteTimeout+0x64>
  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
  /*lint -restore*/
  if (n < s1) {
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000dbc:	1c2a      	adds	r2, r5, #0
 8000dbe:	f004 fb07 	bl	80053d0 <memcpy>
    oqp->q_wrptr += n;
 8000dc2:	6963      	ldr	r3, [r4, #20]
 8000dc4:	195b      	adds	r3, r3, r5
 8000dc6:	6163      	str	r3, [r4, #20]
 8000dc8:	e7c3      	b.n	8000d52 <oqWriteTimeout+0x42>
 8000dca:	46c0      	nop			; (mov r8, r8)
 8000dcc:	46c0      	nop			; (mov r8, r8)
 8000dce:	46c0      	nop			; (mov r8, r8)

08000dd0 <_writet.lto_priv.70>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t _writet(void *ip, const uint8_t *bp, size_t n,
                      sysinterval_t timeout) {
 8000dd0:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000dd2:	3030      	adds	r0, #48	; 0x30
 8000dd4:	f7ff ff9c 	bl	8000d10 <oqWriteTimeout>
}
 8000dd8:	bd08      	pop	{r3, pc}
 8000dda:	46c0      	nop			; (mov r8, r8)
 8000ddc:	46c0      	nop			; (mov r8, r8)
 8000dde:	46c0      	nop			; (mov r8, r8)

08000de0 <_write.lto_priv.64>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8000de0:	b508      	push	{r3, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000de2:	2301      	movs	r3, #1
 8000de4:	3030      	adds	r0, #48	; 0x30
 8000de6:	425b      	negs	r3, r3
 8000de8:	f7ff ff92 	bl	8000d10 <oqWriteTimeout>
                        n, TIME_INFINITE);
}
 8000dec:	bd08      	pop	{r3, pc}
 8000dee:	46c0      	nop			; (mov r8, r8)

08000df0 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8000df0:	b570      	push	{r4, r5, r6, lr}
 8000df2:	1c04      	adds	r4, r0, #0
 8000df4:	1c0e      	adds	r6, r1, #0
 8000df6:	1c15      	adds	r5, r2, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000df8:	b672      	cpsid	i
 8000dfa:	e005      	b.n	8000e08 <oqPutTimeout+0x18>
 8000dfc:	1c20      	adds	r0, r4, #0
 8000dfe:	1c29      	adds	r1, r5, #0
 8000e00:	f7ff ff6e 	bl	8000ce0 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000e04:	2800      	cmp	r0, #0
 8000e06:	db17      	blt.n	8000e38 <oqPutTimeout+0x48>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8000e08:	68a3      	ldr	r3, [r4, #8]
 8000e0a:	2b00      	cmp	r3, #0
 8000e0c:	d0f6      	beq.n	8000dfc <oqPutTimeout+0xc>
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8000e0e:	68a3      	ldr	r3, [r4, #8]
 8000e10:	3b01      	subs	r3, #1
 8000e12:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000e14:	6963      	ldr	r3, [r4, #20]
 8000e16:	1c5a      	adds	r2, r3, #1
 8000e18:	6162      	str	r2, [r4, #20]
 8000e1a:	701e      	strb	r6, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000e1c:	6963      	ldr	r3, [r4, #20]
 8000e1e:	6922      	ldr	r2, [r4, #16]
 8000e20:	4293      	cmp	r3, r2
 8000e22:	d301      	bcc.n	8000e28 <oqPutTimeout+0x38>
    oqp->q_wrptr = oqp->q_buffer;
 8000e24:	68e3      	ldr	r3, [r4, #12]
 8000e26:	6163      	str	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8000e28:	69e3      	ldr	r3, [r4, #28]
 8000e2a:	2b00      	cmp	r3, #0
 8000e2c:	d001      	beq.n	8000e32 <oqPutTimeout+0x42>
    oqp->q_notify(oqp);
 8000e2e:	1c20      	adds	r0, r4, #0
 8000e30:	4798      	blx	r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000e32:	b662      	cpsie	i
 8000e34:	2000      	movs	r0, #0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8000e36:	bd70      	pop	{r4, r5, r6, pc}
 8000e38:	b662      	cpsie	i
 8000e3a:	e7fc      	b.n	8000e36 <oqPutTimeout+0x46>
 8000e3c:	46c0      	nop			; (mov r8, r8)
 8000e3e:	46c0      	nop			; (mov r8, r8)

08000e40 <_putt.lto_priv.68>:
static msg_t _get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 8000e40:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000e42:	3030      	adds	r0, #48	; 0x30
 8000e44:	f7ff ffd4 	bl	8000df0 <oqPutTimeout>
}
 8000e48:	bd08      	pop	{r3, pc}
 8000e4a:	46c0      	nop			; (mov r8, r8)
 8000e4c:	46c0      	nop			; (mov r8, r8)
 8000e4e:	46c0      	nop			; (mov r8, r8)

08000e50 <_put.lto_priv.66>:
                       n, TIME_INFINITE);
}

static msg_t _put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000e50:	2201      	movs	r2, #1

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
                       n, TIME_INFINITE);
}

static msg_t _put(void *ip, uint8_t b) {
 8000e52:	b508      	push	{r3, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000e54:	3030      	adds	r0, #48	; 0x30
 8000e56:	4252      	negs	r2, r2
 8000e58:	f7ff ffca 	bl	8000df0 <oqPutTimeout>
}
 8000e5c:	bd08      	pop	{r3, pc}
 8000e5e:	46c0      	nop			; (mov r8, r8)

08000e60 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
 8000e60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000e62:	465f      	mov	r7, fp
 8000e64:	4656      	mov	r6, sl
 8000e66:	4644      	mov	r4, r8
 8000e68:	464d      	mov	r5, r9
 8000e6a:	b4f0      	push	{r4, r5, r6, r7}
 8000e6c:	469b      	mov	fp, r3
  qnotify_t nfy = iqp->q_notify;
 8000e6e:	69c3      	ldr	r3, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
 8000e70:	b083      	sub	sp, #12
 8000e72:	1c04      	adds	r4, r0, #0
 8000e74:	4688      	mov	r8, r1
 8000e76:	9201      	str	r2, [sp, #4]
  qnotify_t nfy = iqp->q_notify;
 8000e78:	469a      	mov	sl, r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000e7a:	b672      	cpsid	i

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8000e7c:	1e17      	subs	r7, r2, #0
 8000e7e:	d020      	beq.n	8000ec2 <iqReadTimeout+0x62>
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
 8000e80:	68a3      	ldr	r3, [r4, #8]
 8000e82:	1c3d      	adds	r5, r7, #0
 8000e84:	42bb      	cmp	r3, r7
 8000e86:	d200      	bcs.n	8000e8a <iqReadTimeout+0x2a>
    n = iqGetFullI(iqp);
 8000e88:	68a5      	ldr	r5, [r4, #8]
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000e8a:	69a1      	ldr	r1, [r4, #24]
 8000e8c:	6923      	ldr	r3, [r4, #16]
  /*lint -restore*/
  if (n < s1) {
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000e8e:	4640      	mov	r0, r8
    n = iqGetFullI(iqp);
  }

  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000e90:	1a5e      	subs	r6, r3, r1
  /*lint -restore*/
  if (n < s1) {
 8000e92:	42ae      	cmp	r6, r5
 8000e94:	d83a      	bhi.n	8000f0c <iqReadTimeout+0xac>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
    iqp->q_rdptr += n;
  }
  else if (n > s1) {
 8000e96:	d31f      	bcc.n	8000ed8 <iqReadTimeout+0x78>
    s2 = n - s1;
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
    iqp->q_rdptr = iqp->q_buffer + s2;
  }
  else { /* n == s1 */
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000e98:	1c2a      	adds	r2, r5, #0
 8000e9a:	f004 fa99 	bl	80053d0 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8000e9e:	68e3      	ldr	r3, [r4, #12]
 8000ea0:	61a3      	str	r3, [r4, #24]
  }

  iqp->q_counter -= n;
 8000ea2:	68a3      	ldr	r3, [r4, #8]
 8000ea4:	1b5b      	subs	r3, r3, r5
 8000ea6:	60a3      	str	r3, [r4, #8]

  while (n > 0U) {
    size_t done;

    done = iq_read(iqp, bp, n);
    if (done == (size_t)0) {
 8000ea8:	2d00      	cmp	r5, #0
 8000eaa:	d028      	beq.n	8000efe <iqReadTimeout+0x9e>
      }
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
 8000eac:	4653      	mov	r3, sl
 8000eae:	2b00      	cmp	r3, #0
 8000eb0:	d001      	beq.n	8000eb6 <iqReadTimeout+0x56>
        nfy(iqp);
 8000eb2:	1c20      	adds	r0, r4, #0
 8000eb4:	47d0      	blx	sl
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000eb6:	b662      	cpsie	i
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 8000eb8:	1b7f      	subs	r7, r7, r5
      bp += done;
 8000eba:	44a8      	add	r8, r5
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ebc:	b672      	cpsid	i

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8000ebe:	2f00      	cmp	r7, #0
 8000ec0:	d1de      	bne.n	8000e80 <iqReadTimeout+0x20>
  size_t s1, s2;

  osalDbgCheck(n > 0U);

  /* Number of bytes that can be read in a single atomic operation.*/
  if (n > iqGetFullI(iqp)) {
 8000ec2:	2700      	movs	r7, #0
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000ec4:	b662      	cpsie	i
      osalSysLock();
    }
  }

  osalSysUnlock();
  return max - n;
 8000ec6:	9b01      	ldr	r3, [sp, #4]
 8000ec8:	1bd8      	subs	r0, r3, r7
}
 8000eca:	b003      	add	sp, #12
 8000ecc:	bc3c      	pop	{r2, r3, r4, r5}
 8000ece:	4690      	mov	r8, r2
 8000ed0:	4699      	mov	r9, r3
 8000ed2:	46a2      	mov	sl, r4
 8000ed4:	46ab      	mov	fp, r5
 8000ed6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (n < s1) {
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
    iqp->q_rdptr += n;
  }
  else if (n > s1) {
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8000ed8:	1c32      	adds	r2, r6, #0
 8000eda:	f004 fa79 	bl	80053d0 <memcpy>
    bp += s1;
 8000ede:	1c30      	adds	r0, r6, #0
    s2 = n - s1;
 8000ee0:	1bab      	subs	r3, r5, r6
 8000ee2:	4699      	mov	r9, r3
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8000ee4:	1c1a      	adds	r2, r3, #0
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
    iqp->q_rdptr += n;
  }
  else if (n > s1) {
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
    bp += s1;
 8000ee6:	4440      	add	r0, r8
    s2 = n - s1;
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8000ee8:	68e1      	ldr	r1, [r4, #12]
 8000eea:	f004 fa71 	bl	80053d0 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000eee:	68e3      	ldr	r3, [r4, #12]
 8000ef0:	444b      	add	r3, r9
 8000ef2:	61a3      	str	r3, [r4, #24]
  else { /* n == s1 */
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
    iqp->q_rdptr = iqp->q_buffer;
  }

  iqp->q_counter -= n;
 8000ef4:	68a3      	ldr	r3, [r4, #8]
 8000ef6:	1b5b      	subs	r3, r3, r5
 8000ef8:	60a3      	str	r3, [r4, #8]

  while (n > 0U) {
    size_t done;

    done = iq_read(iqp, bp, n);
    if (done == (size_t)0) {
 8000efa:	2d00      	cmp	r5, #0
 8000efc:	d1d6      	bne.n	8000eac <iqReadTimeout+0x4c>
 8000efe:	1c20      	adds	r0, r4, #0
 8000f00:	4659      	mov	r1, fp
 8000f02:	f7ff feed 	bl	8000ce0 <chThdEnqueueTimeoutS>
      msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8000f06:	2800      	cmp	r0, #0
 8000f08:	d0ba      	beq.n	8000e80 <iqReadTimeout+0x20>
 8000f0a:	e7db      	b.n	8000ec4 <iqReadTimeout+0x64>
  /* Number of bytes before buffer limit.*/
  /*lint -save -e9033 [10.8] Checked to be safe.*/
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
  /*lint -restore*/
  if (n < s1) {
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000f0c:	1c2a      	adds	r2, r5, #0
 8000f0e:	f004 fa5f 	bl	80053d0 <memcpy>
    iqp->q_rdptr += n;
 8000f12:	69a3      	ldr	r3, [r4, #24]
 8000f14:	195b      	adds	r3, r3, r5
 8000f16:	61a3      	str	r3, [r4, #24]
 8000f18:	e7c3      	b.n	8000ea2 <iqReadTimeout+0x42>
 8000f1a:	46c0      	nop			; (mov r8, r8)
 8000f1c:	46c0      	nop			; (mov r8, r8)
 8000f1e:	46c0      	nop			; (mov r8, r8)

08000f20 <_readt.lto_priv.71>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t _readt(void *ip, uint8_t *bp, size_t n,
                     sysinterval_t timeout) {
 8000f20:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000f22:	300c      	adds	r0, #12
 8000f24:	f7ff ff9c 	bl	8000e60 <iqReadTimeout>
}
 8000f28:	bd08      	pop	{r3, pc}
 8000f2a:	46c0      	nop			; (mov r8, r8)
 8000f2c:	46c0      	nop			; (mov r8, r8)
 8000f2e:	46c0      	nop			; (mov r8, r8)

08000f30 <_read.lto_priv.65>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
                        n, TIME_INFINITE);
}

static size_t _read(void *ip, uint8_t *bp, size_t n) {
 8000f30:	b508      	push	{r3, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000f32:	2301      	movs	r3, #1
 8000f34:	300c      	adds	r0, #12
 8000f36:	425b      	negs	r3, r3
 8000f38:	f7ff ff92 	bl	8000e60 <iqReadTimeout>
                       n, TIME_INFINITE);
}
 8000f3c:	bd08      	pop	{r3, pc}
 8000f3e:	46c0      	nop			; (mov r8, r8)

08000f40 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8000f40:	b538      	push	{r3, r4, r5, lr}
 8000f42:	1c04      	adds	r4, r0, #0
 8000f44:	1c0d      	adds	r5, r1, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000f46:	b672      	cpsid	i
 8000f48:	e005      	b.n	8000f56 <iqGetTimeout+0x16>
 8000f4a:	1c20      	adds	r0, r4, #0
 8000f4c:	1c29      	adds	r1, r5, #0
 8000f4e:	f7ff fec7 	bl	8000ce0 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8000f52:	2800      	cmp	r0, #0
 8000f54:	db16      	blt.n	8000f84 <iqGetTimeout+0x44>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8000f56:	68a3      	ldr	r3, [r4, #8]
 8000f58:	2b00      	cmp	r3, #0
 8000f5a:	d0f6      	beq.n	8000f4a <iqGetTimeout+0xa>
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8000f5c:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8000f5e:	69a2      	ldr	r2, [r4, #24]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8000f60:	3b01      	subs	r3, #1
 8000f62:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8000f64:	1c53      	adds	r3, r2, #1
 8000f66:	61a3      	str	r3, [r4, #24]
 8000f68:	7815      	ldrb	r5, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000f6a:	6922      	ldr	r2, [r4, #16]
 8000f6c:	4293      	cmp	r3, r2
 8000f6e:	d301      	bcc.n	8000f74 <iqGetTimeout+0x34>
    iqp->q_rdptr = iqp->q_buffer;
 8000f70:	68e3      	ldr	r3, [r4, #12]
 8000f72:	61a3      	str	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 8000f74:	69e3      	ldr	r3, [r4, #28]
 8000f76:	2b00      	cmp	r3, #0
 8000f78:	d001      	beq.n	8000f7e <iqGetTimeout+0x3e>
    iqp->q_notify(iqp);
 8000f7a:	1c20      	adds	r0, r4, #0
 8000f7c:	4798      	blx	r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000f7e:	b662      	cpsie	i
  }

  osalSysUnlock();

  return (msg_t)b;
 8000f80:	1c28      	adds	r0, r5, #0
}
 8000f82:	bd38      	pop	{r3, r4, r5, pc}
 8000f84:	b662      	cpsie	i
 8000f86:	e7fc      	b.n	8000f82 <iqGetTimeout+0x42>
 8000f88:	46c0      	nop			; (mov r8, r8)
 8000f8a:	46c0      	nop			; (mov r8, r8)
 8000f8c:	46c0      	nop			; (mov r8, r8)
 8000f8e:	46c0      	nop			; (mov r8, r8)

08000f90 <_gett.lto_priv.69>:
static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t _gett(void *ip, sysinterval_t timeout) {
 8000f90:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000f92:	300c      	adds	r0, #12
 8000f94:	f7ff ffd4 	bl	8000f40 <iqGetTimeout>
}
 8000f98:	bd08      	pop	{r3, pc}
 8000f9a:	46c0      	nop			; (mov r8, r8)
 8000f9c:	46c0      	nop			; (mov r8, r8)
 8000f9e:	46c0      	nop			; (mov r8, r8)

08000fa0 <_get.lto_priv.67>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t _get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000fa0:	2101      	movs	r1, #1
static msg_t _put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t _get(void *ip) {
 8000fa2:	b508      	push	{r3, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000fa4:	300c      	adds	r0, #12
 8000fa6:	4249      	negs	r1, r1
 8000fa8:	f7ff ffca 	bl	8000f40 <iqGetTimeout>
}
 8000fac:	bd08      	pop	{r3, pc}
 8000fae:	46c0      	nop			; (mov r8, r8)

08000fb0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8000fb0:	b508      	push	{r3, lr}
 8000fb2:	1c01      	adds	r1, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000fb4:	b672      	cpsid	i
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8000fb6:	2008      	movs	r0, #8
 8000fb8:	f7ff fe72 	bl	8000ca0 <chSchGoSleepTimeoutS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000fbc:	b662      	cpsie	i

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 8000fbe:	bd08      	pop	{r3, pc}

08000fc0 <chSysRestoreStatusX.part.2.lto_priv.154>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 8000fc0:	b508      	push	{r3, lr}
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8000fc2:	f3ef 8305 	mrs	r3, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 8000fc6:	05db      	lsls	r3, r3, #23

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 8000fc8:	d101      	bne.n	8000fce <chSysRestoreStatusX.part.2.lto_priv.154+0xe>
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 8000fca:	f7ff faa1 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000fce:	b662      	cpsie	i
      chSysUnlock();
    }
  }
}
 8000fd0:	bd08      	pop	{r3, pc}
 8000fd2:	46c0      	nop			; (mov r8, r8)
 8000fd4:	46c0      	nop			; (mov r8, r8)
 8000fd6:	46c0      	nop			; (mov r8, r8)
 8000fd8:	46c0      	nop			; (mov r8, r8)
 8000fda:	46c0      	nop			; (mov r8, r8)
 8000fdc:	46c0      	nop			; (mov r8, r8)
 8000fde:	46c0      	nop			; (mov r8, r8)

08000fe0 <chSysGetStatusAndLockX>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8000fe0:	f3ef 8010 	mrs	r0, PRIMASK
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8000fe4:	07c3      	lsls	r3, r0, #31
 8000fe6:	d402      	bmi.n	8000fee <chSysGetStatusAndLockX+0xe>
 */
__STATIC_FORCEINLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8000fe8:	f3ef 8305 	mrs	r3, IPSR
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000fec:	b672      	cpsid	i
    else {
      chSysLock();
    }
  }
  return sts;
}
 8000fee:	4770      	bx	lr

08000ff0 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8000ff0:	b530      	push	{r4, r5, lr}
 8000ff2:	1c05      	adds	r5, r0, #0
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8000ff4:	07c3      	lsls	r3, r0, #31
 8000ff6:	d511      	bpl.n	800101c <chSysIntegrityCheckI+0x2c>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
 8000ff8:	4a28      	ldr	r2, [pc, #160]	; (800109c <chSysIntegrityCheckI+0xac>)
 8000ffa:	6811      	ldr	r1, [r2, #0]
    while (tp != (thread_t *)&ch.rlist.queue) {
 8000ffc:	4291      	cmp	r1, r2
 8000ffe:	d03c      	beq.n	800107a <chSysIntegrityCheckI+0x8a>
 8001000:	2300      	movs	r3, #0
      n++;
      tp = tp->queue.next;
 8001002:	6809      	ldr	r1, [r1, #0]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
      n++;
 8001004:	3301      	adds	r3, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001006:	4291      	cmp	r1, r2
 8001008:	d1fb      	bne.n	8001002 <chSysIntegrityCheckI+0x12>
      n++;
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
 800100a:	684c      	ldr	r4, [r1, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 800100c:	428c      	cmp	r4, r1
 800100e:	d032      	beq.n	8001076 <chSysIntegrityCheckI+0x86>
      n--;
      tp = tp->queue.prev;
 8001010:	6864      	ldr	r4, [r4, #4]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
      n--;
 8001012:	3b01      	subs	r3, #1
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8001014:	4294      	cmp	r4, r2
 8001016:	d1fb      	bne.n	8001010 <chSysIntegrityCheckI+0x20>
      n--;
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8001018:	2b00      	cmp	r3, #0
 800101a:	d12c      	bne.n	8001076 <chSysIntegrityCheckI+0x86>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 800101c:	07ab      	lsls	r3, r5, #30
 800101e:	d513      	bpl.n	8001048 <chSysIntegrityCheckI+0x58>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
 8001020:	4b1e      	ldr	r3, [pc, #120]	; (800109c <chSysIntegrityCheckI+0xac>)
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001022:	1c1c      	adds	r4, r3, #0
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
 8001024:	69da      	ldr	r2, [r3, #28]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001026:	341c      	adds	r4, #28
 8001028:	42a2      	cmp	r2, r4
 800102a:	d02b      	beq.n	8001084 <chSysIntegrityCheckI+0x94>
 800102c:	2300      	movs	r3, #0
      n++;
      vtp = vtp->next;
 800102e:	6812      	ldr	r2, [r2, #0]

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n++;
 8001030:	3301      	adds	r3, #1
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001032:	42a2      	cmp	r2, r4
 8001034:	d1fb      	bne.n	800102e <chSysIntegrityCheckI+0x3e>
      n++;
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
 8001036:	6851      	ldr	r1, [r2, #4]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001038:	4291      	cmp	r1, r2
 800103a:	d01c      	beq.n	8001076 <chSysIntegrityCheckI+0x86>
      n--;
      vtp = vtp->prev;
 800103c:	6849      	ldr	r1, [r1, #4]
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n--;
 800103e:	3b01      	subs	r3, #1
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8001040:	42a1      	cmp	r1, r4
 8001042:	d1fb      	bne.n	800103c <chSysIntegrityCheckI+0x4c>
      n--;
      vtp = vtp->prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8001044:	2b00      	cmp	r3, #0
 8001046:	d116      	bne.n	8001076 <chSysIntegrityCheckI+0x86>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 8001048:	2000      	movs	r0, #0
      return true;
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 800104a:	076b      	lsls	r3, r5, #29
 800104c:	d512      	bpl.n	8001074 <chSysIntegrityCheckI+0x84>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
 800104e:	4a13      	ldr	r2, [pc, #76]	; (800109c <chSysIntegrityCheckI+0xac>)
 8001050:	6911      	ldr	r1, [r2, #16]
    while (tp != (thread_t *)&ch.rlist) {
 8001052:	4291      	cmp	r1, r2
 8001054:	d01c      	beq.n	8001090 <chSysIntegrityCheckI+0xa0>
 8001056:	2300      	movs	r3, #0
      n++;
      tp = tp->newer;
 8001058:	6909      	ldr	r1, [r1, #16]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
      n++;
 800105a:	3301      	adds	r3, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
 800105c:	4291      	cmp	r1, r2
 800105e:	d1fb      	bne.n	8001058 <chSysIntegrityCheckI+0x68>
      n++;
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
 8001060:	694c      	ldr	r4, [r1, #20]
    while (tp != (thread_t *)&ch.rlist) {
 8001062:	428c      	cmp	r4, r1
 8001064:	d007      	beq.n	8001076 <chSysIntegrityCheckI+0x86>
      n--;
      tp = tp->older;
 8001066:	6964      	ldr	r4, [r4, #20]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
      n--;
 8001068:	3b01      	subs	r3, #1
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
 800106a:	4294      	cmp	r4, r2
 800106c:	d1fb      	bne.n	8001066 <chSysIntegrityCheckI+0x76>
      n--;
      tp = tp->older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800106e:	1e58      	subs	r0, r3, #1
 8001070:	4183      	sbcs	r3, r0
 8001072:	b2d8      	uxtb	r0, r3
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 8001074:	bd30      	pop	{r4, r5, pc}
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 8001076:	2001      	movs	r0, #1
 8001078:	e7fc      	b.n	8001074 <chSysIntegrityCheckI+0x84>
      n++;
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
 800107a:	6854      	ldr	r4, [r2, #4]
  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800107c:	2300      	movs	r3, #0
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
 800107e:	4294      	cmp	r4, r2
 8001080:	d1c6      	bne.n	8001010 <chSysIntegrityCheckI+0x20>
 8001082:	e7cb      	b.n	800101c <chSysIntegrityCheckI+0x2c>
      n++;
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
 8001084:	6a19      	ldr	r1, [r3, #32]
 8001086:	1c14      	adds	r4, r2, #0
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 8001088:	2300      	movs	r3, #0
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800108a:	4291      	cmp	r1, r2
 800108c:	d1d6      	bne.n	800103c <chSysIntegrityCheckI+0x4c>
 800108e:	e7db      	b.n	8001048 <chSysIntegrityCheckI+0x58>
      n++;
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
 8001090:	694c      	ldr	r4, [r1, #20]
#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 8001092:	2300      	movs	r3, #0
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
 8001094:	428c      	cmp	r4, r1
 8001096:	d1e6      	bne.n	8001066 <chSysIntegrityCheckI+0x76>
 8001098:	e7ec      	b.n	8001074 <chSysIntegrityCheckI+0x84>
 800109a:	46c0      	nop			; (mov r8, r8)
 800109c:	20000e84 	.word	0x20000e84

080010a0 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
 80010a0:	209c      	movs	r0, #156	; 0x9c
 80010a2:	4a47      	ldr	r2, [pc, #284]	; (80011c0 <__early_init+0x120>)
 80010a4:	03c0      	lsls	r0, r0, #15
 80010a6:	6a91      	ldr	r1, [r2, #40]	; 0x28
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80010a8:	b530      	push	{r4, r5, lr}

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
 80010aa:	4301      	orrs	r1, r0
 80010ac:	6291      	str	r1, [r2, #40]	; 0x28
 80010ae:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80010b0:	4944      	ldr	r1, [pc, #272]	; (80011c4 <__early_init+0x124>)

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80010b2:	4c45      	ldr	r4, [pc, #276]	; (80011c8 <__early_init+0x128>)

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
 80010b4:	4019      	ands	r1, r3
 80010b6:	6291      	str	r1, [r2, #40]	; 0x28
 80010b8:	6a93      	ldr	r3, [r2, #40]	; 0x28
  rccEnableAHB(STM32_GPIO_EN_MASK, true);
 80010ba:	6953      	ldr	r3, [r2, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80010bc:	2190      	movs	r1, #144	; 0x90
static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
  rccEnableAHB(STM32_GPIO_EN_MASK, true);
 80010be:	4303      	orrs	r3, r0
 80010c0:	6153      	str	r3, [r2, #20]
 80010c2:	6953      	ldr	r3, [r2, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80010c4:	2300      	movs	r3, #0
  gpiop->OSPEEDR = config->ospeedr;
 80010c6:	4841      	ldr	r0, [pc, #260]	; (80011cc <__early_init+0x12c>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80010c8:	05c9      	lsls	r1, r1, #23
 80010ca:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80010cc:	6088      	str	r0, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 80010ce:	4840      	ldr	r0, [pc, #256]	; (80011d0 <__early_init+0x130>)
 80010d0:	4d40      	ldr	r5, [pc, #256]	; (80011d4 <__early_init+0x134>)
 80010d2:	60c8      	str	r0, [r1, #12]
  gpiop->ODR     = config->odr;
 80010d4:	4840      	ldr	r0, [pc, #256]	; (80011d8 <__early_init+0x138>)
 80010d6:	6148      	str	r0, [r1, #20]
  gpiop->AFRL    = config->afrl;
 80010d8:	2080      	movs	r0, #128	; 0x80
 80010da:	0040      	lsls	r0, r0, #1
 80010dc:	6208      	str	r0, [r1, #32]
  gpiop->AFRH    = config->afrh;
 80010de:	2080      	movs	r0, #128	; 0x80
 80010e0:	0540      	lsls	r0, r0, #21
 80010e2:	6248      	str	r0, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80010e4:	483d      	ldr	r0, [pc, #244]	; (80011dc <__early_init+0x13c>)
 80010e6:	6008      	str	r0, [r1, #0]
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80010e8:	2001      	movs	r0, #1
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80010ea:	493d      	ldr	r1, [pc, #244]	; (80011e0 <__early_init+0x140>)
  gpiop->OSPEEDR = config->ospeedr;
 80010ec:	4240      	negs	r0, r0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80010ee:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80010f0:	6088      	str	r0, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 80010f2:	60cc      	str	r4, [r1, #12]
  gpiop->ODR     = config->odr;
 80010f4:	4c3b      	ldr	r4, [pc, #236]	; (80011e4 <__early_init+0x144>)
 80010f6:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80010f8:	2440      	movs	r4, #64	; 0x40

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 80010fa:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 80010fc:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80010fe:	600c      	str	r4, [r1, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001100:	4939      	ldr	r1, [pc, #228]	; (80011e8 <__early_init+0x148>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8001102:	4c3a      	ldr	r4, [pc, #232]	; (80011ec <__early_init+0x14c>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001104:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001106:	6088      	str	r0, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8001108:	60cd      	str	r5, [r1, #12]
  gpiop->ODR     = config->odr;
 800110a:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 800110c:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 800110e:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001110:	600b      	str	r3, [r1, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001112:	4937      	ldr	r1, [pc, #220]	; (80011f0 <__early_init+0x150>)
 8001114:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001116:	6088      	str	r0, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8001118:	60cd      	str	r5, [r1, #12]
  gpiop->ODR     = config->odr;
 800111a:	614c      	str	r4, [r1, #20]
  gpiop->AFRL    = config->afrl;
 800111c:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
 800111e:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001120:	600b      	str	r3, [r1, #0]
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001122:	6811      	ldr	r1, [r2, #0]
 8001124:	3301      	adds	r3, #1
 8001126:	430b      	orrs	r3, r1
 8001128:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800112a:	3003      	adds	r0, #3
 800112c:	6811      	ldr	r1, [r2, #0]
 800112e:	4b24      	ldr	r3, [pc, #144]	; (80011c0 <__early_init+0x120>)
 8001130:	4208      	tst	r0, r1
 8001132:	d0fb      	beq.n	800112c <__early_init+0x8c>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8001134:	2103      	movs	r1, #3
 8001136:	685a      	ldr	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001138:	200c      	movs	r0, #12
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 800113a:	438a      	bics	r2, r1
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800113c:	1c19      	adds	r1, r3, #0
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 800113e:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001140:	684b      	ldr	r3, [r1, #4]
 8001142:	4a1f      	ldr	r2, [pc, #124]	; (80011c0 <__early_init+0x120>)
 8001144:	4003      	ands	r3, r0
 8001146:	d1fb      	bne.n	8001140 <__early_init+0xa0>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001148:	20f9      	movs	r0, #249	; 0xf9
 800114a:	6811      	ldr	r1, [r2, #0]
 800114c:	4001      	ands	r1, r0
 800114e:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001150:	6053      	str	r3, [r2, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8001152:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8001154:	3301      	adds	r3, #1
 8001156:	430b      	orrs	r3, r1
 8001158:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 800115a:	38f7      	subs	r0, #247	; 0xf7
 800115c:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800115e:	4b18      	ldr	r3, [pc, #96]	; (80011c0 <__early_init+0x120>)
 8001160:	4208      	tst	r0, r1
 8001162:	d0fb      	beq.n	800115c <__early_init+0xbc>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001164:	2201      	movs	r2, #1
 8001166:	6a59      	ldr	r1, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001168:	2002      	movs	r0, #2
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800116a:	430a      	orrs	r2, r1
 800116c:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800116e:	1c1a      	adds	r2, r3, #0
 8001170:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8001172:	4b13      	ldr	r3, [pc, #76]	; (80011c0 <__early_init+0x120>)
 8001174:	4208      	tst	r0, r1
 8001176:	d0fb      	beq.n	8001170 <__early_init+0xd0>
#endif

  /* Clock settings.*/
  /* CFGR2 must be configured first since CFGR value could change CFGR2 */
  RCC->CFGR2 = STM32_PREDIV;
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8001178:	21a0      	movs	r1, #160	; 0xa0
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  /* CFGR2 must be configured first since CFGR value could change CFGR2 */
  RCC->CFGR2 = STM32_PREDIV;
 800117a:	2200      	movs	r2, #0
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 800117c:	0389      	lsls	r1, r1, #14
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  /* CFGR2 must be configured first since CFGR value could change CFGR2 */
  RCC->CFGR2 = STM32_PREDIV;
 800117e:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8001180:	6059      	str	r1, [r3, #4]
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001182:	2180      	movs	r1, #128	; 0x80
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001184:	2080      	movs	r0, #128	; 0x80
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE |
               ((STM32_PREDIV & STM32_PLLXTPRE_MASK) << STM32_PLLXTPRE_OFFSET);
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 8001186:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001188:	681a      	ldr	r2, [r3, #0]
 800118a:	0449      	lsls	r1, r1, #17
 800118c:	430a      	orrs	r2, r1
 800118e:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001190:	0480      	lsls	r0, r0, #18
 8001192:	6819      	ldr	r1, [r3, #0]
 8001194:	4a0a      	ldr	r2, [pc, #40]	; (80011c0 <__early_init+0x120>)
 8001196:	4201      	tst	r1, r0
 8001198:	d0fb      	beq.n	8001192 <__early_init+0xf2>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 800119a:	2111      	movs	r1, #17
 800119c:	4b15      	ldr	r3, [pc, #84]	; (80011f4 <__early_init+0x154>)

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800119e:	200c      	movs	r0, #12
  while (!(RCC->CR & RCC_CR_PLLRDY))
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80011a0:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 80011a2:	2302      	movs	r3, #2
 80011a4:	6851      	ldr	r1, [r2, #4]
 80011a6:	430b      	orrs	r3, r1
 80011a8:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80011aa:	6853      	ldr	r3, [r2, #4]
 80011ac:	4904      	ldr	r1, [pc, #16]	; (80011c0 <__early_init+0x120>)
 80011ae:	4003      	ands	r3, r0
 80011b0:	2b08      	cmp	r3, #8
 80011b2:	d1fa      	bne.n	80011aa <__early_init+0x10a>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 80011b4:	698a      	ldr	r2, [r1, #24]
 80011b6:	3b07      	subs	r3, #7
 80011b8:	4313      	orrs	r3, r2
 80011ba:	618b      	str	r3, [r1, #24]
 80011bc:	698b      	ldr	r3, [r1, #24]
 */
void __early_init(void) {

  stm32_gpio_init();
  stm32_clock_init();
}
 80011be:	bd30      	pop	{r4, r5, pc}
 80011c0:	40021000 	.word	0x40021000
 80011c4:	ffb1ffff 	.word	0xffb1ffff
 80011c8:	55555515 	.word	0x55555515
 80011cc:	fffff75f 	.word	0xfffff75f
 80011d0:	25555545 	.word	0x25555545
 80011d4:	55555555 	.word	0x55555555
 80011d8:	0000ffdf 	.word	0x0000ffdf
 80011dc:	a8000020 	.word	0xa8000020
 80011e0:	48000400 	.word	0x48000400
 80011e4:	0000fff7 	.word	0x0000fff7
 80011e8:	48000800 	.word	0x48000800
 80011ec:	0000ffff 	.word	0x0000ffff
 80011f0:	48001400 	.word	0x48001400
 80011f4:	40022000 	.word	0x40022000
 80011f8:	46c0      	nop			; (mov r8, r8)
 80011fa:	46c0      	nop			; (mov r8, r8)
 80011fc:	46c0      	nop			; (mov r8, r8)
 80011fe:	46c0      	nop			; (mov r8, r8)

08001200 <VectorB0>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001200:	b510      	push	{r4, lr}
 8001202:	4674      	mov	r4, lr

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);
 8001204:	4803      	ldr	r0, [pc, #12]	; (8001214 <VectorB0+0x14>)
 8001206:	f7ff fbfb 	bl	8000a00 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800120a:	1c20      	adds	r0, r4, #0
 800120c:	f002 ff48 	bl	80040a0 <_port_irq_epilogue>
}
 8001210:	bd10      	pop	{r4, pc}
 8001212:	46c0      	nop			; (mov r8, r8)
 8001214:	20000684 	.word	0x20000684
 8001218:	46c0      	nop			; (mov r8, r8)
 800121a:	46c0      	nop			; (mov r8, r8)
 800121c:	46c0      	nop			; (mov r8, r8)
 800121e:	46c0      	nop			; (mov r8, r8)

08001220 <VectorAC>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001220:	b510      	push	{r4, lr}
 8001222:	4674      	mov	r4, lr

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);
 8001224:	4803      	ldr	r0, [pc, #12]	; (8001234 <VectorAC+0x14>)
 8001226:	f7ff fbeb 	bl	8000a00 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800122a:	1c20      	adds	r0, r4, #0
 800122c:	f002 ff38 	bl	80040a0 <_port_irq_epilogue>
}
 8001230:	bd10      	pop	{r4, pc}
 8001232:	46c0      	nop			; (mov r8, r8)
 8001234:	20000624 	.word	0x20000624
 8001238:	46c0      	nop			; (mov r8, r8)
 800123a:	46c0      	nop			; (mov r8, r8)
 800123c:	46c0      	nop			; (mov r8, r8)
 800123e:	46c0      	nop			; (mov r8, r8)

08001240 <Vector7C>:
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001240:	2280      	movs	r2, #128	; 0x80
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001242:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001244:	464f      	mov	r7, r9
 8001246:	4646      	mov	r6, r8
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001248:	05d2      	lsls	r2, r2, #23
 800124a:	6913      	ldr	r3, [r2, #16]
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 800124c:	b4c0      	push	{r6, r7}

  OSAL_IRQ_PROLOGUE();
 800124e:	46f1      	mov	r9, lr

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001250:	079b      	lsls	r3, r3, #30
 8001252:	d406      	bmi.n	8001262 <Vector7C+0x22>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8001254:	4648      	mov	r0, r9
 8001256:	f002 ff23 	bl	80040a0 <_port_irq_epilogue>
}
 800125a:	bc0c      	pop	{r2, r3}
 800125c:	4690      	mov	r8, r2
 800125e:	4699      	mov	r9, r3
 8001260:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8001262:	2300      	movs	r3, #0
 8001264:	6113      	str	r3, [r2, #16]
 8001266:	b672      	cpsid	i
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8001268:	4c1d      	ldr	r4, [pc, #116]	; (80012e0 <Vector7C+0xa0>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800126a:	4690      	mov	r8, r2

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800126c:	1c26      	adds	r6, r4, #0
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 800126e:	2700      	movs	r7, #0
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8001270:	69e3      	ldr	r3, [r4, #28]

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001272:	361c      	adds	r6, #28
 8001274:	6899      	ldr	r1, [r3, #8]
 8001276:	4642      	mov	r2, r8
 8001278:	6a50      	ldr	r0, [r2, #36]	; 0x24
  vtp = ch.vtlist.next;
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 800127a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 800127c:	1a85      	subs	r5, r0, r2

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 800127e:	428d      	cmp	r5, r1
 8001280:	d209      	bcs.n	8001296 <Vector7C+0x56>
 8001282:	e015      	b.n	80012b0 <Vector7C+0x70>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001284:	b662      	cpsie	i
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 8001286:	6918      	ldr	r0, [r3, #16]
 8001288:	4788      	blx	r1
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800128a:	b672      	cpsid	i
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 800128c:	69e3      	ldr	r3, [r4, #28]
    }
    while (vtp->delta <= nowdelta);
 800128e:	6899      	ldr	r1, [r3, #8]
 8001290:	428d      	cmp	r5, r1
 8001292:	d3f0      	bcc.n	8001276 <Vector7C+0x36>
 8001294:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    /* Consuming all timers between "vtp->lasttime" and now.*/
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
 8001296:	1852      	adds	r2, r2, r1
 8001298:	62a2      	str	r2, [r4, #40]	; 0x28
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800129a:	681a      	ldr	r2, [r3, #0]
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;
 800129c:	1a6d      	subs	r5, r5, r1

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800129e:	6056      	str	r6, [r2, #4]
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
 80012a0:	68d9      	ldr	r1, [r3, #12]
      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
      ch.vtlist.next = vtp->next;
 80012a2:	61e2      	str	r2, [r4, #28]
      fn = vtp->func;
      vtp->func = NULL;
 80012a4:	60df      	str	r7, [r3, #12]

      /* if the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80012a6:	42b2      	cmp	r2, r6
 80012a8:	d1ec      	bne.n	8001284 <Vector7C+0x44>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80012aa:	4642      	mov	r2, r8
 80012ac:	60d7      	str	r7, [r2, #12]
 80012ae:	e7e9      	b.n	8001284 <Vector7C+0x44>
    }
    while (vtp->delta <= nowdelta);
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80012b0:	1c26      	adds	r6, r4, #0
 80012b2:	69e1      	ldr	r1, [r4, #28]
 80012b4:	361c      	adds	r6, #28
 80012b6:	42b1      	cmp	r1, r6
 80012b8:	d00d      	beq.n	80012d6 <Vector7C+0x96>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
 80012ba:	1952      	adds	r2, r2, r5
 80012bc:	62a2      	str	r2, [r4, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 80012be:	688c      	ldr	r4, [r1, #8]
 80012c0:	1a12      	subs	r2, r2, r0
 80012c2:	1b65      	subs	r5, r4, r5
 80012c4:	608d      	str	r5, [r1, #8]
 80012c6:	689b      	ldr	r3, [r3, #8]
 80012c8:	18d2      	adds	r2, r2, r3

  /* Recalculating the next alarm time.*/
  delta = chTimeDiffX(now, chTimeAddX(ch.vtlist.lasttime, vtp->delta));
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 80012ca:	2a01      	cmp	r2, #1
 80012cc:	d905      	bls.n	80012da <Vector7C+0x9a>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80012ce:	2380      	movs	r3, #128	; 0x80

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)((systime_t)-1));
#endif

  return systime + (systime_t)interval;
 80012d0:	1810      	adds	r0, r2, r0
 80012d2:	05db      	lsls	r3, r3, #23
 80012d4:	6358      	str	r0, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80012d6:	b662      	cpsie	i
 80012d8:	e7bc      	b.n	8001254 <Vector7C+0x14>
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80012da:	2202      	movs	r2, #2
 80012dc:	e7f7      	b.n	80012ce <Vector7C+0x8e>
 80012de:	46c0      	nop			; (mov r8, r8)
 80012e0:	20000e84 	.word	0x20000e84
 80012e4:	46c0      	nop			; (mov r8, r8)
 80012e6:	46c0      	nop			; (mov r8, r8)
 80012e8:	46c0      	nop			; (mov r8, r8)
 80012ea:	46c0      	nop			; (mov r8, r8)
 80012ec:	46c0      	nop			; (mov r8, r8)
 80012ee:	46c0      	nop			; (mov r8, r8)

080012f0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80012f0:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80012f2:	4e0f      	ldr	r6, [pc, #60]	; (8001330 <__init_ram_areas+0x40>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 80012f4:	2500      	movs	r5, #0
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80012f6:	1c37      	adds	r7, r6, #0
 80012f8:	3780      	adds	r7, #128	; 0x80
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;
 80012fa:	6873      	ldr	r3, [r6, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80012fc:	68b4      	ldr	r4, [r6, #8]
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 80012fe:	6831      	ldr	r1, [r6, #0]
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001300:	42a3      	cmp	r3, r4
 8001302:	d20a      	bcs.n	800131a <__init_ram_areas+0x2a>
 8001304:	1c1a      	adds	r2, r3, #0
      *p = *tp;
 8001306:	c901      	ldmia	r1!, {r0}
 8001308:	c201      	stmia	r2!, {r0}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800130a:	42a2      	cmp	r2, r4
 800130c:	d3fb      	bcc.n	8001306 <__init_ram_areas+0x16>
 800130e:	43da      	mvns	r2, r3
 8001310:	1914      	adds	r4, r2, r4
 8001312:	08a4      	lsrs	r4, r4, #2
 8001314:	3401      	adds	r4, #1
 8001316:	00a4      	lsls	r4, r4, #2
 8001318:	191b      	adds	r3, r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800131a:	68f2      	ldr	r2, [r6, #12]
 800131c:	4293      	cmp	r3, r2
 800131e:	d202      	bcs.n	8001326 <__init_ram_areas+0x36>
      *p = 0;
 8001320:	c320      	stmia	r3!, {r5}
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001322:	4293      	cmp	r3, r2
 8001324:	d3fc      	bcc.n	8001320 <__init_ram_areas+0x30>
      *p = 0;
      p++;
    }
    rap++;
 8001326:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001328:	42be      	cmp	r6, r7
 800132a:	d3e6      	bcc.n	80012fa <__init_ram_areas+0xa>
#endif
}
 800132c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800132e:	46c0      	nop			; (mov r8, r8)
 8001330:	0800546c 	.word	0x0800546c
 8001334:	46c0      	nop			; (mov r8, r8)
 8001336:	46c0      	nop			; (mov r8, r8)
 8001338:	46c0      	nop			; (mov r8, r8)
 800133a:	46c0      	nop			; (mov r8, r8)
 800133c:	46c0      	nop			; (mov r8, r8)
 800133e:	46c0      	nop			; (mov r8, r8)

08001340 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001340:	e7fe      	b.n	8001340 <__default_exit>
 8001342:	46c0      	nop			; (mov r8, r8)
 8001344:	46c0      	nop			; (mov r8, r8)
 8001346:	46c0      	nop			; (mov r8, r8)
 8001348:	46c0      	nop			; (mov r8, r8)
 800134a:	46c0      	nop			; (mov r8, r8)
 800134c:	46c0      	nop			; (mov r8, r8)
 800134e:	46c0      	nop			; (mov r8, r8)

08001350 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001350:	4770      	bx	lr
 8001352:	46c0      	nop			; (mov r8, r8)
 8001354:	46c0      	nop			; (mov r8, r8)
 8001356:	46c0      	nop			; (mov r8, r8)
 8001358:	46c0      	nop			; (mov r8, r8)
 800135a:	46c0      	nop			; (mov r8, r8)
 800135c:	46c0      	nop			; (mov r8, r8)
 800135e:	46c0      	nop			; (mov r8, r8)

08001360 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8001360:	4770      	bx	lr
 8001362:	46c0      	nop			; (mov r8, r8)
 8001364:	46c0      	nop			; (mov r8, r8)
 8001366:	46c0      	nop			; (mov r8, r8)
 8001368:	46c0      	nop			; (mov r8, r8)
 800136a:	46c0      	nop			; (mov r8, r8)
 800136c:	46c0      	nop			; (mov r8, r8)
 800136e:	46c0      	nop			; (mov r8, r8)

08001370 <rt_test_005_005_setup.lto_priv.95>:
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 8001370:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001372:	4b02      	ldr	r3, [pc, #8]	; (800137c <rt_test_005_005_setup.lto_priv.95+0xc>)
 8001374:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001376:	605b      	str	r3, [r3, #4]
 8001378:	609a      	str	r2, [r3, #8]
 * .
 */

static void rt_test_005_005_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 800137a:	4770      	bx	lr
 800137c:	20000e74 	.word	0x20000e74

08001380 <rt_test_005_004_setup.lto_priv.93>:
 8001380:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001382:	4b02      	ldr	r3, [pc, #8]	; (800138c <rt_test_005_004_setup.lto_priv.93+0xc>)
 8001384:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001386:	605b      	str	r3, [r3, #4]
 8001388:	609a      	str	r2, [r3, #8]
 * .
 */

static void rt_test_005_004_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 800138a:	4770      	bx	lr
 800138c:	20000e74 	.word	0x20000e74

08001390 <rt_test_005_003_setup.lto_priv.91>:
 8001390:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001392:	4b02      	ldr	r3, [pc, #8]	; (800139c <rt_test_005_003_setup.lto_priv.91+0xc>)
 8001394:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001396:	605b      	str	r3, [r3, #4]
 8001398:	609a      	str	r2, [r3, #8]
 * .
 */

static void rt_test_005_003_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 800139a:	4770      	bx	lr
 800139c:	20000e74 	.word	0x20000e74

080013a0 <rt_test_005_002_setup.lto_priv.89>:
 80013a0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80013a2:	4b02      	ldr	r3, [pc, #8]	; (80013ac <rt_test_005_002_setup.lto_priv.89+0xc>)
 80013a4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80013a6:	605b      	str	r3, [r3, #4]
 80013a8:	609a      	str	r2, [r3, #8]
 * .
 */

static void rt_test_005_002_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 80013aa:	4770      	bx	lr
 80013ac:	20000e74 	.word	0x20000e74

080013b0 <rt_test_005_001_setup.lto_priv.86>:
 80013b0:	2201      	movs	r2, #1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80013b2:	4b02      	ldr	r3, [pc, #8]	; (80013bc <rt_test_005_001_setup.lto_priv.86+0xc>)
 80013b4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80013b6:	605b      	str	r3, [r3, #4]
 80013b8:	609a      	str	r2, [r3, #8]
 * .
 */

static void rt_test_005_001_setup(void) {
  chSemObjectInit(&sem1, 1);
}
 80013ba:	4770      	bx	lr
 80013bc:	20000e74 	.word	0x20000e74

080013c0 <rt_test_004_001_setup.lto_priv.84>:
 *   the state of the reference are tested.
 * .
 */

static void rt_test_004_001_setup(void) {
  tr1 = NULL;
 80013c0:	2200      	movs	r2, #0
 80013c2:	4b01      	ldr	r3, [pc, #4]	; (80013c8 <rt_test_004_001_setup.lto_priv.84+0x8>)
 80013c4:	601a      	str	r2, [r3, #0]
}
 80013c6:	4770      	bx	lr
 80013c8:	20000430 	.word	0x20000430
 80013cc:	46c0      	nop			; (mov r8, r8)
 80013ce:	46c0      	nop			; (mov r8, r8)

080013d0 <rt_test_002_004_execute.lto_priv.79>:

static void rt_test_002_004_execute(void) {

  /* [2.4.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
 80013d0:	2201      	movs	r2, #1
 80013d2:	4b04      	ldr	r3, [pc, #16]	; (80013e4 <rt_test_002_004_execute.lto_priv.79+0x14>)
 80013d4:	601a      	str	r2, [r3, #0]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80013d6:	2280      	movs	r2, #128	; 0x80
 80013d8:	05d2      	lsls	r2, r2, #23
 80013da:	6a51      	ldr	r1, [r2, #36]	; 0x24
 80013dc:	6a53      	ldr	r3, [r2, #36]	; 0x24
  {
    systime_t time = chVTGetSystemTimeX();
    while (time == chVTGetSystemTimeX()) {
 80013de:	428b      	cmp	r3, r1
 80013e0:	d0fc      	beq.n	80013dc <rt_test_002_004_execute.lto_priv.79+0xc>
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    }
  }
}
 80013e2:	4770      	bx	lr
 80013e4:	20000d64 	.word	0x20000d64
 80013e8:	46c0      	nop			; (mov r8, r8)
 80013ea:	46c0      	nop			; (mov r8, r8)
 80013ec:	46c0      	nop			; (mov r8, r8)
 80013ee:	46c0      	nop			; (mov r8, r8)

080013f0 <rt_test_005_001_teardown.lto_priv.87>:

static void rt_test_005_001_teardown(void) {
 80013f0:	b508      	push	{r3, lr}
  chSemReset(&sem1, 0);
 80013f2:	4802      	ldr	r0, [pc, #8]	; (80013fc <rt_test_005_001_teardown.lto_priv.87+0xc>)
 80013f4:	2100      	movs	r1, #0
 80013f6:	f7ff fac3 	bl	8000980 <chSemReset>
}
 80013fa:	bd08      	pop	{r3, pc}
 80013fc:	20000e74 	.word	0x20000e74

08001400 <rt_test_005_006_execute.lto_priv.99>:
  binary_semaphore_t bsem;
  msg_t msg;

  /* [5.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 8001400:	2301      	movs	r3, #1

static void rt_test_005_006_teardown(void) {
  test_wait_threads();
}

static void rt_test_005_006_execute(void) {
 8001402:	b5f0      	push	{r4, r5, r6, r7, lr}
  binary_semaphore_t bsem;
  msg_t msg;

  /* [5.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 8001404:	4d4a      	ldr	r5, [pc, #296]	; (8001530 <rt_test_005_006_execute.lto_priv.99+0x130>)

static void rt_test_005_006_teardown(void) {
  test_wait_threads();
}

static void rt_test_005_006_execute(void) {
 8001406:	b085      	sub	sp, #20
  binary_semaphore_t bsem;
  msg_t msg;

  /* [5.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 8001408:	602b      	str	r3, [r5, #0]
 800140a:	2300      	movs	r3, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800140c:	ac01      	add	r4, sp, #4
 800140e:	9401      	str	r4, [sp, #4]
  tqp->prev = (thread_t *)tqp;
 8001410:	6064      	str	r4, [r4, #4]
 8001412:	60a3      	str	r3, [r4, #8]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001414:	b672      	cpsid	i
 */
static inline bool chBSemGetStateI(const binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8001416:	9b03      	ldr	r3, [sp, #12]
  {
    chBSemObjectInit(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8001418:	4e46      	ldr	r6, [pc, #280]	; (8001534 <rt_test_005_006_execute.lto_priv.99+0x134>)
 800141a:	1e58      	subs	r0, r3, #1
 800141c:	4318      	orrs	r0, r3
 800141e:	0fc0      	lsrs	r0, r0, #31
 8001420:	1c31      	adds	r1, r6, #0
 8001422:	f002 fd6d 	bl	8003f00 <_test_assert>
 8001426:	2800      	cmp	r0, #0
 8001428:	d002      	beq.n	8001430 <rt_test_005_006_execute.lto_priv.99+0x30>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800142a:	b662      	cpsie	i
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
}
 800142c:	b005      	add	sp, #20
 800142e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001430:	b662      	cpsie	i
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  }

  /* [5.6.2] Resetting the binary semaphore in "taken" state, the state
     must not change.*/
  test_set_step(2);
 8001432:	2302      	movs	r3, #2
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {

  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 8001434:	1c20      	adds	r0, r4, #0
 8001436:	2100      	movs	r1, #0
 8001438:	602b      	str	r3, [r5, #0]
 800143a:	f7ff faa1 	bl	8000980 <chSemReset>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800143e:	b672      	cpsid	i
 */
static inline bool chBSemGetStateI(const binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8001440:	9b03      	ldr	r3, [sp, #12]
  {
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8001442:	1c31      	adds	r1, r6, #0
 8001444:	1e58      	subs	r0, r3, #1
 8001446:	4318      	orrs	r0, r3
 8001448:	0fc0      	lsrs	r0, r0, #31
 800144a:	f002 fd59 	bl	8003f00 <_test_assert>
 800144e:	2800      	cmp	r0, #0
 8001450:	d1eb      	bne.n	800142a <rt_test_005_006_execute.lto_priv.99+0x2a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001452:	b662      	cpsie	i
  }

  /* [5.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
 8001454:	2303      	movs	r3, #3
 8001456:	602b      	str	r3, [r5, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001458:	4b37      	ldr	r3, [pc, #220]	; (8001538 <rt_test_005_006_execute.lto_priv.99+0x138>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800145a:	4a38      	ldr	r2, [pc, #224]	; (800153c <rt_test_005_006_execute.lto_priv.99+0x13c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800145c:	699b      	ldr	r3, [r3, #24]
 800145e:	4838      	ldr	r0, [pc, #224]	; (8001540 <rt_test_005_006_execute.lto_priv.99+0x140>)
 8001460:	6899      	ldr	r1, [r3, #8]
 8001462:	1c23      	adds	r3, r4, #0
 8001464:	3901      	subs	r1, #1
 8001466:	f003 fd4b 	bl	8004f00 <chThdCreateStatic.constprop.40>
 800146a:	4b36      	ldr	r3, [pc, #216]	; (8001544 <rt_test_005_006_execute.lto_priv.99+0x144>)
 800146c:	6018      	str	r0, [r3, #0]
                                   chThdGetPriorityX()-1, thread4, &bsem);
  }

  /* [5.6.4] Waiting for the binary semaphore to be signaled, the
     semaphore is expected to be taken.*/
  test_set_step(4);
 800146e:	2304      	movs	r3, #4
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->sem);
 8001470:	1c20      	adds	r0, r4, #0
 8001472:	602b      	str	r3, [r5, #0]
 8001474:	f7ff f8ec 	bl	8000650 <chSemWait>
 8001478:	1c07      	adds	r7, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800147a:	b672      	cpsid	i
 */
static inline bool chBSemGetStateI(const binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 800147c:	9b03      	ldr	r3, [sp, #12]
  {
    msg = chBSemWait(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 800147e:	1c31      	adds	r1, r6, #0
 8001480:	1e58      	subs	r0, r3, #1
 8001482:	4318      	orrs	r0, r3
 8001484:	0fc0      	lsrs	r0, r0, #31
 8001486:	f002 fd3b 	bl	8003f00 <_test_assert>
 800148a:	2800      	cmp	r0, #0
 800148c:	d1cd      	bne.n	800142a <rt_test_005_006_execute.lto_priv.99+0x2a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800148e:	b662      	cpsie	i
    test_assert(msg == MSG_OK, "unexpected message");
 8001490:	4278      	negs	r0, r7
 8001492:	4178      	adcs	r0, r7
 8001494:	492c      	ldr	r1, [pc, #176]	; (8001548 <rt_test_005_006_execute.lto_priv.99+0x148>)
 8001496:	b2c0      	uxtb	r0, r0
 8001498:	f002 fd32 	bl	8003f00 <_test_assert>
 800149c:	2800      	cmp	r0, #0
 800149e:	d1c5      	bne.n	800142c <rt_test_005_006_execute.lto_priv.99+0x2c>
  }

  /* [5.6.5] Signaling the binary semaphore, checking the binary
     semaphore state to be "not taken" and the underlying counter
     semaphore counter to be one.*/
  test_set_step(5);
 80014a0:	2305      	movs	r3, #5
 80014a2:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80014a4:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 80014a6:	68a3      	ldr	r3, [r4, #8]
 80014a8:	2b00      	cmp	r3, #0
 80014aa:	dd39      	ble.n	8001520 <rt_test_005_006_execute.lto_priv.99+0x120>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80014ac:	f7ff f830 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80014b0:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80014b2:	b672      	cpsid	i
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 80014b4:	9b03      	ldr	r3, [sp, #12]
 80014b6:	4925      	ldr	r1, [pc, #148]	; (800154c <rt_test_005_006_execute.lto_priv.99+0x14c>)
 80014b8:	17d8      	asrs	r0, r3, #31
 80014ba:	1ac0      	subs	r0, r0, r3
 80014bc:	0fc0      	lsrs	r0, r0, #31
 80014be:	f002 fd1f 	bl	8003f00 <_test_assert>
 80014c2:	2800      	cmp	r0, #0
 80014c4:	d1b1      	bne.n	800142a <rt_test_005_006_execute.lto_priv.99+0x2a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80014c6:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80014c8:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 80014ca:	9b03      	ldr	r3, [sp, #12]
 80014cc:	4e20      	ldr	r6, [pc, #128]	; (8001550 <rt_test_005_006_execute.lto_priv.99+0x150>)
 80014ce:	1e58      	subs	r0, r3, #1
 80014d0:	4242      	negs	r2, r0
 80014d2:	4142      	adcs	r2, r0
 80014d4:	1c31      	adds	r1, r6, #0
 80014d6:	b2d0      	uxtb	r0, r2
 80014d8:	f002 fd12 	bl	8003f00 <_test_assert>
 80014dc:	2800      	cmp	r0, #0
 80014de:	d1a4      	bne.n	800142a <rt_test_005_006_execute.lto_priv.99+0x2a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80014e0:	b662      	cpsie	i
  }

  /* [5.6.6] Signaling the binary semaphore again, the internal state
     must not change from "not taken".*/
  test_set_step(6);
 80014e2:	2306      	movs	r3, #6
 80014e4:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80014e6:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 80014e8:	68a3      	ldr	r3, [r4, #8]
 80014ea:	2b00      	cmp	r3, #0
 80014ec:	dd1c      	ble.n	8001528 <rt_test_005_006_execute.lto_priv.99+0x128>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80014ee:	f7ff f80f 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80014f2:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80014f4:	b672      	cpsid	i
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 80014f6:	9b03      	ldr	r3, [sp, #12]
 80014f8:	4916      	ldr	r1, [pc, #88]	; (8001554 <rt_test_005_006_execute.lto_priv.99+0x154>)
 80014fa:	17d8      	asrs	r0, r3, #31
 80014fc:	1ac0      	subs	r0, r0, r3
 80014fe:	0fc0      	lsrs	r0, r0, #31
 8001500:	f002 fcfe 	bl	8003f00 <_test_assert>
 8001504:	2800      	cmp	r0, #0
 8001506:	d000      	beq.n	800150a <rt_test_005_006_execute.lto_priv.99+0x10a>
 8001508:	e78f      	b.n	800142a <rt_test_005_006_execute.lto_priv.99+0x2a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800150a:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800150c:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 800150e:	9b03      	ldr	r3, [sp, #12]
 8001510:	1c31      	adds	r1, r6, #0
 8001512:	1e58      	subs	r0, r3, #1
 8001514:	4242      	negs	r2, r0
 8001516:	4142      	adcs	r2, r0
 8001518:	b2d0      	uxtb	r0, r2
 800151a:	f002 fcf1 	bl	8003f00 <_test_assert>
 800151e:	e784      	b.n	800142a <rt_test_005_006_execute.lto_priv.99+0x2a>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 8001520:	1c20      	adds	r0, r4, #0
 8001522:	f7ff fa15 	bl	8000950 <chSemSignalI>
 8001526:	e7c1      	b.n	80014ac <rt_test_005_006_execute.lto_priv.99+0xac>
 8001528:	1c20      	adds	r0, r4, #0
 800152a:	f7ff fa11 	bl	8000950 <chSemSignalI>
 800152e:	e7de      	b.n	80014ee <rt_test_005_006_execute.lto_priv.99+0xee>
 8001530:	20000d64 	.word	0x20000d64
 8001534:	080054ec 	.word	0x080054ec
 8001538:	20000e84 	.word	0x20000e84
 800153c:	08001561 	.word	0x08001561
 8001540:	200006e8 	.word	0x200006e8
 8001544:	20000d68 	.word	0x20000d68
 8001548:	080054f8 	.word	0x080054f8
 800154c:	0800550c 	.word	0x0800550c
 8001550:	08005518 	.word	0x08005518
 8001554:	080054f0 	.word	0x080054f0
 8001558:	46c0      	nop			; (mov r8, r8)
 800155a:	46c0      	nop			; (mov r8, r8)
 800155c:	46c0      	nop			; (mov r8, r8)
 800155e:	46c0      	nop			; (mov r8, r8)

08001560 <thread4>:
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static THD_FUNCTION(thread4, p) {
 8001560:	b508      	push	{r3, lr}
 8001562:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 8001564:	6883      	ldr	r3, [r0, #8]
 8001566:	2b00      	cmp	r3, #0
 8001568:	dd03      	ble.n	8001572 <thread4+0x12>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 800156a:	f7fe ffd1 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800156e:	b662      	cpsie	i

  chBSemSignal((binary_semaphore_t *)p);
}
 8001570:	bd08      	pop	{r3, pc}
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 8001572:	f7ff f9ed 	bl	8000950 <chSemSignalI>
 8001576:	e7f8      	b.n	800156a <thread4+0xa>
 8001578:	46c0      	nop			; (mov r8, r8)
 800157a:	46c0      	nop			; (mov r8, r8)
 800157c:	46c0      	nop			; (mov r8, r8)
 800157e:	46c0      	nop			; (mov r8, r8)

08001580 <rt_test_005_006_teardown.lto_priv.98>:
 * - [5.6.6] Signaling the binary semaphore again, the internal state
 *   must not change from "not taken".
 * .
 */

static void rt_test_005_006_teardown(void) {
 8001580:	b508      	push	{r3, lr}
  test_wait_threads();
 8001582:	f002 f9bd 	bl	8003900 <test_wait_threads>
}
 8001586:	bd08      	pop	{r3, pc}
 8001588:	46c0      	nop			; (mov r8, r8)
 800158a:	46c0      	nop			; (mov r8, r8)
 800158c:	46c0      	nop			; (mov r8, r8)
 800158e:	46c0      	nop			; (mov r8, r8)

08001590 <rt_test_005_005_teardown.lto_priv.96>:

static void rt_test_005_005_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void rt_test_005_005_teardown(void) {
 8001590:	b508      	push	{r3, lr}
  test_wait_threads();
 8001592:	f002 f9b5 	bl	8003900 <test_wait_threads>
}
 8001596:	bd08      	pop	{r3, pc}
 8001598:	46c0      	nop			; (mov r8, r8)
 800159a:	46c0      	nop			; (mov r8, r8)
 800159c:	46c0      	nop			; (mov r8, r8)
 800159e:	46c0      	nop			; (mov r8, r8)

080015a0 <rt_test_005_005_execute.lto_priv.97>:

static void rt_test_005_005_execute(void) {
 80015a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [5.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 80015a2:	2301      	movs	r3, #1
 80015a4:	4d1e      	ldr	r5, [pc, #120]	; (8001620 <rt_test_005_005_execute.lto_priv.97+0x80>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80015a6:	4a1f      	ldr	r2, [pc, #124]	; (8001624 <rt_test_005_005_execute.lto_priv.97+0x84>)

static void rt_test_005_005_execute(void) {

  /* [5.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 80015a8:	602b      	str	r3, [r5, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80015aa:	4b1f      	ldr	r3, [pc, #124]	; (8001628 <rt_test_005_005_execute.lto_priv.97+0x88>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80015ac:	481f      	ldr	r0, [pc, #124]	; (800162c <rt_test_005_005_execute.lto_priv.97+0x8c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80015ae:	699b      	ldr	r3, [r3, #24]
 80015b0:	6899      	ldr	r1, [r3, #8]
 80015b2:	2300      	movs	r3, #0
 80015b4:	3101      	adds	r1, #1
 80015b6:	f003 fca3 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80015ba:	4b1d      	ldr	r3, [pc, #116]	; (8001630 <rt_test_005_005_execute.lto_priv.97+0x90>)
 80015bc:	6018      	str	r0, [r3, #0]
  }

  /* [5.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
 80015be:	2302      	movs	r3, #2
 80015c0:	602b      	str	r3, [r5, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 80015c2:	f003 fd0d 	bl	8004fe0 <chSemSignalWait.constprop.33>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 80015c6:	4c1b      	ldr	r4, [pc, #108]	; (8001634 <rt_test_005_005_execute.lto_priv.97+0x94>)
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80015c8:	4e1b      	ldr	r6, [pc, #108]	; (8001638 <rt_test_005_005_execute.lto_priv.97+0x98>)
 80015ca:	6823      	ldr	r3, [r4, #0]
 80015cc:	1c31      	adds	r1, r6, #0
 80015ce:	1b18      	subs	r0, r3, r4
 80015d0:	4242      	negs	r2, r0
 80015d2:	4142      	adcs	r2, r0
 80015d4:	b2d0      	uxtb	r0, r2
 80015d6:	f002 fc93 	bl	8003f00 <_test_assert>
 80015da:	2800      	cmp	r0, #0
 80015dc:	d000      	beq.n	80015e0 <rt_test_005_005_execute.lto_priv.97+0x40>
  {
    chSemSignalWait(&sem1, &sem1);
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
  }
}
 80015de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     value must be one on exit.*/
  test_set_step(2);
  {
    chSemSignalWait(&sem1, &sem1);
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
 80015e0:	68a0      	ldr	r0, [r4, #8]
 80015e2:	4f16      	ldr	r7, [pc, #88]	; (800163c <rt_test_005_005_execute.lto_priv.97+0x9c>)
 80015e4:	4243      	negs	r3, r0
 80015e6:	4158      	adcs	r0, r3
 80015e8:	1c39      	adds	r1, r7, #0
 80015ea:	b2c0      	uxtb	r0, r0
 80015ec:	f002 fc88 	bl	8003f00 <_test_assert>
 80015f0:	2800      	cmp	r0, #0
 80015f2:	d1f4      	bne.n	80015de <rt_test_005_005_execute.lto_priv.97+0x3e>
  }

  /* [5.5.3] The function chSemSignalWait() is invoked again by
     specifying the same semaphore for the wait and signal phases. The
     counter value must be one on exit.*/
  test_set_step(3);
 80015f4:	2303      	movs	r3, #3
 80015f6:	602b      	str	r3, [r5, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 80015f8:	f003 fcf2 	bl	8004fe0 <chSemSignalWait.constprop.33>
 80015fc:	6823      	ldr	r3, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80015fe:	1c31      	adds	r1, r6, #0
 8001600:	1b18      	subs	r0, r3, r4
 8001602:	4242      	negs	r2, r0
 8001604:	4142      	adcs	r2, r0
 8001606:	b2d0      	uxtb	r0, r2
 8001608:	f002 fc7a 	bl	8003f00 <_test_assert>
 800160c:	2800      	cmp	r0, #0
 800160e:	d1e6      	bne.n	80015de <rt_test_005_005_execute.lto_priv.97+0x3e>
    test_assert(sem1.cnt == 0, "counter not zero");
 8001610:	68a3      	ldr	r3, [r4, #8]
 8001612:	1c39      	adds	r1, r7, #0
 8001614:	4258      	negs	r0, r3
 8001616:	4158      	adcs	r0, r3
 8001618:	b2c0      	uxtb	r0, r0
 800161a:	f002 fc71 	bl	8003f00 <_test_assert>
 800161e:	e7de      	b.n	80015de <rt_test_005_005_execute.lto_priv.97+0x3e>
 8001620:	20000d64 	.word	0x20000d64
 8001624:	08001641 	.word	0x08001641
 8001628:	20000e84 	.word	0x20000e84
 800162c:	200006e8 	.word	0x200006e8
 8001630:	20000d68 	.word	0x20000d68
 8001634:	20000e74 	.word	0x20000e74
 8001638:	0800552c 	.word	0x0800552c
 800163c:	0800553c 	.word	0x0800553c

08001640 <thread3>:
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
  chSysUnlock();
}

static THD_FUNCTION(thread3, p) {
 8001640:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 8001642:	4c04      	ldr	r4, [pc, #16]	; (8001654 <thread3+0x14>)
 8001644:	1c20      	adds	r0, r4, #0
 8001646:	f7ff f803 	bl	8000650 <chSemWait>
  chSemSignal(&sem1);
 800164a:	1c20      	adds	r0, r4, #0
 800164c:	f7fe ffd0 	bl	80005f0 <chSemSignal>
}
 8001650:	bd10      	pop	{r4, pc}
 8001652:	46c0      	nop			; (mov r8, r8)
 8001654:	20000e74 	.word	0x20000e74
 8001658:	46c0      	nop			; (mov r8, r8)
 800165a:	46c0      	nop			; (mov r8, r8)
 800165c:	46c0      	nop			; (mov r8, r8)
 800165e:	46c0      	nop			; (mov r8, r8)

08001660 <rt_test_005_001_execute.lto_priv.88>:

static void rt_test_005_001_teardown(void) {
  chSemReset(&sem1, 0);
}

static void rt_test_005_001_execute(void) {
 8001660:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [5.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 8001662:	2301      	movs	r3, #1
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 8001664:	4c1e      	ldr	r4, [pc, #120]	; (80016e0 <rt_test_005_001_execute.lto_priv.88+0x80>)

static void rt_test_005_001_execute(void) {

  /* [5.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 8001666:	4f1f      	ldr	r7, [pc, #124]	; (80016e4 <rt_test_005_001_execute.lto_priv.88+0x84>)
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 8001668:	1c20      	adds	r0, r4, #0

static void rt_test_005_001_execute(void) {

  /* [5.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 800166a:	603b      	str	r3, [r7, #0]
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 800166c:	f7fe fff0 	bl	8000650 <chSemWait>
 8001670:	1c05      	adds	r5, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001672:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 8001674:	68a0      	ldr	r0, [r4, #8]
 8001676:	4e1c      	ldr	r6, [pc, #112]	; (80016e8 <rt_test_005_001_execute.lto_priv.88+0x88>)
 8001678:	4243      	negs	r3, r0
 800167a:	4158      	adcs	r0, r3
 800167c:	1c31      	adds	r1, r6, #0
 800167e:	b2c0      	uxtb	r0, r0
 8001680:	f002 fc3e 	bl	8003f00 <_test_assert>
 8001684:	2800      	cmp	r0, #0
 8001686:	d001      	beq.n	800168c <rt_test_005_001_execute.lto_priv.88+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001688:	b662      	cpsie	i
  test_set_step(3);
  {
    chSemReset(&sem1, 2);
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
  }
}
 800168a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800168c:	b662      	cpsie	i
  {
    msg_t msg;

    msg = chSemWait(&sem1);
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
    test_assert(MSG_OK == msg, "wrong returned message");
 800168e:	4268      	negs	r0, r5
 8001690:	4168      	adcs	r0, r5
 8001692:	4916      	ldr	r1, [pc, #88]	; (80016ec <rt_test_005_001_execute.lto_priv.88+0x8c>)
 8001694:	b2c0      	uxtb	r0, r0
 8001696:	f002 fc33 	bl	8003f00 <_test_assert>
 800169a:	2800      	cmp	r0, #0
 800169c:	d1f5      	bne.n	800168a <rt_test_005_001_execute.lto_priv.88+0x2a>
  }

  /* [5.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 800169e:	2302      	movs	r3, #2
  {
    chSemSignal(&sem1);
 80016a0:	1c20      	adds	r0, r4, #0
    test_assert(MSG_OK == msg, "wrong returned message");
  }

  /* [5.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 80016a2:	603b      	str	r3, [r7, #0]
  {
    chSemSignal(&sem1);
 80016a4:	f7fe ffa4 	bl	80005f0 <chSemSignal>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80016a8:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 80016aa:	68a3      	ldr	r3, [r4, #8]
 80016ac:	1c31      	adds	r1, r6, #0
 80016ae:	1e58      	subs	r0, r3, #1
 80016b0:	4242      	negs	r2, r0
 80016b2:	4142      	adcs	r2, r0
 80016b4:	b2d0      	uxtb	r0, r2
 80016b6:	f002 fc23 	bl	8003f00 <_test_assert>
 80016ba:	2800      	cmp	r0, #0
 80016bc:	d1e4      	bne.n	8001688 <rt_test_005_001_execute.lto_priv.88+0x28>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80016be:	b662      	cpsie	i
  }

  /* [5.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 80016c0:	2303      	movs	r3, #3
  {
    chSemReset(&sem1, 2);
 80016c2:	1c20      	adds	r0, r4, #0
 80016c4:	2102      	movs	r1, #2
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
  }

  /* [5.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 80016c6:	603b      	str	r3, [r7, #0]
  {
    chSemReset(&sem1, 2);
 80016c8:	f7ff f95a 	bl	8000980 <chSemReset>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80016cc:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 80016ce:	68a0      	ldr	r0, [r4, #8]
 80016d0:	1c31      	adds	r1, r6, #0
 80016d2:	3802      	subs	r0, #2
 80016d4:	4242      	negs	r2, r0
 80016d6:	4142      	adcs	r2, r0
 80016d8:	b2d0      	uxtb	r0, r2
 80016da:	f002 fc11 	bl	8003f00 <_test_assert>
 80016de:	e7d3      	b.n	8001688 <rt_test_005_001_execute.lto_priv.88+0x28>
 80016e0:	20000e74 	.word	0x20000e74
 80016e4:	20000d64 	.word	0x20000d64
 80016e8:	08005550 	.word	0x08005550
 80016ec:	08005564 	.word	0x08005564

080016f0 <thread1.lto_priv.152>:

#include "ch.h"

static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {
 80016f0:	b510      	push	{r4, lr}
 80016f2:	1c04      	adds	r4, r0, #0

  chSemWait(&sem1);
 80016f4:	4803      	ldr	r0, [pc, #12]	; (8001704 <thread1.lto_priv.152+0x14>)
 80016f6:	f7fe ffab 	bl	8000650 <chSemWait>
  test_emit_token(*(char *)p);
 80016fa:	7820      	ldrb	r0, [r4, #0]
 80016fc:	f002 f930 	bl	8003960 <test_emit_token>
}
 8001700:	bd10      	pop	{r4, pc}
 8001702:	46c0      	nop			; (mov r8, r8)
 8001704:	20000e74 	.word	0x20000e74
 8001708:	46c0      	nop			; (mov r8, r8)
 800170a:	46c0      	nop			; (mov r8, r8)
 800170c:	46c0      	nop			; (mov r8, r8)
 800170e:	46c0      	nop			; (mov r8, r8)

08001710 <thread>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {
 8001710:	b508      	push	{r3, lr}

  test_emit_token(*(char *)p);
 8001712:	7800      	ldrb	r0, [r0, #0]
 8001714:	f002 f924 	bl	8003960 <test_emit_token>
}
 8001718:	bd08      	pop	{r3, pc}
 800171a:	46c0      	nop			; (mov r8, r8)
 800171c:	46c0      	nop			; (mov r8, r8)
 800171e:	46c0      	nop			; (mov r8, r8)

08001720 <rt_test_005_002_execute.lto_priv.90>:
static void rt_test_005_002_execute(void) {

  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 8001720:	4b2d      	ldr	r3, [pc, #180]	; (80017d8 <rt_test_005_002_execute.lto_priv.90+0xb8>)

static void rt_test_005_002_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void rt_test_005_002_execute(void) {
 8001722:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001724:	4647      	mov	r7, r8

  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 8001726:	4698      	mov	r8, r3
 8001728:	2301      	movs	r3, #1
 800172a:	4642      	mov	r2, r8

static void rt_test_005_002_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void rt_test_005_002_execute(void) {
 800172c:	b480      	push	{r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800172e:	4f2b      	ldr	r7, [pc, #172]	; (80017dc <rt_test_005_002_execute.lto_priv.90+0xbc>)

  /* [5.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 8001730:	6013      	str	r3, [r2, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001732:	69bb      	ldr	r3, [r7, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8001734:	4e2a      	ldr	r6, [pc, #168]	; (80017e0 <rt_test_005_002_execute.lto_priv.90+0xc0>)
 8001736:	4c2b      	ldr	r4, [pc, #172]	; (80017e4 <rt_test_005_002_execute.lto_priv.90+0xc4>)
 8001738:	6899      	ldr	r1, [r3, #8]
 800173a:	1c32      	adds	r2, r6, #0
 800173c:	3105      	adds	r1, #5
 800173e:	1c20      	adds	r0, r4, #0
 8001740:	4b29      	ldr	r3, [pc, #164]	; (80017e8 <rt_test_005_002_execute.lto_priv.90+0xc8>)
 8001742:	f003 fbdd 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8001746:	4d29      	ldr	r5, [pc, #164]	; (80017ec <rt_test_005_002_execute.lto_priv.90+0xcc>)
 8001748:	69bb      	ldr	r3, [r7, #24]
 800174a:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800174c:	1c20      	adds	r0, r4, #0
 800174e:	6899      	ldr	r1, [r3, #8]
 8001750:	3049      	adds	r0, #73	; 0x49
 8001752:	1c32      	adds	r2, r6, #0
 8001754:	3101      	adds	r1, #1
 8001756:	4b26      	ldr	r3, [pc, #152]	; (80017f0 <rt_test_005_002_execute.lto_priv.90+0xd0>)
 8001758:	30ff      	adds	r0, #255	; 0xff
 800175a:	f003 fbd1 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800175e:	23a4      	movs	r3, #164	; 0xa4
 8001760:	009b      	lsls	r3, r3, #2
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8001762:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8001764:	18e0      	adds	r0, r4, r3
 8001766:	69bb      	ldr	r3, [r7, #24]
 8001768:	1c32      	adds	r2, r6, #0
 800176a:	6899      	ldr	r1, [r3, #8]
 800176c:	4b21      	ldr	r3, [pc, #132]	; (80017f4 <rt_test_005_002_execute.lto_priv.90+0xd4>)
 800176e:	3103      	adds	r1, #3
 8001770:	f003 fbc6 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8001774:	23f6      	movs	r3, #246	; 0xf6
 8001776:	009b      	lsls	r3, r3, #2
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8001778:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 800177a:	18e0      	adds	r0, r4, r3
 800177c:	69bb      	ldr	r3, [r7, #24]
 800177e:	1c32      	adds	r2, r6, #0
 8001780:	6899      	ldr	r1, [r3, #8]
 8001782:	4b1d      	ldr	r3, [pc, #116]	; (80017f8 <rt_test_005_002_execute.lto_priv.90+0xd8>)
 8001784:	3104      	adds	r1, #4
 8001786:	f003 fbbb 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 800178a:	23a4      	movs	r3, #164	; 0xa4
 800178c:	00db      	lsls	r3, r3, #3
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 800178e:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8001790:	18e0      	adds	r0, r4, r3
 8001792:	69bb      	ldr	r3, [r7, #24]
 8001794:	1c32      	adds	r2, r6, #0
 8001796:	6899      	ldr	r1, [r3, #8]
 8001798:	4b18      	ldr	r3, [pc, #96]	; (80017fc <rt_test_005_002_execute.lto_priv.90+0xdc>)
 800179a:	3102      	adds	r1, #2
 800179c:	f003 fbb0 	bl	8004f00 <chThdCreateStatic.constprop.40>
  }

  /* [5.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 80017a0:	4642      	mov	r2, r8
 80017a2:	2302      	movs	r3, #2
  {
    chSemSignal(&sem1);
 80017a4:	4c16      	ldr	r4, [pc, #88]	; (8001800 <rt_test_005_002_execute.lto_priv.90+0xe0>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 80017a6:	6128      	str	r0, [r5, #16]

  /* [5.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
  {
    chSemSignal(&sem1);
 80017a8:	1c20      	adds	r0, r4, #0
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  }

  /* [5.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 80017aa:	6013      	str	r3, [r2, #0]
  {
    chSemSignal(&sem1);
 80017ac:	f7fe ff20 	bl	80005f0 <chSemSignal>
    chSemSignal(&sem1);
 80017b0:	1c20      	adds	r0, r4, #0
 80017b2:	f7fe ff1d 	bl	80005f0 <chSemSignal>
    chSemSignal(&sem1);
 80017b6:	1c20      	adds	r0, r4, #0
 80017b8:	f7fe ff1a 	bl	80005f0 <chSemSignal>
    chSemSignal(&sem1);
 80017bc:	1c20      	adds	r0, r4, #0
 80017be:	f7fe ff17 	bl	80005f0 <chSemSignal>
    chSemSignal(&sem1);
 80017c2:	1c20      	adds	r0, r4, #0
 80017c4:	f7fe ff14 	bl	80005f0 <chSemSignal>
    test_wait_threads();
 80017c8:	f002 f89a 	bl	8003900 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
    test_assert_sequence("ADCEB", "invalid sequence");
#else
    test_assert_sequence("ABCDE", "invalid sequence");
 80017cc:	480d      	ldr	r0, [pc, #52]	; (8001804 <rt_test_005_002_execute.lto_priv.90+0xe4>)
 80017ce:	f003 fdaf 	bl	8005330 <_test_assert_sequence.constprop.3>
#endif
  }
}
 80017d2:	bc04      	pop	{r2}
 80017d4:	4690      	mov	r8, r2
 80017d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80017d8:	20000d64 	.word	0x20000d64
 80017dc:	20000e84 	.word	0x20000e84
 80017e0:	080016f1 	.word	0x080016f1
 80017e4:	200006e8 	.word	0x200006e8
 80017e8:	0800557c 	.word	0x0800557c
 80017ec:	20000d68 	.word	0x20000d68
 80017f0:	08005580 	.word	0x08005580
 80017f4:	08005584 	.word	0x08005584
 80017f8:	08005588 	.word	0x08005588
 80017fc:	08005590 	.word	0x08005590
 8001800:	20000e74 	.word	0x20000e74
 8001804:	0800558c 	.word	0x0800558c
 8001808:	46c0      	nop			; (mov r8, r8)
 800180a:	46c0      	nop			; (mov r8, r8)
 800180c:	46c0      	nop			; (mov r8, r8)
 800180e:	46c0      	nop			; (mov r8, r8)

08001810 <rt_test_003_002_execute.lto_priv.81>:
 * - [3.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void rt_test_003_002_execute(void) {
 8001810:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 8001812:	4b5e      	ldr	r3, [pc, #376]	; (800198c <rt_test_003_002_execute.lto_priv.81+0x17c>)
 * - [3.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void rt_test_003_002_execute(void) {
 8001814:	465f      	mov	r7, fp

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 8001816:	469b      	mov	fp, r3
 * - [3.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void rt_test_003_002_execute(void) {
 8001818:	4656      	mov	r6, sl
 800181a:	464d      	mov	r5, r9
 800181c:	4644      	mov	r4, r8

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 800181e:	2301      	movs	r3, #1
 8001820:	465a      	mov	r2, fp
 * - [3.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void rt_test_003_002_execute(void) {
 8001822:	b4f0      	push	{r4, r5, r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001824:	4e5a      	ldr	r6, [pc, #360]	; (8001990 <rt_test_003_002_execute.lto_priv.81+0x180>)

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 8001826:	6013      	str	r3, [r2, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001828:	69b3      	ldr	r3, [r6, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800182a:	4d5a      	ldr	r5, [pc, #360]	; (8001994 <rt_test_003_002_execute.lto_priv.81+0x184>)
 800182c:	4f5a      	ldr	r7, [pc, #360]	; (8001998 <rt_test_003_002_execute.lto_priv.81+0x188>)
 800182e:	6899      	ldr	r1, [r3, #8]
 8001830:	1c2a      	adds	r2, r5, #0
 8001832:	3905      	subs	r1, #5
 8001834:	4b59      	ldr	r3, [pc, #356]	; (800199c <rt_test_003_002_execute.lto_priv.81+0x18c>)
 8001836:	1c38      	adds	r0, r7, #0
 8001838:	f003 fb62 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800183c:	23a4      	movs	r3, #164	; 0xa4
 800183e:	005b      	lsls	r3, r3, #1
 8001840:	469a      	mov	sl, r3
 8001842:	69b3      	ldr	r3, [r6, #24]

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8001844:	4c56      	ldr	r4, [pc, #344]	; (80019a0 <rt_test_003_002_execute.lto_priv.81+0x190>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8001846:	6899      	ldr	r1, [r3, #8]
 8001848:	44ba      	add	sl, r7

  /* [3.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800184a:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800184c:	3904      	subs	r1, #4
 800184e:	1c2a      	adds	r2, r5, #0
 8001850:	4b54      	ldr	r3, [pc, #336]	; (80019a4 <rt_test_003_002_execute.lto_priv.81+0x194>)
 8001852:	4650      	mov	r0, sl
 8001854:	f003 fb54 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8001858:	69b3      	ldr	r3, [r6, #24]
 800185a:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800185c:	6899      	ldr	r1, [r3, #8]
 800185e:	1c2a      	adds	r2, r5, #0
 8001860:	3903      	subs	r1, #3
 8001862:	4b51      	ldr	r3, [pc, #324]	; (80019a8 <rt_test_003_002_execute.lto_priv.81+0x198>)
 8001864:	4851      	ldr	r0, [pc, #324]	; (80019ac <rt_test_003_002_execute.lto_priv.81+0x19c>)
 8001866:	f003 fb4b 	bl	8004f00 <chThdCreateStatic.constprop.40>
 800186a:	69b3      	ldr	r3, [r6, #24]
 800186c:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800186e:	6899      	ldr	r1, [r3, #8]
 8001870:	1c2a      	adds	r2, r5, #0
 8001872:	3902      	subs	r1, #2
 8001874:	4b4e      	ldr	r3, [pc, #312]	; (80019b0 <rt_test_003_002_execute.lto_priv.81+0x1a0>)
 8001876:	484f      	ldr	r0, [pc, #316]	; (80019b4 <rt_test_003_002_execute.lto_priv.81+0x1a4>)
 8001878:	f003 fb42 	bl	8004f00 <chThdCreateStatic.constprop.40>
 800187c:	69b3      	ldr	r3, [r6, #24]
 800187e:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8001880:	6899      	ldr	r1, [r3, #8]
 8001882:	4b4d      	ldr	r3, [pc, #308]	; (80019b8 <rt_test_003_002_execute.lto_priv.81+0x1a8>)
 8001884:	3901      	subs	r1, #1
 8001886:	1c2a      	adds	r2, r5, #0
 8001888:	484c      	ldr	r0, [pc, #304]	; (80019bc <rt_test_003_002_execute.lto_priv.81+0x1ac>)
 800188a:	4699      	mov	r9, r3
 800188c:	f003 fb38 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8001890:	6120      	str	r0, [r4, #16]
    test_wait_threads();
 8001892:	f002 f835 	bl	8003900 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8001896:	4b4a      	ldr	r3, [pc, #296]	; (80019c0 <rt_test_003_002_execute.lto_priv.81+0x1b0>)
 8001898:	1c18      	adds	r0, r3, #0
 800189a:	4698      	mov	r8, r3
 800189c:	f003 fd48 	bl	8005330 <_test_assert_sequence.constprop.3>
 80018a0:	2800      	cmp	r0, #0
 80018a2:	d005      	beq.n	80018b0 <rt_test_003_002_execute.lto_priv.81+0xa0>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
  }
}
 80018a4:	bc3c      	pop	{r2, r3, r4, r5}
 80018a6:	4690      	mov	r8, r2
 80018a8:	4699      	mov	r9, r3
 80018aa:	46a2      	mov	sl, r4
 80018ac:	46ab      	mov	fp, r5
 80018ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert_sequence("ABCDE", "invalid sequence");
  }

  /* [3.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
 80018b0:	2302      	movs	r3, #2
 80018b2:	465a      	mov	r2, fp
 80018b4:	6013      	str	r3, [r2, #0]
 80018b6:	69b3      	ldr	r3, [r6, #24]
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80018b8:	1c2a      	adds	r2, r5, #0
 80018ba:	6899      	ldr	r1, [r3, #8]
 80018bc:	483f      	ldr	r0, [pc, #252]	; (80019bc <rt_test_003_002_execute.lto_priv.81+0x1ac>)
 80018be:	3901      	subs	r1, #1
 80018c0:	464b      	mov	r3, r9
 80018c2:	f003 fb1d 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80018c6:	69b3      	ldr	r3, [r6, #24]
 80018c8:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80018ca:	6899      	ldr	r1, [r3, #8]
 80018cc:	1c2a      	adds	r2, r5, #0
 80018ce:	3902      	subs	r1, #2
 80018d0:	4b37      	ldr	r3, [pc, #220]	; (80019b0 <rt_test_003_002_execute.lto_priv.81+0x1a0>)
 80018d2:	4838      	ldr	r0, [pc, #224]	; (80019b4 <rt_test_003_002_execute.lto_priv.81+0x1a4>)
 80018d4:	f003 fb14 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80018d8:	69b3      	ldr	r3, [r6, #24]
 80018da:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80018dc:	6899      	ldr	r1, [r3, #8]
 80018de:	1c2a      	adds	r2, r5, #0
 80018e0:	3903      	subs	r1, #3
 80018e2:	4b31      	ldr	r3, [pc, #196]	; (80019a8 <rt_test_003_002_execute.lto_priv.81+0x198>)
 80018e4:	4831      	ldr	r0, [pc, #196]	; (80019ac <rt_test_003_002_execute.lto_priv.81+0x19c>)
 80018e6:	f003 fb0b 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80018ea:	69b3      	ldr	r3, [r6, #24]
 80018ec:	60a0      	str	r0, [r4, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80018ee:	6899      	ldr	r1, [r3, #8]
 80018f0:	1c2a      	adds	r2, r5, #0
 80018f2:	3904      	subs	r1, #4
 80018f4:	4b2b      	ldr	r3, [pc, #172]	; (80019a4 <rt_test_003_002_execute.lto_priv.81+0x194>)
 80018f6:	4650      	mov	r0, sl
 80018f8:	f003 fb02 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80018fc:	69b3      	ldr	r3, [r6, #24]
 80018fe:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8001900:	6899      	ldr	r1, [r3, #8]
 8001902:	1c2a      	adds	r2, r5, #0
 8001904:	3905      	subs	r1, #5
 8001906:	4b25      	ldr	r3, [pc, #148]	; (800199c <rt_test_003_002_execute.lto_priv.81+0x18c>)
 8001908:	1c38      	adds	r0, r7, #0
 800190a:	f003 faf9 	bl	8004f00 <chThdCreateStatic.constprop.40>
 800190e:	6020      	str	r0, [r4, #0]
    test_wait_threads();
 8001910:	f001 fff6 	bl	8003900 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8001914:	4640      	mov	r0, r8
 8001916:	f003 fd0b 	bl	8005330 <_test_assert_sequence.constprop.3>
 800191a:	2800      	cmp	r0, #0
 800191c:	d1c2      	bne.n	80018a4 <rt_test_003_002_execute.lto_priv.81+0x94>
  }

  /* [3.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
 800191e:	465a      	mov	r2, fp
 8001920:	2303      	movs	r3, #3
 8001922:	6013      	str	r3, [r2, #0]
 8001924:	69b3      	ldr	r3, [r6, #24]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8001926:	1c2a      	adds	r2, r5, #0
 8001928:	6899      	ldr	r1, [r3, #8]
 800192a:	4650      	mov	r0, sl
 800192c:	3904      	subs	r1, #4
 800192e:	4b1d      	ldr	r3, [pc, #116]	; (80019a4 <rt_test_003_002_execute.lto_priv.81+0x194>)
 8001930:	f003 fae6 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8001934:	69b3      	ldr	r3, [r6, #24]
 8001936:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8001938:	6899      	ldr	r1, [r3, #8]
 800193a:	1c2a      	adds	r2, r5, #0
 800193c:	3905      	subs	r1, #5
 800193e:	1c38      	adds	r0, r7, #0
 8001940:	4b16      	ldr	r3, [pc, #88]	; (800199c <rt_test_003_002_execute.lto_priv.81+0x18c>)
 8001942:	f003 fadd 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8001946:	69b3      	ldr	r3, [r6, #24]
 8001948:	6020      	str	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800194a:	6899      	ldr	r1, [r3, #8]
 800194c:	1c2a      	adds	r2, r5, #0
 800194e:	464b      	mov	r3, r9
 8001950:	3901      	subs	r1, #1
 8001952:	481a      	ldr	r0, [pc, #104]	; (80019bc <rt_test_003_002_execute.lto_priv.81+0x1ac>)
 8001954:	f003 fad4 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8001958:	69b3      	ldr	r3, [r6, #24]
 800195a:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800195c:	6899      	ldr	r1, [r3, #8]
 800195e:	1c2a      	adds	r2, r5, #0
 8001960:	3902      	subs	r1, #2
 8001962:	4b13      	ldr	r3, [pc, #76]	; (80019b0 <rt_test_003_002_execute.lto_priv.81+0x1a0>)
 8001964:	4813      	ldr	r0, [pc, #76]	; (80019b4 <rt_test_003_002_execute.lto_priv.81+0x1a4>)
 8001966:	f003 facb 	bl	8004f00 <chThdCreateStatic.constprop.40>
 800196a:	69b3      	ldr	r3, [r6, #24]
 800196c:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800196e:	6899      	ldr	r1, [r3, #8]
 8001970:	1c2a      	adds	r2, r5, #0
 8001972:	3903      	subs	r1, #3
 8001974:	4b0c      	ldr	r3, [pc, #48]	; (80019a8 <rt_test_003_002_execute.lto_priv.81+0x198>)
 8001976:	480d      	ldr	r0, [pc, #52]	; (80019ac <rt_test_003_002_execute.lto_priv.81+0x19c>)
 8001978:	f003 fac2 	bl	8004f00 <chThdCreateStatic.constprop.40>
 800197c:	60a0      	str	r0, [r4, #8]
    test_wait_threads();
 800197e:	f001 ffbf 	bl	8003900 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8001982:	4640      	mov	r0, r8
 8001984:	f003 fcd4 	bl	8005330 <_test_assert_sequence.constprop.3>
 8001988:	e78c      	b.n	80018a4 <rt_test_003_002_execute.lto_priv.81+0x94>
 800198a:	46c0      	nop			; (mov r8, r8)
 800198c:	20000d64 	.word	0x20000d64
 8001990:	20000e84 	.word	0x20000e84
 8001994:	08001711 	.word	0x08001711
 8001998:	200006e8 	.word	0x200006e8
 800199c:	08005590 	.word	0x08005590
 80019a0:	20000d68 	.word	0x20000d68
 80019a4:	08005588 	.word	0x08005588
 80019a8:	08005584 	.word	0x08005584
 80019ac:	20000978 	.word	0x20000978
 80019b0:	08005580 	.word	0x08005580
 80019b4:	20000ac0 	.word	0x20000ac0
 80019b8:	0800557c 	.word	0x0800557c
 80019bc:	20000c08 	.word	0x20000c08
 80019c0:	0800558c 	.word	0x0800558c
 80019c4:	46c0      	nop			; (mov r8, r8)
 80019c6:	46c0      	nop			; (mov r8, r8)
 80019c8:	46c0      	nop			; (mov r8, r8)
 80019ca:	46c0      	nop			; (mov r8, r8)
 80019cc:	46c0      	nop			; (mov r8, r8)
 80019ce:	46c0      	nop			; (mov r8, r8)

080019d0 <rt_test_005_004_execute.lto_priv.94>:

static void rt_test_005_004_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void rt_test_005_004_execute(void) {
 80019d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [5.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 80019d2:	2301      	movs	r3, #1
 80019d4:	4c1e      	ldr	r4, [pc, #120]	; (8001a50 <rt_test_005_004_execute.lto_priv.94+0x80>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 80019d6:	4e1f      	ldr	r6, [pc, #124]	; (8001a54 <rt_test_005_004_execute.lto_priv.94+0x84>)
}

static void rt_test_005_004_execute(void) {

  /* [5.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 80019d8:	6023      	str	r3, [r4, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80019da:	4b1f      	ldr	r3, [pc, #124]	; (8001a58 <rt_test_005_004_execute.lto_priv.94+0x88>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 80019dc:	4a1f      	ldr	r2, [pc, #124]	; (8001a5c <rt_test_005_004_execute.lto_priv.94+0x8c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80019de:	699b      	ldr	r3, [r3, #24]
 80019e0:	481f      	ldr	r0, [pc, #124]	; (8001a60 <rt_test_005_004_execute.lto_priv.94+0x90>)
 80019e2:	6899      	ldr	r1, [r3, #8]
 80019e4:	1c33      	adds	r3, r6, #0
 80019e6:	3101      	adds	r1, #1
 80019e8:	f003 fa8a 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80019ec:	4b1d      	ldr	r3, [pc, #116]	; (8001a64 <rt_test_005_004_execute.lto_priv.94+0x94>)
 80019ee:	6018      	str	r0, [r3, #0]
  }

  /* [5.4.2] The semaphore counter is increased by two, it is then
     tested to be one, the thread must have completed.*/
  test_set_step(2);
 80019f0:	2302      	movs	r3, #2
 80019f2:	6023      	str	r3, [r4, #0]
 80019f4:	b672      	cpsid	i
 80019f6:	2502      	movs	r5, #2
 80019f8:	4c1b      	ldr	r4, [pc, #108]	; (8001a68 <rt_test_005_004_execute.lto_priv.94+0x98>)
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 80019fa:	2700      	movs	r7, #0
 80019fc:	e002      	b.n	8001a04 <rt_test_005_004_execute.lto_priv.94+0x34>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 80019fe:	2d01      	cmp	r5, #1
 8001a00:	d00e      	beq.n	8001a20 <rt_test_005_004_execute.lto_priv.94+0x50>
 8001a02:	2501      	movs	r5, #1
    if (++sp->cnt <= (cnt_t)0) {
 8001a04:	68a3      	ldr	r3, [r4, #8]
 8001a06:	3301      	adds	r3, #1
 8001a08:	60a3      	str	r3, [r4, #8]
 8001a0a:	2b00      	cmp	r3, #0
 8001a0c:	dcf7      	bgt.n	80019fe <rt_test_005_004_execute.lto_priv.94+0x2e>
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8001a0e:	6820      	ldr	r0, [r4, #0]

  tqp->next             = tp->queue.next;
 8001a10:	6803      	ldr	r3, [r0, #0]
 8001a12:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001a14:	605c      	str	r4, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 8001a16:	f7fe fe3b 	bl	8000690 <chSchReadyI>
 8001a1a:	6247      	str	r7, [r0, #36]	; 0x24
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001a1c:	2d01      	cmp	r5, #1
 8001a1e:	d1f0      	bne.n	8001a02 <rt_test_005_004_execute.lto_priv.94+0x32>
  {
    chSysLock();
    chSemAddCounterI(&sem1, 2);
    chSchRescheduleS();
 8001a20:	f7fe fd76 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001a24:	b662      	cpsie	i
    chSysUnlock();
    test_wait_threads();
 8001a26:	f001 ff6b 	bl	8003900 <test_wait_threads>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001a2a:	b672      	cpsid	i
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 8001a2c:	68a0      	ldr	r0, [r4, #8]
 8001a2e:	490f      	ldr	r1, [pc, #60]	; (8001a6c <rt_test_005_004_execute.lto_priv.94+0x9c>)
 8001a30:	3801      	subs	r0, #1
 8001a32:	4242      	negs	r2, r0
 8001a34:	4142      	adcs	r2, r0
 8001a36:	b2d0      	uxtb	r0, r2
 8001a38:	f002 fa62 	bl	8003f00 <_test_assert>
 8001a3c:	2800      	cmp	r0, #0
 8001a3e:	d001      	beq.n	8001a44 <rt_test_005_004_execute.lto_priv.94+0x74>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001a40:	b662      	cpsie	i
    test_assert_sequence("A", "invalid sequence");
  }
}
 8001a42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001a44:	b662      	cpsie	i
    chSemAddCounterI(&sem1, 2);
    chSchRescheduleS();
    chSysUnlock();
    test_wait_threads();
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
    test_assert_sequence("A", "invalid sequence");
 8001a46:	1c30      	adds	r0, r6, #0
 8001a48:	f003 fc72 	bl	8005330 <_test_assert_sequence.constprop.3>
 8001a4c:	e7f9      	b.n	8001a42 <rt_test_005_004_execute.lto_priv.94+0x72>
 8001a4e:	46c0      	nop			; (mov r8, r8)
 8001a50:	20000d64 	.word	0x20000d64
 8001a54:	0800557c 	.word	0x0800557c
 8001a58:	20000e84 	.word	0x20000e84
 8001a5c:	080016f1 	.word	0x080016f1
 8001a60:	200006e8 	.word	0x200006e8
 8001a64:	20000d68 	.word	0x20000d68
 8001a68:	20000e74 	.word	0x20000e74
 8001a6c:	08005594 	.word	0x08005594

08001a70 <thread1.lto_priv.151>:
 * Shared code.
 ****************************************************************************/

static thread_reference_t tr1;

static THD_FUNCTION(thread1, p) {
 8001a70:	b510      	push	{r4, lr}
 8001a72:	1c04      	adds	r4, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001a74:	b672      	cpsid	i
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8001a76:	4b08      	ldr	r3, [pc, #32]	; (8001a98 <thread1.lto_priv.151+0x28>)
 8001a78:	6818      	ldr	r0, [r3, #0]
 8001a7a:	2800      	cmp	r0, #0
 8001a7c:	d004      	beq.n	8001a88 <thread1.lto_priv.151+0x18>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8001a7e:	2200      	movs	r2, #0
    tp->u.rdymsg = msg;
 8001a80:	6242      	str	r2, [r0, #36]	; 0x24
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8001a82:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8001a84:	f7fe fe04 	bl	8000690 <chSchReadyI>

  chSysLock();
  chThdResumeI(&tr1, MSG_OK);
  chSchRescheduleS();
 8001a88:	f7fe fd42 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001a8c:	b662      	cpsie	i
  chSysUnlock();
  test_emit_token(*(char *)p);
 8001a8e:	7820      	ldrb	r0, [r4, #0]
 8001a90:	f001 ff66 	bl	8003960 <test_emit_token>
}
 8001a94:	bd10      	pop	{r4, pc}
 8001a96:	46c0      	nop			; (mov r8, r8)
 8001a98:	20000430 	.word	0x20000430
 8001a9c:	46c0      	nop			; (mov r8, r8)
 8001a9e:	46c0      	nop			; (mov r8, r8)

08001aa0 <thread2>:
}

static THD_FUNCTION(thread2, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 8001aa0:	20fa      	movs	r0, #250	; 0xfa

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static THD_FUNCTION(thread2, p) {
 8001aa2:	b508      	push	{r3, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8001aa4:	0040      	lsls	r0, r0, #1
 8001aa6:	f7ff fa83 	bl	8000fb0 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001aaa:	b672      	cpsid	i
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 8001aac:	4a09      	ldr	r2, [pc, #36]	; (8001ad4 <thread2+0x34>)
 8001aae:	6893      	ldr	r3, [r2, #8]
 8001ab0:	3301      	adds	r3, #1
 8001ab2:	6093      	str	r3, [r2, #8]
 8001ab4:	2b00      	cmp	r3, #0
 8001ab6:	dd03      	ble.n	8001ac0 <thread2+0x20>
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
 8001ab8:	f7fe fd2a 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001abc:	b662      	cpsie	i
  chSysUnlock();
}
 8001abe:	bd08      	pop	{r3, pc}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8001ac0:	6810      	ldr	r0, [r2, #0]

  tqp->next             = tp->queue.next;
 8001ac2:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001ac4:	605a      	str	r2, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8001ac6:	6013      	str	r3, [r2, #0]
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 8001ac8:	2300      	movs	r3, #0
 8001aca:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8001acc:	f7fe fde0 	bl	8000690 <chSchReadyI>
 8001ad0:	e7f2      	b.n	8001ab8 <thread2+0x18>
 8001ad2:	46c0      	nop			; (mov r8, r8)
 8001ad4:	20000e74 	.word	0x20000e74
 8001ad8:	46c0      	nop			; (mov r8, r8)
 8001ada:	46c0      	nop			; (mov r8, r8)
 8001adc:	46c0      	nop			; (mov r8, r8)
 8001ade:	46c0      	nop			; (mov r8, r8)

08001ae0 <rt_test_003_001_execute.lto_priv.80>:
 * - [3.1.5] Function chThdSleepUntil() is tested with a timeline of
 *   "now" + 100 ticks.
 * .
 */

static void rt_test_003_001_execute(void) {
 8001ae0:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  /* [3.1.1] The current system time is read then a sleep is performed
     for 100 system ticks and on exit the system time is verified
     again.*/
  test_set_step(1);
 8001ae2:	2301      	movs	r3, #1
 8001ae4:	2580      	movs	r5, #128	; 0x80
 8001ae6:	4e28      	ldr	r6, [pc, #160]	; (8001b88 <rt_test_003_001_execute.lto_priv.80+0xa8>)
 8001ae8:	05ed      	lsls	r5, r5, #23
 8001aea:	6033      	str	r3, [r6, #0]
 8001aec:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleep(100);
 8001aee:	2064      	movs	r0, #100	; 0x64
 8001af0:	f7ff fa5e 	bl	8000fb0 <chThdSleep>
 8001af4:	1c20      	adds	r0, r4, #0
 8001af6:	1c21      	adds	r1, r4, #0
 8001af8:	3064      	adds	r0, #100	; 0x64
 8001afa:	3167      	adds	r1, #103	; 0x67
    test_assert_time_window(chTimeAddX(time, 100),
 8001afc:	f003 fc48 	bl	8005390 <_test_assert_time_window.constprop.2>
 8001b00:	2800      	cmp	r0, #0
 8001b02:	d000      	beq.n	8001b06 <rt_test_003_001_execute.lto_priv.80+0x26>
    chThdSleepUntil(chTimeAddX(time, 100));
    test_assert_time_window(chTimeAddX(time, 100),
                            chTimeAddX(time, 100 + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
  }
}
 8001b04:	bd70      	pop	{r4, r5, r6, pc}
  }

  /* [3.1.2] The current system time is read then a sleep is performed
     for 100000 microseconds and on exit the system time is verified
     again.*/
  test_set_step(2);
 8001b06:	2302      	movs	r3, #2
  {
    time = chVTGetSystemTimeX();
    chThdSleepMicroseconds(100000);
 8001b08:	20fa      	movs	r0, #250	; 0xfa
  }

  /* [3.1.2] The current system time is read then a sleep is performed
     for 100000 microseconds and on exit the system time is verified
     again.*/
  test_set_step(2);
 8001b0a:	6033      	str	r3, [r6, #0]
  {
    time = chVTGetSystemTimeX();
    chThdSleepMicroseconds(100000);
 8001b0c:	0080      	lsls	r0, r0, #2
 8001b0e:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8001b10:	f7ff fa4e 	bl	8000fb0 <chThdSleep>
 8001b14:	23fa      	movs	r3, #250	; 0xfa
 8001b16:	009b      	lsls	r3, r3, #2
 8001b18:	18e0      	adds	r0, r4, r3
 8001b1a:	4b1c      	ldr	r3, [pc, #112]	; (8001b8c <rt_test_003_001_execute.lto_priv.80+0xac>)
 8001b1c:	18e1      	adds	r1, r4, r3
    test_assert_time_window(chTimeAddX(time, TIME_US2I(100000)),
 8001b1e:	f003 fc37 	bl	8005390 <_test_assert_time_window.constprop.2>
 8001b22:	2800      	cmp	r0, #0
 8001b24:	d1ee      	bne.n	8001b04 <rt_test_003_001_execute.lto_priv.80+0x24>
  }

  /* [3.1.3] The current system time is read then a sleep is performed
     for 100 milliseconds and on exit the system time is verified
     again.*/
  test_set_step(3);
 8001b26:	2303      	movs	r3, #3
  {
    time = chVTGetSystemTimeX();
    chThdSleepMilliseconds(100);
 8001b28:	20fa      	movs	r0, #250	; 0xfa
  }

  /* [3.1.3] The current system time is read then a sleep is performed
     for 100 milliseconds and on exit the system time is verified
     again.*/
  test_set_step(3);
 8001b2a:	6033      	str	r3, [r6, #0]
  {
    time = chVTGetSystemTimeX();
    chThdSleepMilliseconds(100);
 8001b2c:	0080      	lsls	r0, r0, #2
 8001b2e:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8001b30:	f7ff fa3e 	bl	8000fb0 <chThdSleep>
 8001b34:	23fa      	movs	r3, #250	; 0xfa
 8001b36:	009b      	lsls	r3, r3, #2
 8001b38:	18e0      	adds	r0, r4, r3
 8001b3a:	4b14      	ldr	r3, [pc, #80]	; (8001b8c <rt_test_003_001_execute.lto_priv.80+0xac>)
 8001b3c:	18e1      	adds	r1, r4, r3
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(100)),
 8001b3e:	f003 fc27 	bl	8005390 <_test_assert_time_window.constprop.2>
 8001b42:	2800      	cmp	r0, #0
 8001b44:	d1de      	bne.n	8001b04 <rt_test_003_001_execute.lto_priv.80+0x24>
                            "out of time window");
  }

  /* [3.1.4] The current system time is read then a sleep is performed
     for 1 second and on exit the system time is verified again.*/
  test_set_step(4);
 8001b46:	2304      	movs	r3, #4
  {
    time = chVTGetSystemTimeX();
    chThdSleepSeconds(1);
 8001b48:	4811      	ldr	r0, [pc, #68]	; (8001b90 <rt_test_003_001_execute.lto_priv.80+0xb0>)
                            "out of time window");
  }

  /* [3.1.4] The current system time is read then a sleep is performed
     for 1 second and on exit the system time is verified again.*/
  test_set_step(4);
 8001b4a:	6033      	str	r3, [r6, #0]
 8001b4c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepSeconds(1);
 8001b4e:	f7ff fa2f 	bl	8000fb0 <chThdSleep>
 8001b52:	4b0f      	ldr	r3, [pc, #60]	; (8001b90 <rt_test_003_001_execute.lto_priv.80+0xb0>)
 8001b54:	18e0      	adds	r0, r4, r3
 8001b56:	4b0f      	ldr	r3, [pc, #60]	; (8001b94 <rt_test_003_001_execute.lto_priv.80+0xb4>)
 8001b58:	18e1      	adds	r1, r4, r3
    test_assert_time_window(chTimeAddX(time, TIME_S2I(1)),
 8001b5a:	f003 fc19 	bl	8005390 <_test_assert_time_window.constprop.2>
 8001b5e:	2800      	cmp	r0, #0
 8001b60:	d1d0      	bne.n	8001b04 <rt_test_003_001_execute.lto_priv.80+0x24>
                            "out of time window");
  }

  /* [3.1.5] Function chThdSleepUntil() is tested with a timeline of
     "now" + 100 ticks.*/
  test_set_step(5);
 8001b62:	2305      	movs	r3, #5
 8001b64:	6033      	str	r3, [r6, #0]
 8001b66:	6a6c      	ldr	r4, [r5, #36]	; 0x24
 8001b68:	1c26      	adds	r6, r4, #0
 8001b6a:	3664      	adds	r6, #100	; 0x64
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001b6c:	b672      	cpsid	i
 8001b6e:	6a69      	ldr	r1, [r5, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8001b70:	1a71      	subs	r1, r6, r1
void chThdSleepUntil(systime_t time) {
  sysinterval_t interval;

  chSysLock();
  interval = chTimeDiffX(chVTGetSystemTimeX(), time);
  if (interval > (sysinterval_t)0) {
 8001b72:	d002      	beq.n	8001b7a <rt_test_003_001_execute.lto_priv.80+0x9a>
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8001b74:	3008      	adds	r0, #8
 8001b76:	f7ff f893 	bl	8000ca0 <chSchGoSleepTimeoutS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001b7a:	b662      	cpsie	i

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)((systime_t)-1));
#endif

  return systime + (systime_t)interval;
 8001b7c:	1c21      	adds	r1, r4, #0
  {
    time = chVTGetSystemTimeX();
    chThdSleepUntil(chTimeAddX(time, 100));
    test_assert_time_window(chTimeAddX(time, 100),
 8001b7e:	1c30      	adds	r0, r6, #0
 8001b80:	3167      	adds	r1, #103	; 0x67
 8001b82:	f003 fc05 	bl	8005390 <_test_assert_time_window.constprop.2>
 8001b86:	e7bd      	b.n	8001b04 <rt_test_003_001_execute.lto_priv.80+0x24>
 8001b88:	20000d64 	.word	0x20000d64
 8001b8c:	000003eb 	.word	0x000003eb
 8001b90:	00002710 	.word	0x00002710
 8001b94:	00002713 	.word	0x00002713
 8001b98:	46c0      	nop			; (mov r8, r8)
 8001b9a:	46c0      	nop			; (mov r8, r8)
 8001b9c:	46c0      	nop			; (mov r8, r8)
 8001b9e:	46c0      	nop			; (mov r8, r8)

08001ba0 <rt_test_005_003_execute.lto_priv.92>:

static void rt_test_005_003_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void rt_test_005_003_execute(void) {
 8001ba0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001ba2:	4646      	mov	r6, r8
 8001ba4:	464f      	mov	r7, r9
  unsigned i;
  systime_t target_time;
  msg_t msg;

  /* [5.3.1] Testing special case TIME_IMMEDIATE.*/
  test_set_step(1);
 8001ba6:	2301      	movs	r3, #1

static void rt_test_005_003_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void rt_test_005_003_execute(void) {
 8001ba8:	b4c0      	push	{r6, r7}
  unsigned i;
  systime_t target_time;
  msg_t msg;

  /* [5.3.1] Testing special case TIME_IMMEDIATE.*/
  test_set_step(1);
 8001baa:	4e4b      	ldr	r6, [pc, #300]	; (8001cd8 <rt_test_005_003_execute.lto_priv.92+0x138>)
 8001bac:	6033      	str	r3, [r6, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001bae:	b672      	cpsid	i
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8001bb0:	4c4a      	ldr	r4, [pc, #296]	; (8001cdc <rt_test_005_003_execute.lto_priv.92+0x13c>)
 8001bb2:	68a3      	ldr	r3, [r4, #8]
 8001bb4:	3b01      	subs	r3, #1
 8001bb6:	d500      	bpl.n	8001bba <rt_test_005_003_execute.lto_priv.92+0x1a>
 8001bb8:	e08c      	b.n	8001cd4 <rt_test_005_003_execute.lto_priv.92+0x134>
 8001bba:	2000      	movs	r0, #0
 8001bbc:	60a3      	str	r3, [r4, #8]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001bbe:	b662      	cpsie	i
  {
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8001bc0:	4d47      	ldr	r5, [pc, #284]	; (8001ce0 <rt_test_005_003_execute.lto_priv.92+0x140>)
 8001bc2:	1c29      	adds	r1, r5, #0
 8001bc4:	f002 f99c 	bl	8003f00 <_test_assert>
 8001bc8:	2800      	cmp	r0, #0
 8001bca:	d003      	beq.n	8001bd4 <rt_test_005_003_execute.lto_priv.92+0x34>
    test_assert_sequence("ABCDE", "invalid sequence");
    test_assert_time_window(target_time,
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
  }
}
 8001bcc:	bc0c      	pop	{r2, r3}
 8001bce:	4690      	mov	r8, r2
 8001bd0:	4699      	mov	r9, r3
 8001bd2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 8001bd4:	6823      	ldr	r3, [r4, #0]
  /* [5.3.1] Testing special case TIME_IMMEDIATE.*/
  test_set_step(1);
  {
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8001bd6:	4f43      	ldr	r7, [pc, #268]	; (8001ce4 <rt_test_005_003_execute.lto_priv.92+0x144>)
 8001bd8:	1b18      	subs	r0, r3, r4
 8001bda:	4242      	negs	r2, r0
 8001bdc:	4142      	adcs	r2, r0
 8001bde:	1c39      	adds	r1, r7, #0
 8001be0:	b2d0      	uxtb	r0, r2
 8001be2:	f002 f98d 	bl	8003f00 <_test_assert>
 8001be6:	2800      	cmp	r0, #0
 8001be8:	d1f0      	bne.n	8001bcc <rt_test_005_003_execute.lto_priv.92+0x2c>
    test_assert(sem1.cnt == 0, "counter not zero");
 8001bea:	68a0      	ldr	r0, [r4, #8]
 8001bec:	4243      	negs	r3, r0
 8001bee:	4158      	adcs	r0, r3
 8001bf0:	4b3d      	ldr	r3, [pc, #244]	; (8001ce8 <rt_test_005_003_execute.lto_priv.92+0x148>)
 8001bf2:	b2c0      	uxtb	r0, r0
 8001bf4:	1c19      	adds	r1, r3, #0
 8001bf6:	4699      	mov	r9, r3
 8001bf8:	f002 f982 	bl	8003f00 <_test_assert>
 8001bfc:	2800      	cmp	r0, #0
 8001bfe:	d1e5      	bne.n	8001bcc <rt_test_005_003_execute.lto_priv.92+0x2c>
  }

  /* [5.3.2] Testing non-timeout condition.*/
  test_set_step(2);
 8001c00:	2302      	movs	r3, #2
 8001c02:	6033      	str	r3, [r6, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001c04:	4b39      	ldr	r3, [pc, #228]	; (8001cec <rt_test_005_003_execute.lto_priv.92+0x14c>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001c06:	4a3a      	ldr	r2, [pc, #232]	; (8001cf0 <rt_test_005_003_execute.lto_priv.92+0x150>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001c08:	699b      	ldr	r3, [r3, #24]
 8001c0a:	483a      	ldr	r0, [pc, #232]	; (8001cf4 <rt_test_005_003_execute.lto_priv.92+0x154>)
 8001c0c:	6899      	ldr	r1, [r3, #8]
 8001c0e:	2300      	movs	r3, #0
 8001c10:	3901      	subs	r1, #1
 8001c12:	f003 f975 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8001c16:	4b38      	ldr	r3, [pc, #224]	; (8001cf8 <rt_test_005_003_execute.lto_priv.92+0x158>)
 8001c18:	6018      	str	r0, [r3, #0]
                                   thread2, 0);
    msg = chSemWaitTimeout(&sem1, TIME_MS2I(500));
 8001c1a:	4838      	ldr	r0, [pc, #224]	; (8001cfc <rt_test_005_003_execute.lto_priv.92+0x15c>)
 8001c1c:	f003 f9b8 	bl	8004f90 <chSemWaitTimeout.constprop.35>
 8001c20:	4680      	mov	r8, r0
    test_wait_threads();
 8001c22:	f001 fe6d 	bl	8003900 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 8001c26:	4640      	mov	r0, r8
 8001c28:	4243      	negs	r3, r0
 8001c2a:	4158      	adcs	r0, r3
 8001c2c:	1c29      	adds	r1, r5, #0
 8001c2e:	b2c0      	uxtb	r0, r0
 8001c30:	f002 f966 	bl	8003f00 <_test_assert>
 8001c34:	2800      	cmp	r0, #0
 8001c36:	d1c9      	bne.n	8001bcc <rt_test_005_003_execute.lto_priv.92+0x2c>
 8001c38:	6823      	ldr	r3, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8001c3a:	1c39      	adds	r1, r7, #0
 8001c3c:	1b18      	subs	r0, r3, r4
 8001c3e:	4242      	negs	r2, r0
 8001c40:	4142      	adcs	r2, r0
 8001c42:	b2d0      	uxtb	r0, r2
 8001c44:	f002 f95c 	bl	8003f00 <_test_assert>
 8001c48:	2800      	cmp	r0, #0
 8001c4a:	d1bf      	bne.n	8001bcc <rt_test_005_003_execute.lto_priv.92+0x2c>
    test_assert(sem1.cnt == 0, "counter not zero");
 8001c4c:	68a0      	ldr	r0, [r4, #8]
 8001c4e:	4649      	mov	r1, r9
 8001c50:	4243      	negs	r3, r0
 8001c52:	4158      	adcs	r0, r3
 8001c54:	b2c0      	uxtb	r0, r0
 8001c56:	f002 f953 	bl	8003f00 <_test_assert>
 8001c5a:	2800      	cmp	r0, #0
 8001c5c:	d1b6      	bne.n	8001bcc <rt_test_005_003_execute.lto_priv.92+0x2c>
  }

  /* [5.3.3] Testing timeout condition.*/
  test_set_step(3);
 8001c5e:	2303      	movs	r3, #3
 8001c60:	6033      	str	r3, [r6, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
 8001c62:	f001 fe3d 	bl	80038e0 <test_wait_tick>
 8001c66:	2641      	movs	r6, #65	; 0x41
 8001c68:	4680      	mov	r8, r0
    for (i = 0; i < 5; i++) {
      test_emit_token('A' + i);
 8001c6a:	1c30      	adds	r0, r6, #0
 8001c6c:	f001 fe78 	bl	8003960 <test_emit_token>
      msg = chSemWaitTimeout(&sem1, TIME_MS2I(50));
 8001c70:	20fa      	movs	r0, #250	; 0xfa
 8001c72:	0040      	lsls	r0, r0, #1
 8001c74:	f003 f98c 	bl	8004f90 <chSemWaitTimeout.constprop.35>
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8001c78:	3001      	adds	r0, #1
 8001c7a:	4242      	negs	r2, r0
 8001c7c:	4142      	adcs	r2, r0
 8001c7e:	1c29      	adds	r1, r5, #0
 8001c80:	b2d0      	uxtb	r0, r2
 8001c82:	f002 f93d 	bl	8003f00 <_test_assert>
 8001c86:	2800      	cmp	r0, #0
 8001c88:	d1a0      	bne.n	8001bcc <rt_test_005_003_execute.lto_priv.92+0x2c>
 8001c8a:	6823      	ldr	r3, [r4, #0]
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8001c8c:	1c39      	adds	r1, r7, #0
 8001c8e:	1b18      	subs	r0, r3, r4
 8001c90:	4242      	negs	r2, r0
 8001c92:	4142      	adcs	r2, r0
 8001c94:	b2d0      	uxtb	r0, r2
 8001c96:	f002 f933 	bl	8003f00 <_test_assert>
 8001c9a:	2800      	cmp	r0, #0
 8001c9c:	d196      	bne.n	8001bcc <rt_test_005_003_execute.lto_priv.92+0x2c>
      test_assert(sem1.cnt == 0, "counter not zero");
 8001c9e:	68a0      	ldr	r0, [r4, #8]
 8001ca0:	4649      	mov	r1, r9
 8001ca2:	4243      	negs	r3, r0
 8001ca4:	4158      	adcs	r0, r3
 8001ca6:	b2c0      	uxtb	r0, r0
 8001ca8:	f002 f92a 	bl	8003f00 <_test_assert>
 8001cac:	2800      	cmp	r0, #0
 8001cae:	d000      	beq.n	8001cb2 <rt_test_005_003_execute.lto_priv.92+0x112>
 8001cb0:	e78c      	b.n	8001bcc <rt_test_005_003_execute.lto_priv.92+0x2c>
 8001cb2:	3601      	adds	r6, #1
 8001cb4:	b2f6      	uxtb	r6, r6

  /* [5.3.3] Testing timeout condition.*/
  test_set_step(3);
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(5 * 50));
    for (i = 0; i < 5; i++) {
 8001cb6:	2e46      	cmp	r6, #70	; 0x46
 8001cb8:	d1d7      	bne.n	8001c6a <rt_test_005_003_execute.lto_priv.92+0xca>
      msg = chSemWaitTimeout(&sem1, TIME_MS2I(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
 8001cba:	4811      	ldr	r0, [pc, #68]	; (8001d00 <rt_test_005_003_execute.lto_priv.92+0x160>)
 8001cbc:	f003 fb38 	bl	8005330 <_test_assert_sequence.constprop.3>
 8001cc0:	2800      	cmp	r0, #0
 8001cc2:	d000      	beq.n	8001cc6 <rt_test_005_003_execute.lto_priv.92+0x126>
 8001cc4:	e782      	b.n	8001bcc <rt_test_005_003_execute.lto_priv.92+0x2c>
 8001cc6:	480f      	ldr	r0, [pc, #60]	; (8001d04 <rt_test_005_003_execute.lto_priv.92+0x164>)
 8001cc8:	490f      	ldr	r1, [pc, #60]	; (8001d08 <rt_test_005_003_execute.lto_priv.92+0x168>)
 8001cca:	4440      	add	r0, r8
 8001ccc:	4441      	add	r1, r8
    test_assert_time_window(target_time,
 8001cce:	f003 fb5f 	bl	8005390 <_test_assert_time_window.constprop.2>
 8001cd2:	e77b      	b.n	8001bcc <rt_test_005_003_execute.lto_priv.92+0x2c>
 8001cd4:	2001      	movs	r0, #1
 8001cd6:	e772      	b.n	8001bbe <rt_test_005_003_execute.lto_priv.92+0x1e>
 8001cd8:	20000d64 	.word	0x20000d64
 8001cdc:	20000e74 	.word	0x20000e74
 8001ce0:	080055a4 	.word	0x080055a4
 8001ce4:	0800552c 	.word	0x0800552c
 8001ce8:	0800553c 	.word	0x0800553c
 8001cec:	20000e84 	.word	0x20000e84
 8001cf0:	08001aa1 	.word	0x08001aa1
 8001cf4:	200006e8 	.word	0x200006e8
 8001cf8:	20000d68 	.word	0x20000d68
 8001cfc:	00001388 	.word	0x00001388
 8001d00:	0800558c 	.word	0x0800558c
 8001d04:	000009c4 	.word	0x000009c4
 8001d08:	000009d8 	.word	0x000009d8
 8001d0c:	46c0      	nop			; (mov r8, r8)
 8001d0e:	46c0      	nop			; (mov r8, r8)

08001d10 <rt_test_004_001_execute.lto_priv.85>:

static void rt_test_004_001_setup(void) {
  tr1 = NULL;
}

static void rt_test_004_001_execute(void) {
 8001d10:	b5f0      	push	{r4, r5, r6, r7, lr}
  msg_t msg;

  /* [4.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 8001d12:	2301      	movs	r3, #1

static void rt_test_004_001_setup(void) {
  tr1 = NULL;
}

static void rt_test_004_001_execute(void) {
 8001d14:	4647      	mov	r7, r8
  msg_t msg;

  /* [4.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 8001d16:	4e2d      	ldr	r6, [pc, #180]	; (8001dcc <rt_test_004_001_execute.lto_priv.85+0xbc>)
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001d18:	4d2d      	ldr	r5, [pc, #180]	; (8001dd0 <rt_test_004_001_execute.lto_priv.85+0xc0>)

static void rt_test_004_001_setup(void) {
  tr1 = NULL;
}

static void rt_test_004_001_execute(void) {
 8001d1a:	b480      	push	{r7}
  msg_t msg;

  /* [4.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 8001d1c:	6033      	str	r3, [r6, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001d1e:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 8001d20:	4a2c      	ldr	r2, [pc, #176]	; (8001dd4 <rt_test_004_001_execute.lto_priv.85+0xc4>)
 8001d22:	6899      	ldr	r1, [r3, #8]
 8001d24:	482c      	ldr	r0, [pc, #176]	; (8001dd8 <rt_test_004_001_execute.lto_priv.85+0xc8>)
 8001d26:	3901      	subs	r1, #1
 8001d28:	4b2c      	ldr	r3, [pc, #176]	; (8001ddc <rt_test_004_001_execute.lto_priv.85+0xcc>)
 8001d2a:	f003 f8e9 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8001d2e:	4b2c      	ldr	r3, [pc, #176]	; (8001de0 <rt_test_004_001_execute.lto_priv.85+0xd0>)
 8001d30:	6018      	str	r0, [r3, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001d32:	b672      	cpsid	i

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8001d34:	4c2b      	ldr	r4, [pc, #172]	; (8001de4 <rt_test_004_001_execute.lto_priv.85+0xd4>)
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001d36:	69ab      	ldr	r3, [r5, #24]
 8001d38:	2003      	movs	r0, #3
  tp->u.wttrp = trp;
 8001d3a:	625c      	str	r4, [r3, #36]	; 0x24

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8001d3c:	6023      	str	r3, [r4, #0]
 8001d3e:	f7fe fc6f 	bl	8000620 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8001d42:	69ab      	ldr	r3, [r5, #24]
 8001d44:	6a5f      	ldr	r7, [r3, #36]	; 0x24
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001d46:	b662      	cpsie	i
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
 8001d48:	6820      	ldr	r0, [r4, #0]
 8001d4a:	4243      	negs	r3, r0
 8001d4c:	4158      	adcs	r0, r3
 8001d4e:	4b26      	ldr	r3, [pc, #152]	; (8001de8 <rt_test_004_001_execute.lto_priv.85+0xd8>)
 8001d50:	b2c0      	uxtb	r0, r0
 8001d52:	1c19      	adds	r1, r3, #0
 8001d54:	4698      	mov	r8, r3
 8001d56:	f002 f8d3 	bl	8003f00 <_test_assert>
 8001d5a:	2800      	cmp	r0, #0
 8001d5c:	d002      	beq.n	8001d64 <rt_test_004_001_execute.lto_priv.85+0x54>
                            chTimeAddX(time, TIME_MS2I(1000) + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
  }
}
 8001d5e:	bc04      	pop	{r2}
 8001d60:	4690      	mov	r8, r2
 8001d62:	bdf0      	pop	{r4, r5, r6, r7, pc}
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
    test_assert(MSG_OK == msg,"wrong returned message");
 8001d64:	4278      	negs	r0, r7
 8001d66:	4178      	adcs	r0, r7
 8001d68:	4f20      	ldr	r7, [pc, #128]	; (8001dec <rt_test_004_001_execute.lto_priv.85+0xdc>)
 8001d6a:	b2c0      	uxtb	r0, r0
 8001d6c:	1c39      	adds	r1, r7, #0
 8001d6e:	f002 f8c7 	bl	8003f00 <_test_assert>
 8001d72:	2800      	cmp	r0, #0
 8001d74:	d1f3      	bne.n	8001d5e <rt_test_004_001_execute.lto_priv.85+0x4e>
    test_wait_threads();
 8001d76:	f001 fdc3 	bl	8003900 <test_wait_threads>
  }

  /* [4.1.2] The function chThdSuspendTimeoutS() is invoked, the thread
     is not resumed so a timeout must occur. On return the message and
     the state of the reference are tested.*/
  test_set_step(2);
 8001d7a:	2302      	movs	r3, #2
 8001d7c:	6033      	str	r3, [r6, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001d7e:	b672      	cpsid	i
 8001d80:	2380      	movs	r3, #128	; 0x80
 8001d82:	05db      	lsls	r3, r3, #23
 8001d84:	6a5e      	ldr	r6, [r3, #36]	; 0x24
 8001d86:	69ab      	ldr	r3, [r5, #24]
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8001d88:	4919      	ldr	r1, [pc, #100]	; (8001df0 <rt_test_004_001_execute.lto_priv.85+0xe0>)
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->u.wttrp = trp;
 8001d8a:	625c      	str	r4, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8001d8c:	2003      	movs	r0, #3

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8001d8e:	6023      	str	r3, [r4, #0]
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8001d90:	f7fe ff86 	bl	8000ca0 <chSchGoSleepTimeoutS>
 8001d94:	1c05      	adds	r5, r0, #0
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001d96:	b662      	cpsie	i
 8001d98:	4b15      	ldr	r3, [pc, #84]	; (8001df0 <rt_test_004_001_execute.lto_priv.85+0xe0>)
 8001d9a:	18f0      	adds	r0, r6, r3
 8001d9c:	4b15      	ldr	r3, [pc, #84]	; (8001df4 <rt_test_004_001_execute.lto_priv.85+0xe4>)
 8001d9e:	18f1      	adds	r1, r6, r3
  {
    chSysLock();
    time = chVTGetSystemTimeX();
    msg = chThdSuspendTimeoutS(&tr1, TIME_MS2I(1000));
    chSysUnlock();
    test_assert_time_window(chTimeAddX(time, TIME_MS2I(1000)),
 8001da0:	f003 faf6 	bl	8005390 <_test_assert_time_window.constprop.2>
 8001da4:	2800      	cmp	r0, #0
 8001da6:	d1da      	bne.n	8001d5e <rt_test_004_001_execute.lto_priv.85+0x4e>
                            chTimeAddX(time, TIME_MS2I(1000) + CH_CFG_ST_TIMEDELTA + 1),
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
 8001da8:	6823      	ldr	r3, [r4, #0]
 8001daa:	4641      	mov	r1, r8
 8001dac:	4258      	negs	r0, r3
 8001dae:	4158      	adcs	r0, r3
 8001db0:	b2c0      	uxtb	r0, r0
 8001db2:	f002 f8a5 	bl	8003f00 <_test_assert>
 8001db6:	2800      	cmp	r0, #0
 8001db8:	d1d1      	bne.n	8001d5e <rt_test_004_001_execute.lto_priv.85+0x4e>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 8001dba:	3501      	adds	r5, #1
 8001dbc:	4268      	negs	r0, r5
 8001dbe:	4168      	adcs	r0, r5
 8001dc0:	1c39      	adds	r1, r7, #0
 8001dc2:	b2c0      	uxtb	r0, r0
 8001dc4:	f002 f89c 	bl	8003f00 <_test_assert>
 8001dc8:	e7c9      	b.n	8001d5e <rt_test_004_001_execute.lto_priv.85+0x4e>
 8001dca:	46c0      	nop			; (mov r8, r8)
 8001dcc:	20000d64 	.word	0x20000d64
 8001dd0:	20000e84 	.word	0x20000e84
 8001dd4:	08001a71 	.word	0x08001a71
 8001dd8:	200006e8 	.word	0x200006e8
 8001ddc:	0800557c 	.word	0x0800557c
 8001de0:	20000d68 	.word	0x20000d68
 8001de4:	20000430 	.word	0x20000430
 8001de8:	080055bc 	.word	0x080055bc
 8001dec:	08005564 	.word	0x08005564
 8001df0:	00002710 	.word	0x00002710
 8001df4:	00002713 	.word	0x00002713
 8001df8:	46c0      	nop			; (mov r8, r8)
 8001dfa:	46c0      	nop			; (mov r8, r8)
 8001dfc:	46c0      	nop			; (mov r8, r8)
 8001dfe:	46c0      	nop			; (mov r8, r8)

08001e00 <rt_test_003_004_execute.lto_priv.83>:
 * - [3.4.3] Raising thread priority above the boosted level.
 * - [3.4.4] Restoring original conditions.
 * .
 */

static void rt_test_003_004_execute(void) {
 8001e00:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001e02:	464e      	mov	r6, r9
 8001e04:	4645      	mov	r5, r8
 8001e06:	4657      	mov	r7, sl
 8001e08:	b4e0      	push	{r5, r6, r7}
 8001e0a:	4e33      	ldr	r6, [pc, #204]	; (8001ed8 <rt_test_003_004_execute.lto_priv.83+0xd8>)
 8001e0c:	69b3      	ldr	r3, [r6, #24]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001e0e:	689c      	ldr	r4, [r3, #8]

  /* [3.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    chThdGetSelfX()->prio += 2;
 8001e10:	1ca5      	adds	r5, r4, #2
 8001e12:	609d      	str	r5, [r3, #8]
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8001e14:	4b31      	ldr	r3, [pc, #196]	; (8001edc <rt_test_003_004_execute.lto_priv.83+0xdc>)
  {
    p1 = chThdSetPriority(prio + 1);
 8001e16:	1c67      	adds	r7, r4, #1
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8001e18:	4698      	mov	r8, r3
 8001e1a:	2302      	movs	r3, #2
 8001e1c:	4642      	mov	r2, r8
  {
    p1 = chThdSetPriority(prio + 1);
 8001e1e:	1c38      	adds	r0, r7, #0
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [3.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8001e20:	6013      	str	r3, [r2, #0]
  {
    p1 = chThdSetPriority(prio + 1);
 8001e22:	f7fe fb9d 	bl	8000560 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 8001e26:	1b00      	subs	r0, r0, r4
 8001e28:	4243      	negs	r3, r0
 8001e2a:	4158      	adcs	r0, r3
 8001e2c:	4b2c      	ldr	r3, [pc, #176]	; (8001ee0 <rt_test_003_004_execute.lto_priv.83+0xe0>)
 8001e2e:	b2c0      	uxtb	r0, r0
 8001e30:	1c19      	adds	r1, r3, #0
 8001e32:	4699      	mov	r9, r3
 8001e34:	f002 f864 	bl	8003f00 <_test_assert>
 8001e38:	2800      	cmp	r0, #0
 8001e3a:	d004      	beq.n	8001e46 <rt_test_003_004_execute.lto_priv.83+0x46>
    chSysLock();
    chThdGetSelfX()->prio = prio;
    chThdGetSelfX()->realprio = prio;
    chSysUnlock();
  }
}
 8001e3c:	bc1c      	pop	{r2, r3, r4}
 8001e3e:	4690      	mov	r8, r2
 8001e40:	4699      	mov	r9, r3
 8001e42:	46a2      	mov	sl, r4
 8001e44:	bdf0      	pop	{r4, r5, r6, r7, pc}
     the boosted level.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(prio + 1);
    test_assert(p1 == prio, "unexpected returned priority level");
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
 8001e46:	69b3      	ldr	r3, [r6, #24]
 8001e48:	6898      	ldr	r0, [r3, #8]
 8001e4a:	1a28      	subs	r0, r5, r0
 8001e4c:	4245      	negs	r5, r0
 8001e4e:	4168      	adcs	r0, r5
 8001e50:	4d24      	ldr	r5, [pc, #144]	; (8001ee4 <rt_test_003_004_execute.lto_priv.83+0xe4>)
 8001e52:	b2c0      	uxtb	r0, r0
 8001e54:	1c29      	adds	r1, r5, #0
 8001e56:	f002 f853 	bl	8003f00 <_test_assert>
 8001e5a:	2800      	cmp	r0, #0
 8001e5c:	d1ee      	bne.n	8001e3c <rt_test_003_004_execute.lto_priv.83+0x3c>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 8001e5e:	69b3      	ldr	r3, [r6, #24]
 8001e60:	4921      	ldr	r1, [pc, #132]	; (8001ee8 <rt_test_003_004_execute.lto_priv.83+0xe8>)
 8001e62:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8001e64:	1a38      	subs	r0, r7, r0
 8001e66:	4243      	negs	r3, r0
 8001e68:	4158      	adcs	r0, r3
 8001e6a:	b2c0      	uxtb	r0, r0
 8001e6c:	f002 f848 	bl	8003f00 <_test_assert>
 8001e70:	2800      	cmp	r0, #0
 8001e72:	d1e3      	bne.n	8001e3c <rt_test_003_004_execute.lto_priv.83+0x3c>
  }

  /* [3.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
 8001e74:	2303      	movs	r3, #3
 8001e76:	4642      	mov	r2, r8
 8001e78:	6013      	str	r3, [r2, #0]
  {
    p1 = chThdSetPriority(prio + 3);
 8001e7a:	1ce3      	adds	r3, r4, #3
 8001e7c:	1c18      	adds	r0, r3, #0
 8001e7e:	469a      	mov	sl, r3
 8001e80:	f7fe fb6e 	bl	8000560 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8001e84:	1a38      	subs	r0, r7, r0
 8001e86:	4247      	negs	r7, r0
 8001e88:	4178      	adcs	r0, r7
 8001e8a:	4649      	mov	r1, r9
 8001e8c:	b2c0      	uxtb	r0, r0
 8001e8e:	f002 f837 	bl	8003f00 <_test_assert>
 8001e92:	2800      	cmp	r0, #0
 8001e94:	d1d2      	bne.n	8001e3c <rt_test_003_004_execute.lto_priv.83+0x3c>
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
 8001e96:	69b3      	ldr	r3, [r6, #24]
 8001e98:	1c29      	adds	r1, r5, #0
 8001e9a:	6898      	ldr	r0, [r3, #8]
 8001e9c:	4653      	mov	r3, sl
 8001e9e:	1a18      	subs	r0, r3, r0
 8001ea0:	4243      	negs	r3, r0
 8001ea2:	4158      	adcs	r0, r3
 8001ea4:	b2c0      	uxtb	r0, r0
 8001ea6:	f002 f82b 	bl	8003f00 <_test_assert>
 8001eaa:	2800      	cmp	r0, #0
 8001eac:	d1c6      	bne.n	8001e3c <rt_test_003_004_execute.lto_priv.83+0x3c>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 8001eae:	69b3      	ldr	r3, [r6, #24]
 8001eb0:	490e      	ldr	r1, [pc, #56]	; (8001eec <rt_test_003_004_execute.lto_priv.83+0xec>)
 8001eb2:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8001eb4:	4653      	mov	r3, sl
 8001eb6:	1a18      	subs	r0, r3, r0
 8001eb8:	4243      	negs	r3, r0
 8001eba:	4158      	adcs	r0, r3
 8001ebc:	b2c0      	uxtb	r0, r0
 8001ebe:	f002 f81f 	bl	8003f00 <_test_assert>
 8001ec2:	2800      	cmp	r0, #0
 8001ec4:	d1ba      	bne.n	8001e3c <rt_test_003_004_execute.lto_priv.83+0x3c>
  }

  /* [3.4.4] Restoring original conditions.*/
  test_set_step(4);
 8001ec6:	2304      	movs	r3, #4
 8001ec8:	4642      	mov	r2, r8
 8001eca:	6013      	str	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001ecc:	b672      	cpsid	i
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001ece:	69b3      	ldr	r3, [r6, #24]
  {
    chSysLock();
    chThdGetSelfX()->prio = prio;
 8001ed0:	609c      	str	r4, [r3, #8]
    chThdGetSelfX()->realprio = prio;
 8001ed2:	63dc      	str	r4, [r3, #60]	; 0x3c
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001ed4:	b662      	cpsie	i
 8001ed6:	e7b1      	b.n	8001e3c <rt_test_003_004_execute.lto_priv.83+0x3c>
 8001ed8:	20000e84 	.word	0x20000e84
 8001edc:	20000d64 	.word	0x20000d64
 8001ee0:	080055c8 	.word	0x080055c8
 8001ee4:	080055ec 	.word	0x080055ec
 8001ee8:	08005608 	.word	0x08005608
 8001eec:	08005630 	.word	0x08005630

08001ef0 <rt_test_003_003_execute.lto_priv.82>:
static void rt_test_003_003_execute(void) {
  tprio_t prio, p1;

  /* [3.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8001ef0:	4b23      	ldr	r3, [pc, #140]	; (8001f80 <rt_test_003_003_execute.lto_priv.82+0x90>)
 * - [3.3.2] Thread priority is returned to the previous value then a
 *   check is performed.
 * .
 */

static void rt_test_003_003_execute(void) {
 8001ef2:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001ef4:	4645      	mov	r5, r8
  tprio_t prio, p1;

  /* [3.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8001ef6:	4698      	mov	r8, r3
 * - [3.3.2] Thread priority is returned to the previous value then a
 *   check is performed.
 * .
 */

static void rt_test_003_003_execute(void) {
 8001ef8:	464e      	mov	r6, r9
 8001efa:	4657      	mov	r7, sl
  tprio_t prio, p1;

  /* [3.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8001efc:	2301      	movs	r3, #1
 8001efe:	4642      	mov	r2, r8
 * - [3.3.2] Thread priority is returned to the previous value then a
 *   check is performed.
 * .
 */

static void rt_test_003_003_execute(void) {
 8001f00:	b4e0      	push	{r5, r6, r7}
 8001f02:	4e20      	ldr	r6, [pc, #128]	; (8001f84 <rt_test_003_003_execute.lto_priv.82+0x94>)
  tprio_t prio, p1;

  /* [3.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8001f04:	6013      	str	r3, [r2, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001f06:	69b3      	ldr	r3, [r6, #24]
 8001f08:	689d      	ldr	r5, [r3, #8]
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8001f0a:	1c6c      	adds	r4, r5, #1
 8001f0c:	1c20      	adds	r0, r4, #0
 8001f0e:	f7fe fb27 	bl	8000560 <chThdSetPriority>
 8001f12:	1c07      	adds	r7, r0, #0
    test_assert(p1 == prio, "unexpected returned priority level");
 8001f14:	1b40      	subs	r0, r0, r5
 8001f16:	4243      	negs	r3, r0
 8001f18:	4158      	adcs	r0, r3
 8001f1a:	4b1b      	ldr	r3, [pc, #108]	; (8001f88 <rt_test_003_003_execute.lto_priv.82+0x98>)
 8001f1c:	b2c0      	uxtb	r0, r0
 8001f1e:	1c19      	adds	r1, r3, #0
 8001f20:	4699      	mov	r9, r3
 8001f22:	f001 ffed 	bl	8003f00 <_test_assert>
 8001f26:	2800      	cmp	r0, #0
 8001f28:	d004      	beq.n	8001f34 <rt_test_003_003_execute.lto_priv.82+0x44>
  {
    p1 = chThdSetPriority(p1);
    test_assert(p1 == prio + 1, "unexpected returned priority level");
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
  }
}
 8001f2a:	bc1c      	pop	{r2, r3, r4}
 8001f2c:	4690      	mov	r8, r2
 8001f2e:	4699      	mov	r9, r3
 8001f30:	46a2      	mov	sl, r4
 8001f32:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001f34:	69b3      	ldr	r3, [r6, #24]
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
    test_assert(p1 == prio, "unexpected returned priority level");
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 8001f36:	6898      	ldr	r0, [r3, #8]
 8001f38:	1a20      	subs	r0, r4, r0
 8001f3a:	4243      	negs	r3, r0
 8001f3c:	4158      	adcs	r0, r3
 8001f3e:	4b13      	ldr	r3, [pc, #76]	; (8001f8c <rt_test_003_003_execute.lto_priv.82+0x9c>)
 8001f40:	b2c0      	uxtb	r0, r0
 8001f42:	1c19      	adds	r1, r3, #0
 8001f44:	469a      	mov	sl, r3
 8001f46:	f001 ffdb 	bl	8003f00 <_test_assert>
 8001f4a:	2800      	cmp	r0, #0
 8001f4c:	d1ed      	bne.n	8001f2a <rt_test_003_003_execute.lto_priv.82+0x3a>
  }

  /* [3.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 8001f4e:	2302      	movs	r3, #2
 8001f50:	4642      	mov	r2, r8
  {
    p1 = chThdSetPriority(p1);
 8001f52:	1c38      	adds	r0, r7, #0
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
  }

  /* [3.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 8001f54:	6013      	str	r3, [r2, #0]
  {
    p1 = chThdSetPriority(p1);
 8001f56:	f7fe fb03 	bl	8000560 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8001f5a:	1a20      	subs	r0, r4, r0
 8001f5c:	4244      	negs	r4, r0
 8001f5e:	4160      	adcs	r0, r4
 8001f60:	4649      	mov	r1, r9
 8001f62:	b2c0      	uxtb	r0, r0
 8001f64:	f001 ffcc 	bl	8003f00 <_test_assert>
 8001f68:	2800      	cmp	r0, #0
 8001f6a:	d1de      	bne.n	8001f2a <rt_test_003_003_execute.lto_priv.82+0x3a>
 8001f6c:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8001f6e:	4651      	mov	r1, sl
 8001f70:	6898      	ldr	r0, [r3, #8]
 8001f72:	1a28      	subs	r0, r5, r0
 8001f74:	4245      	negs	r5, r0
 8001f76:	4168      	adcs	r0, r5
 8001f78:	b2c0      	uxtb	r0, r0
 8001f7a:	f001 ffc1 	bl	8003f00 <_test_assert>
 8001f7e:	e7d4      	b.n	8001f2a <rt_test_003_003_execute.lto_priv.82+0x3a>
 8001f80:	20000d64 	.word	0x20000d64
 8001f84:	20000e84 	.word	0x20000e84
 8001f88:	080055c8 	.word	0x080055c8
 8001f8c:	080055ec 	.word	0x080055ec

08001f90 <rt_test_010_007_setup.lto_priv.137>:
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 8001f90:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001f92:	4b02      	ldr	r3, [pc, #8]	; (8001f9c <rt_test_010_007_setup.lto_priv.137+0xc>)
 8001f94:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001f96:	605b      	str	r3, [r3, #4]
 8001f98:	609a      	str	r2, [r3, #8]
 * .
 */

static void rt_test_010_007_setup(void) {
  chSemObjectInit(&sem1, 0);
}
 8001f9a:	4770      	bx	lr
 8001f9c:	20000e68 	.word	0x20000e68

08001fa0 <tmo.lto_priv.61>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static void tmo(void *param) {(void)param;}
 8001fa0:	4770      	bx	lr
 8001fa2:	46c0      	nop			; (mov r8, r8)
 8001fa4:	46c0      	nop			; (mov r8, r8)
 8001fa6:	46c0      	nop			; (mov r8, r8)
 8001fa8:	46c0      	nop			; (mov r8, r8)
 8001faa:	46c0      	nop			; (mov r8, r8)
 8001fac:	46c0      	nop			; (mov r8, r8)
 8001fae:	46c0      	nop			; (mov r8, r8)

08001fb0 <rt_test_009_002_setup.lto_priv.129>:
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 8001fb0:	21a4      	movs	r1, #164	; 0xa4
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8001fb2:	2200      	movs	r2, #0
 8001fb4:	4b04      	ldr	r3, [pc, #16]	; (8001fc8 <rt_test_009_002_setup.lto_priv.129+0x18>)
  mp->object_size = size;
 8001fb6:	0049      	lsls	r1, r1, #1
 8001fb8:	6059      	str	r1, [r3, #4]
  mp->align = align;
 8001fba:	3945      	subs	r1, #69	; 0x45
 8001fbc:	39ff      	subs	r1, #255	; 0xff
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8001fbe:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
  mp->align = align;
 8001fc0:	6099      	str	r1, [r3, #8]
  mp->provider = provider;
 8001fc2:	60da      	str	r2, [r3, #12]
 * .
 */

static void rt_test_009_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
 8001fc4:	4770      	bx	lr
 8001fc6:	46c0      	nop			; (mov r8, r8)
 8001fc8:	20000f00 	.word	0x20000f00
 8001fcc:	46c0      	nop			; (mov r8, r8)
 8001fce:	46c0      	nop			; (mov r8, r8)

08001fd0 <rt_test_009_001_setup.lto_priv.127>:
 *   freeing memory.
 * - [9.1.7] Getting heap info again for verification.
 * .
 */

static void rt_test_009_001_setup(void) {
 8001fd0:	b510      	push	{r4, lr}
  /* Initializing the heap header.*/
  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8001fd2:	24cc      	movs	r4, #204	; 0xcc
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 8001fd4:	2207      	movs	r2, #7
  /* Initializing the heap header.*/
  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8001fd6:	00e4      	lsls	r4, r4, #3
 8001fd8:	46a4      	mov	ip, r4
  /*lint -save -e9033 [10.8] Required cast operations.*/
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
  /*lint restore*/

  /* Initializing the heap header.*/
  heapp->provider = NULL;
 8001fda:	2000      	movs	r0, #0
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  heap_header_t *hp = (heap_header_t *)MEM_ALIGN_NEXT(buf, CH_HEAP_ALIGNMENT);
 8001fdc:	4b08      	ldr	r3, [pc, #32]	; (8002000 <rt_test_009_001_setup.lto_priv.127+0x30>)
 8001fde:	1dd9      	adds	r1, r3, #7
 8001fe0:	4391      	bics	r1, r2
  chDbgCheck((heapp != NULL) && (size > 0U));

  /* Adjusting the size in case the initial block was not correctly
     aligned.*/
  /*lint -save -e9033 [10.8] Required cast operations.*/
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
 8001fe2:	1a5b      	subs	r3, r3, r1
  /*lint restore*/

  /* Initializing the heap header.*/
  heapp->provider = NULL;
 8001fe4:	4a07      	ldr	r2, [pc, #28]	; (8002004 <rt_test_009_001_setup.lto_priv.127+0x34>)
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8001fe6:	4463      	add	r3, ip
 8001fe8:	08db      	lsrs	r3, r3, #3
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
  /*lint restore*/

  /* Initializing the heap header.*/
  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 8001fea:	6051      	str	r1, [r2, #4]
  H_PAGES(&heapp->header) = 0;
 8001fec:	6090      	str	r0, [r2, #8]
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8001fee:	604b      	str	r3, [r1, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001ff0:	1c13      	adds	r3, r2, #0
 8001ff2:	330c      	adds	r3, #12
  /*lint -save -e9033 [10.8] Required cast operations.*/
  size -= (size_t)((uint8_t *)hp - (uint8_t *)buf);
  /*lint restore*/

  /* Initializing the heap header.*/
  heapp->provider = NULL;
 8001ff4:	6010      	str	r0, [r2, #0]
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
 8001ff6:	6008      	str	r0, [r1, #0]
 8001ff8:	60d3      	str	r3, [r2, #12]
  tqp->prev = (thread_t *)tqp;
 8001ffa:	6113      	str	r3, [r2, #16]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8001ffc:	6150      	str	r0, [r2, #20]
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}
 8001ffe:	bd10      	pop	{r4, pc}
 8002000:	200006e8 	.word	0x200006e8
 8002004:	20000f3c 	.word	0x20000f3c
 8002008:	46c0      	nop			; (mov r8, r8)
 800200a:	46c0      	nop			; (mov r8, r8)
 800200c:	46c0      	nop			; (mov r8, r8)
 800200e:	46c0      	nop			; (mov r8, r8)

08002010 <rt_test_010_007_execute.lto_priv.138>:

static void rt_test_010_007_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void rt_test_010_007_execute(void) {
 8002010:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;

  /* [10.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 8002012:	4b3c      	ldr	r3, [pc, #240]	; (8002104 <rt_test_010_007_execute.lto_priv.138+0xf4>)

static void rt_test_010_007_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void rt_test_010_007_execute(void) {
 8002014:	464f      	mov	r7, r9
  uint32_t n;

  /* [10.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 8002016:	4699      	mov	r9, r3

static void rt_test_010_007_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void rt_test_010_007_execute(void) {
 8002018:	4646      	mov	r6, r8
  uint32_t n;

  /* [10.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 800201a:	2301      	movs	r3, #1
 800201c:	464a      	mov	r2, r9

static void rt_test_010_007_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void rt_test_010_007_execute(void) {
 800201e:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002020:	4f39      	ldr	r7, [pc, #228]	; (8002108 <rt_test_010_007_execute.lto_priv.138+0xf8>)
  uint32_t n;

  /* [10.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 8002022:	6013      	str	r3, [r2, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002024:	69bb      	ldr	r3, [r7, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8002026:	4c39      	ldr	r4, [pc, #228]	; (800210c <rt_test_010_007_execute.lto_priv.138+0xfc>)
 8002028:	4e39      	ldr	r6, [pc, #228]	; (8002110 <rt_test_010_007_execute.lto_priv.138+0x100>)
 800202a:	6899      	ldr	r1, [r3, #8]
 800202c:	1c32      	adds	r2, r6, #0
 800202e:	3105      	adds	r1, #5
 8002030:	1c20      	adds	r0, r4, #0
 8002032:	2300      	movs	r3, #0
 8002034:	f002 ff64 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8002038:	4d36      	ldr	r5, [pc, #216]	; (8002114 <rt_test_010_007_execute.lto_priv.138+0x104>)
 800203a:	69bb      	ldr	r3, [r7, #24]
 800203c:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 800203e:	1c20      	adds	r0, r4, #0
 8002040:	6899      	ldr	r1, [r3, #8]
 8002042:	3049      	adds	r0, #73	; 0x49
 8002044:	1c32      	adds	r2, r6, #0
 8002046:	3104      	adds	r1, #4
 8002048:	2300      	movs	r3, #0
 800204a:	30ff      	adds	r0, #255	; 0xff
 800204c:	f002 ff58 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 8002050:	23a4      	movs	r3, #164	; 0xa4
 8002052:	009b      	lsls	r3, r3, #2
  /* [10.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 8002054:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 8002056:	18e0      	adds	r0, r4, r3
 8002058:	69bb      	ldr	r3, [r7, #24]
 800205a:	1c32      	adds	r2, r6, #0
 800205c:	6899      	ldr	r1, [r3, #8]
 800205e:	2300      	movs	r3, #0
 8002060:	3103      	adds	r1, #3
 8002062:	f002 ff4d 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 8002066:	23f6      	movs	r3, #246	; 0xf6
 8002068:	009b      	lsls	r3, r3, #2
     immediately enqueue on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 800206a:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 800206c:	18e0      	adds	r0, r4, r3
 800206e:	69bb      	ldr	r3, [r7, #24]
 8002070:	1c32      	adds	r2, r6, #0
 8002072:	6899      	ldr	r1, [r3, #8]
 8002074:	2300      	movs	r3, #0
 8002076:	3102      	adds	r1, #2
 8002078:	f002 ff42 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 800207c:	23a4      	movs	r3, #164	; 0xa4
 800207e:	00db      	lsls	r3, r3, #3
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 8002080:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 8002082:	18e0      	adds	r0, r4, r3
 8002084:	69bb      	ldr	r3, [r7, #24]
 8002086:	1c32      	adds	r2, r6, #0
 8002088:	6899      	ldr	r1, [r3, #8]
 800208a:	2300      	movs	r3, #0
 800208c:	3101      	adds	r1, #1
 800208e:	f002 ff37 	bl	8004f00 <chThdCreateStatic.constprop.40>
  }

  /* [10.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 8002092:	2302      	movs	r3, #2
 8002094:	464a      	mov	r2, r9
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 8002096:	6128      	str	r0, [r5, #16]
  }

  /* [10.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 8002098:	6013      	str	r3, [r2, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 800209a:	f001 fc21 	bl	80038e0 <test_wait_tick>
 800209e:	2780      	movs	r7, #128	; 0x80
 80020a0:	4680      	mov	r8, r0
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
 80020a2:	2400      	movs	r4, #0
 80020a4:	4d1c      	ldr	r5, [pc, #112]	; (8002118 <rt_test_010_007_execute.lto_priv.138+0x108>)
      chSemReset(&sem1, 0);
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80020a6:	4e1d      	ldr	r6, [pc, #116]	; (800211c <rt_test_010_007_execute.lto_priv.138+0x10c>)
 80020a8:	05ff      	lsls	r7, r7, #23

    n = 0;
    start = test_wait_tick();
    end = chTimeAddX(start, TIME_MS2I(1000));
    do {
      chSemReset(&sem1, 0);
 80020aa:	1c28      	adds	r0, r5, #0
 80020ac:	2100      	movs	r1, #0
 80020ae:	f7fe fc67 	bl	8000980 <chSemReset>
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((time - start) < (end - start));
 80020b2:	4642      	mov	r2, r8
 80020b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      n++;
 80020b6:	3401      	adds	r4, #1
 80020b8:	1a9b      	subs	r3, r3, r2
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80020ba:	42b3      	cmp	r3, r6
 80020bc:	d9f5      	bls.n	80020aa <rt_test_010_007_execute.lto_priv.138+0x9a>
  }

  /* [10.7.3] The five threads are terminated.*/
  test_set_step(3);
 80020be:	464a      	mov	r2, r9
 80020c0:	2303      	movs	r3, #3
 80020c2:	6013      	str	r3, [r2, #0]
  {
    test_terminate_threads();
 80020c4:	f001 fc34 	bl	8003930 <test_terminate_threads>
    chSemReset(&sem1, 0);
 80020c8:	2100      	movs	r1, #0
 80020ca:	1c28      	adds	r0, r5, #0
 80020cc:	f7fe fc58 	bl	8000980 <chSemReset>
    test_wait_threads();
 80020d0:	f001 fc16 	bl	8003900 <test_wait_threads>
  }

  /* [10.7.4] The score is printed.*/
  test_set_step(4);
 80020d4:	464a      	mov	r2, r9
 80020d6:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 80020d8:	4811      	ldr	r0, [pc, #68]	; (8002120 <rt_test_010_007_execute.lto_priv.138+0x110>)
    chSemReset(&sem1, 0);
    test_wait_threads();
  }

  /* [10.7.4] The score is printed.*/
  test_set_step(4);
 80020da:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 80020dc:	f001 fc70 	bl	80039c0 <test_print>
    test_printn(n);
 80020e0:	1c20      	adds	r0, r4, #0
 80020e2:	f001 fbcd 	bl	8003880 <test_printn>
    test_print(" reschedules/S, ");
 80020e6:	480f      	ldr	r0, [pc, #60]	; (8002124 <rt_test_010_007_execute.lto_priv.138+0x114>)
 80020e8:	f001 fc6a 	bl	80039c0 <test_print>
    test_printn(n * 6);
 80020ec:	0060      	lsls	r0, r4, #1
 80020ee:	1900      	adds	r0, r0, r4
 80020f0:	0040      	lsls	r0, r0, #1
 80020f2:	f001 fbc5 	bl	8003880 <test_printn>
    test_println(" ctxswc/S");
 80020f6:	480c      	ldr	r0, [pc, #48]	; (8002128 <rt_test_010_007_execute.lto_priv.138+0x118>)
 80020f8:	f001 fc42 	bl	8003980 <test_println>
  }
}
 80020fc:	bc0c      	pop	{r2, r3}
 80020fe:	4690      	mov	r8, r2
 8002100:	4699      	mov	r9, r3
 8002102:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002104:	20000d64 	.word	0x20000d64
 8002108:	20000e84 	.word	0x20000e84
 800210c:	200006e8 	.word	0x200006e8
 8002110:	08002131 	.word	0x08002131
 8002114:	20000d68 	.word	0x20000d68
 8002118:	20000e68 	.word	0x20000e68
 800211c:	0000270f 	.word	0x0000270f
 8002120:	08005650 	.word	0x08005650
 8002124:	08005660 	.word	0x08005660
 8002128:	08005674 	.word	0x08005674
 800212c:	46c0      	nop			; (mov r8, r8)
 800212e:	46c0      	nop			; (mov r8, r8)

08002130 <bmk_thread7>:
  } while (msg == MSG_OK);
  chSysUnlock();
}

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {
 8002130:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8002132:	2321      	movs	r3, #33	; 0x21
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002134:	4c07      	ldr	r4, [pc, #28]	; (8002154 <bmk_thread7+0x24>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8002136:	69a2      	ldr	r2, [r4, #24]
 8002138:	5cd3      	ldrb	r3, [r2, r3]

  (void)p;
  while (!chThdShouldTerminateX())
 800213a:	075b      	lsls	r3, r3, #29
 800213c:	d409      	bmi.n	8002152 <bmk_thread7+0x22>
 800213e:	2621      	movs	r6, #33	; 0x21
 8002140:	2504      	movs	r5, #4
 8002142:	4f05      	ldr	r7, [pc, #20]	; (8002158 <bmk_thread7+0x28>)
    chSemWait(&sem1);
 8002144:	1c38      	adds	r0, r7, #0
 8002146:	f7fe fa83 	bl	8000650 <chSemWait>
 800214a:	69a3      	ldr	r3, [r4, #24]
 800214c:	5d9b      	ldrb	r3, [r3, r6]

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 800214e:	421d      	tst	r5, r3
 8002150:	d0f8      	beq.n	8002144 <bmk_thread7+0x14>
    chSemWait(&sem1);
}
 8002152:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002154:	20000e84 	.word	0x20000e84
 8002158:	20000e68 	.word	0x20000e68
 800215c:	46c0      	nop			; (mov r8, r8)
 800215e:	46c0      	nop			; (mov r8, r8)

08002160 <rt_test_010_006_execute.lto_priv.136>:
 *   one-second time window.
 * - [10.6.2] Score is printed.
 * .
 */

static void rt_test_010_006_execute(void) {
 8002160:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002162:	465f      	mov	r7, fp
 8002164:	4656      	mov	r6, sl
 8002166:	464d      	mov	r5, r9
 8002168:	4644      	mov	r4, r8
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800216a:	4b1a      	ldr	r3, [pc, #104]	; (80021d4 <rt_test_010_006_execute.lto_priv.136+0x74>)
 800216c:	b4f0      	push	{r4, r5, r6, r7}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800216e:	699b      	ldr	r3, [r3, #24]
 8002170:	2780      	movs	r7, #128	; 0x80
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 8002172:	689d      	ldr	r5, [r3, #8]
  systime_t start, end;

  /* [10.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8002174:	4b18      	ldr	r3, [pc, #96]	; (80021d8 <rt_test_010_006_execute.lto_priv.136+0x78>)
  {
    n = 0;
 8002176:	2400      	movs	r4, #0
  systime_t start, end;

  /* [10.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8002178:	469b      	mov	fp, r3
 800217a:	2301      	movs	r3, #1
 800217c:	465a      	mov	r2, fp
 800217e:	6013      	str	r3, [r2, #0]
  {
    n = 0;
    start = test_wait_tick();
 8002180:	f001 fbae 	bl	80038e0 <test_wait_tick>
 8002184:	4b15      	ldr	r3, [pc, #84]	; (80021dc <rt_test_010_006_execute.lto_priv.136+0x7c>)
 8002186:	4682      	mov	sl, r0
 8002188:	4699      	mov	r9, r3
 800218a:	4b15      	ldr	r3, [pc, #84]	; (80021e0 <rt_test_010_006_execute.lto_priv.136+0x80>)
#endif
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800218c:	4e15      	ldr	r6, [pc, #84]	; (80021e4 <rt_test_010_006_execute.lto_priv.136+0x84>)
 800218e:	4698      	mov	r8, r3
 * .
 */

static void rt_test_010_006_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 8002190:	3501      	adds	r5, #1
 8002192:	05ff      	lsls	r7, r7, #23
    n = 0;
    start = test_wait_tick();
    end = chTimeAddX(start, TIME_MS2I(1000));
    do {
#if CH_CFG_USE_REGISTRY
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8002194:	4642      	mov	r2, r8
 8002196:	2300      	movs	r3, #0
 8002198:	1c29      	adds	r1, r5, #0
 800219a:	4648      	mov	r0, r9
 800219c:	f002 feb0 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80021a0:	f7fe fb56 	bl	8000850 <chThdRelease>
 80021a4:	4652      	mov	r2, sl
 80021a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
#else
      chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL);
#endif
      n++;
 80021a8:	3401      	adds	r4, #1
 80021aa:	1a9b      	subs	r3, r3, r2
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80021ac:	42b3      	cmp	r3, r6
 80021ae:	d9f1      	bls.n	8002194 <rt_test_010_006_execute.lto_priv.136+0x34>
  }

  /* [10.6.2] Score is printed.*/
  test_set_step(2);
 80021b0:	465a      	mov	r2, fp
 80021b2:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 80021b4:	480c      	ldr	r0, [pc, #48]	; (80021e8 <rt_test_010_006_execute.lto_priv.136+0x88>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [10.6.2] Score is printed.*/
  test_set_step(2);
 80021b6:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 80021b8:	f001 fc02 	bl	80039c0 <test_print>
    test_printn(n);
 80021bc:	1c20      	adds	r0, r4, #0
 80021be:	f001 fb5f 	bl	8003880 <test_printn>
    test_println(" threads/S");
 80021c2:	480a      	ldr	r0, [pc, #40]	; (80021ec <rt_test_010_006_execute.lto_priv.136+0x8c>)
 80021c4:	f001 fbdc 	bl	8003980 <test_println>
  }
}
 80021c8:	bc3c      	pop	{r2, r3, r4, r5}
 80021ca:	4690      	mov	r8, r2
 80021cc:	4699      	mov	r9, r3
 80021ce:	46a2      	mov	sl, r4
 80021d0:	46ab      	mov	fp, r5
 80021d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80021d4:	20000e84 	.word	0x20000e84
 80021d8:	20000d64 	.word	0x20000d64
 80021dc:	200006e8 	.word	0x200006e8
 80021e0:	08002c51 	.word	0x08002c51
 80021e4:	0000270f 	.word	0x0000270f
 80021e8:	08005650 	.word	0x08005650
 80021ec:	08005680 	.word	0x08005680

080021f0 <rt_test_010_005_execute.lto_priv.135>:
 *   repeated continuously in a one-second time window.
 * - [10.5.2] Score is printed.
 * .
 */

static void rt_test_010_005_execute(void) {
 80021f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80021f2:	465f      	mov	r7, fp
 80021f4:	4656      	mov	r6, sl
 80021f6:	464d      	mov	r5, r9
 80021f8:	4644      	mov	r4, r8
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80021fa:	4b1a      	ldr	r3, [pc, #104]	; (8002264 <rt_test_010_005_execute.lto_priv.135+0x74>)
 80021fc:	b4f0      	push	{r4, r5, r6, r7}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80021fe:	699b      	ldr	r3, [r3, #24]
 8002200:	2780      	movs	r7, #128	; 0x80
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 8002202:	689d      	ldr	r5, [r3, #8]
  systime_t start, end;

  /* [10.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002204:	4b18      	ldr	r3, [pc, #96]	; (8002268 <rt_test_010_005_execute.lto_priv.135+0x78>)
  {
    n = 0;
 8002206:	2400      	movs	r4, #0
  systime_t start, end;

  /* [10.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002208:	469b      	mov	fp, r3
 800220a:	2301      	movs	r3, #1
 800220c:	465a      	mov	r2, fp
 800220e:	6013      	str	r3, [r2, #0]
  {
    n = 0;
    start = test_wait_tick();
 8002210:	f001 fb66 	bl	80038e0 <test_wait_tick>
 8002214:	4b15      	ldr	r3, [pc, #84]	; (800226c <rt_test_010_005_execute.lto_priv.135+0x7c>)
 8002216:	4682      	mov	sl, r0
 8002218:	4699      	mov	r9, r3
 800221a:	4b15      	ldr	r3, [pc, #84]	; (8002270 <rt_test_010_005_execute.lto_priv.135+0x80>)
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800221c:	4e15      	ldr	r6, [pc, #84]	; (8002274 <rt_test_010_005_execute.lto_priv.135+0x84>)
 800221e:	4698      	mov	r8, r3
 * .
 */

static void rt_test_010_005_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 8002220:	3d01      	subs	r5, #1
 8002222:	05ff      	lsls	r7, r7, #23
  {
    n = 0;
    start = test_wait_tick();
    end = chTimeAddX(start, TIME_MS2I(1000));
    do {
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8002224:	4642      	mov	r2, r8
 8002226:	2300      	movs	r3, #0
 8002228:	1c29      	adds	r1, r5, #0
 800222a:	4648      	mov	r0, r9
 800222c:	f002 fe68 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8002230:	f7fe fb76 	bl	8000920 <chThdWait>
 8002234:	4652      	mov	r2, sl
 8002236:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      n++;
 8002238:	3401      	adds	r4, #1
 800223a:	1a9b      	subs	r3, r3, r2
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800223c:	42b3      	cmp	r3, r6
 800223e:	d9f1      	bls.n	8002224 <rt_test_010_005_execute.lto_priv.135+0x34>
  }

  /* [10.5.2] Score is printed.*/
  test_set_step(2);
 8002240:	465a      	mov	r2, fp
 8002242:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 8002244:	480c      	ldr	r0, [pc, #48]	; (8002278 <rt_test_010_005_execute.lto_priv.135+0x88>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [10.5.2] Score is printed.*/
  test_set_step(2);
 8002246:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 8002248:	f001 fbba 	bl	80039c0 <test_print>
    test_printn(n);
 800224c:	1c20      	adds	r0, r4, #0
 800224e:	f001 fb17 	bl	8003880 <test_printn>
    test_println(" threads/S");
 8002252:	480a      	ldr	r0, [pc, #40]	; (800227c <rt_test_010_005_execute.lto_priv.135+0x8c>)
 8002254:	f001 fb94 	bl	8003980 <test_println>
  }
}
 8002258:	bc3c      	pop	{r2, r3, r4, r5}
 800225a:	4690      	mov	r8, r2
 800225c:	4699      	mov	r9, r3
 800225e:	46a2      	mov	sl, r4
 8002260:	46ab      	mov	fp, r5
 8002262:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002264:	20000e84 	.word	0x20000e84
 8002268:	20000d64 	.word	0x20000d64
 800226c:	200006e8 	.word	0x200006e8
 8002270:	08002c51 	.word	0x08002c51
 8002274:	0000270f 	.word	0x0000270f
 8002278:	08005650 	.word	0x08005650
 800227c:	08005680 	.word	0x08005680

08002280 <rt_test_010_004_execute.lto_priv.134>:
 * - [10.4.3] Stopping the target thread.
 * - [10.4.4] Score is printed.
 * .
 */

static void rt_test_010_004_execute(void) {
 8002280:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *tp;
  uint32_t n;

  /* [10.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 8002282:	4b29      	ldr	r3, [pc, #164]	; (8002328 <rt_test_010_004_execute.lto_priv.134+0xa8>)
 * - [10.4.3] Stopping the target thread.
 * - [10.4.4] Score is printed.
 * .
 */

static void rt_test_010_004_execute(void) {
 8002284:	464f      	mov	r7, r9
  thread_t *tp;
  uint32_t n;

  /* [10.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 8002286:	4699      	mov	r9, r3
 * - [10.4.3] Stopping the target thread.
 * - [10.4.4] Score is printed.
 * .
 */

static void rt_test_010_004_execute(void) {
 8002288:	4646      	mov	r6, r8
  thread_t *tp;
  uint32_t n;

  /* [10.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 800228a:	2301      	movs	r3, #1
 800228c:	464a      	mov	r2, r9
 * - [10.4.3] Stopping the target thread.
 * - [10.4.4] Score is printed.
 * .
 */

static void rt_test_010_004_execute(void) {
 800228e:	b4c0      	push	{r6, r7}
  thread_t *tp;
  uint32_t n;

  /* [10.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 8002290:	6013      	str	r3, [r2, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002292:	4b26      	ldr	r3, [pc, #152]	; (800232c <rt_test_010_004_execute.lto_priv.134+0xac>)
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8002294:	4a26      	ldr	r2, [pc, #152]	; (8002330 <rt_test_010_004_execute.lto_priv.134+0xb0>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002296:	699b      	ldr	r3, [r3, #24]
 8002298:	4826      	ldr	r0, [pc, #152]	; (8002334 <rt_test_010_004_execute.lto_priv.134+0xb4>)
 800229a:	6899      	ldr	r1, [r3, #8]
 800229c:	2300      	movs	r3, #0
 800229e:	3101      	adds	r1, #1
 80022a0:	f002 fe2e 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80022a4:	4b24      	ldr	r3, [pc, #144]	; (8002338 <rt_test_010_004_execute.lto_priv.134+0xb8>)
                                        bmk_thread4, NULL);
  }

  /* [10.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 80022a6:	464a      	mov	r2, r9
  uint32_t n;

  /* [10.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80022a8:	6018      	str	r0, [r3, #0]
                                        bmk_thread4, NULL);
  }

  /* [10.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 80022aa:	2302      	movs	r3, #2
  uint32_t n;

  /* [10.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80022ac:	1c04      	adds	r4, r0, #0
                                        bmk_thread4, NULL);
  }

  /* [10.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 80022ae:	6013      	str	r3, [r2, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 80022b0:	f001 fb16 	bl	80038e0 <test_wait_tick>
 80022b4:	2780      	movs	r7, #128	; 0x80
 80022b6:	4680      	mov	r8, r0
     time window.*/
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
 80022b8:	2500      	movs	r5, #0
      chSysUnlock();
      n += 4;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80022ba:	4e20      	ldr	r6, [pc, #128]	; (800233c <rt_test_010_004_execute.lto_priv.134+0xbc>)
 80022bc:	05ff      	lsls	r7, r7, #23
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80022be:	b672      	cpsid	i
    n = 0;
    start = test_wait_tick();
    end = chTimeAddX(start, TIME_MS2I(1000));
    do {
      chSysLock();
      chSchWakeupS(tp, MSG_OK);
 80022c0:	2100      	movs	r1, #0
 80022c2:	1c20      	adds	r0, r4, #0
 80022c4:	f7fe f964 	bl	8000590 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 80022c8:	1c20      	adds	r0, r4, #0
 80022ca:	2100      	movs	r1, #0
 80022cc:	f7fe f960 	bl	8000590 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 80022d0:	1c20      	adds	r0, r4, #0
 80022d2:	2100      	movs	r1, #0
 80022d4:	f7fe f95c 	bl	8000590 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 80022d8:	1c20      	adds	r0, r4, #0
 80022da:	2100      	movs	r1, #0
 80022dc:	f7fe f958 	bl	8000590 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80022e0:	b662      	cpsie	i
 80022e2:	4642      	mov	r2, r8
 80022e4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      chSysUnlock();
      n += 4;
 80022e6:	3504      	adds	r5, #4
 80022e8:	1a9b      	subs	r3, r3, r2
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80022ea:	42b3      	cmp	r3, r6
 80022ec:	d9e7      	bls.n	80022be <rt_test_010_004_execute.lto_priv.134+0x3e>
  }

  /* [10.4.3] Stopping the target thread.*/
  test_set_step(3);
 80022ee:	2303      	movs	r3, #3
 80022f0:	464a      	mov	r2, r9
 80022f2:	6013      	str	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80022f4:	b672      	cpsid	i
  {
    chSysLock();
    chSchWakeupS(tp, MSG_TIMEOUT);
 80022f6:	2101      	movs	r1, #1
 80022f8:	1c20      	adds	r0, r4, #0
 80022fa:	4249      	negs	r1, r1
 80022fc:	f7fe f948 	bl	8000590 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002300:	b662      	cpsie	i
    chSysUnlock();
    test_wait_threads();
 8002302:	f001 fafd 	bl	8003900 <test_wait_threads>
  }

  /* [10.4.4] Score is printed.*/
  test_set_step(4);
 8002306:	464a      	mov	r2, r9
 8002308:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 800230a:	480d      	ldr	r0, [pc, #52]	; (8002340 <rt_test_010_004_execute.lto_priv.134+0xc0>)
    chSysUnlock();
    test_wait_threads();
  }

  /* [10.4.4] Score is printed.*/
  test_set_step(4);
 800230c:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 800230e:	f001 fb57 	bl	80039c0 <test_print>
    test_printn(n * 2);
 8002312:	0068      	lsls	r0, r5, #1
 8002314:	f001 fab4 	bl	8003880 <test_printn>
    test_println(" ctxswc/S");
 8002318:	480a      	ldr	r0, [pc, #40]	; (8002344 <rt_test_010_004_execute.lto_priv.134+0xc4>)
 800231a:	f001 fb31 	bl	8003980 <test_println>
  }
}
 800231e:	bc0c      	pop	{r2, r3}
 8002320:	4690      	mov	r8, r2
 8002322:	4699      	mov	r9, r3
 8002324:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002326:	46c0      	nop			; (mov r8, r8)
 8002328:	20000d64 	.word	0x20000d64
 800232c:	20000e84 	.word	0x20000e84
 8002330:	08002351 	.word	0x08002351
 8002334:	200006e8 	.word	0x200006e8
 8002338:	20000d68 	.word	0x20000d68
 800233c:	0000270f 	.word	0x0000270f
 8002340:	08005650 	.word	0x08005650
 8002344:	08005674 	.word	0x08005674
 8002348:	46c0      	nop			; (mov r8, r8)
 800234a:	46c0      	nop			; (mov r8, r8)
 800234c:	46c0      	nop			; (mov r8, r8)
 800234e:	46c0      	nop			; (mov r8, r8)

08002350 <bmk_thread4>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002350:	4b05      	ldr	r3, [pc, #20]	; (8002368 <bmk_thread4+0x18>)
static THD_FUNCTION(bmk_thread3, p) {

  chThdExit((msg_t)p);
}

static THD_FUNCTION(bmk_thread4, p) {
 8002352:	b510      	push	{r4, lr}
 8002354:	699c      	ldr	r4, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002356:	b672      	cpsid	i
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8002358:	2003      	movs	r0, #3
 800235a:	f7fe f961 	bl	8000620 <chSchGoSleepS>
    msg = self->u.rdymsg;
  } while (msg == MSG_OK);
 800235e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002360:	2b00      	cmp	r3, #0
 8002362:	d0f9      	beq.n	8002358 <bmk_thread4+0x8>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002364:	b662      	cpsie	i
  chSysUnlock();
}
 8002366:	bd10      	pop	{r4, pc}
 8002368:	20000e84 	.word	0x20000e84
 800236c:	46c0      	nop			; (mov r8, r8)
 800236e:	46c0      	nop			; (mov r8, r8)

08002370 <bmk_thread1>:
#endif

static void tmo(void *param) {(void)param;}

#if CH_CFG_USE_MESSAGES
static THD_FUNCTION(bmk_thread1, p) {
 8002370:	b510      	push	{r4, lr}
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8002372:	f001 febd 	bl	80040f0 <chMsgWait>
 8002376:	6a44      	ldr	r4, [r0, #36]	; 0x24
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002378:	b672      	cpsid	i
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 800237a:	1c21      	adds	r1, r4, #0
 800237c:	f7fe f908 	bl	8000590 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002380:	b662      	cpsie	i
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
 8002382:	2c00      	cmp	r4, #0
 8002384:	d1f5      	bne.n	8002372 <bmk_thread1+0x2>
}
 8002386:	bd10      	pop	{r4, pc}
 8002388:	46c0      	nop			; (mov r8, r8)
 800238a:	46c0      	nop			; (mov r8, r8)
 800238c:	46c0      	nop			; (mov r8, r8)
 800238e:	46c0      	nop			; (mov r8, r8)

08002390 <bmk_thread8.lto_priv.62>:
  while (!chThdShouldTerminateX())
    chSemWait(&sem1);
}
#endif

static THD_FUNCTION(bmk_thread8, p) {
 8002390:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002392:	1c04      	adds	r4, r0, #0
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8002394:	2621      	movs	r6, #33	; 0x21
 8002396:	2504      	movs	r5, #4
 8002398:	4f08      	ldr	r7, [pc, #32]	; (80023bc <bmk_thread8.lto_priv.62+0x2c>)

  do {
    chThdYield();
 800239a:	f7fe f839 	bl	8000410 <chThdYield>
    chThdYield();
 800239e:	f7fe f837 	bl	8000410 <chThdYield>
    chThdYield();
 80023a2:	f7fe f835 	bl	8000410 <chThdYield>
    chThdYield();
 80023a6:	f7fe f833 	bl	8000410 <chThdYield>
    (*(uint32_t *)p) += 4;
 80023aa:	6823      	ldr	r3, [r4, #0]
 80023ac:	3304      	adds	r3, #4
 80023ae:	6023      	str	r3, [r4, #0]
 80023b0:	69bb      	ldr	r3, [r7, #24]
 80023b2:	5d9b      	ldrb	r3, [r3, r6]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 80023b4:	421d      	tst	r5, r3
 80023b6:	d0f0      	beq.n	800239a <bmk_thread8.lto_priv.62+0xa>
}
 80023b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80023ba:	46c0      	nop			; (mov r8, r8)
 80023bc:	20000e84 	.word	0x20000e84

080023c0 <msg_loop_test>:
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
}

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 80023c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80023c2:	4647      	mov	r7, r8
 80023c4:	b480      	push	{r7}
 80023c6:	1c05      	adds	r5, r0, #0
  systime_t start, end;

  uint32_t n = 0;
  start = test_wait_tick();
 80023c8:	f001 fa8a 	bl	80038e0 <test_wait_tick>
 80023cc:	2780      	movs	r7, #128	; 0x80
 80023ce:	4680      	mov	r8, r0
}

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
  systime_t start, end;

  uint32_t n = 0;
 80023d0:	2400      	movs	r4, #0
    (void)chMsgSend(tp, 1);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 80023d2:	4e0a      	ldr	r6, [pc, #40]	; (80023fc <msg_loop_test+0x3c>)
 80023d4:	05ff      	lsls	r7, r7, #23

  uint32_t n = 0;
  start = test_wait_tick();
  end = chTimeAddX(start, TIME_MS2I(1000));
  do {
    (void)chMsgSend(tp, 1);
 80023d6:	1c28      	adds	r0, r5, #0
 80023d8:	2101      	movs	r1, #1
 80023da:	f001 fea9 	bl	8004130 <chMsgSend>
 80023de:	4642      	mov	r2, r8
 80023e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    n++;
 80023e2:	3401      	adds	r4, #1
 80023e4:	1a9b      	subs	r3, r3, r2
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 80023e6:	42b3      	cmp	r3, r6
 80023e8:	d9f5      	bls.n	80023d6 <msg_loop_test+0x16>
  (void)chMsgSend(tp, 0);
 80023ea:	1c28      	adds	r0, r5, #0
 80023ec:	2100      	movs	r1, #0
 80023ee:	f001 fe9f 	bl	8004130 <chMsgSend>
  return n;
}
 80023f2:	1c20      	adds	r0, r4, #0
 80023f4:	bc04      	pop	{r2}
 80023f6:	4690      	mov	r8, r2
 80023f8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80023fa:	46c0      	nop			; (mov r8, r8)
 80023fc:	0000270f 	.word	0x0000270f

08002400 <rt_test_010_003_execute.lto_priv.133>:
 *   second time window.
 * - [10.3.4] Score is printed.
 * .
 */

static void rt_test_010_003_execute(void) {
 8002400:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002402:	4647      	mov	r7, r8
  uint32_t n;

  /* [10.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8002404:	2301      	movs	r3, #1
 *   second time window.
 * - [10.3.4] Score is printed.
 * .
 */

static void rt_test_010_003_execute(void) {
 8002406:	b480      	push	{r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002408:	4e2c      	ldr	r6, [pc, #176]	; (80024bc <rt_test_010_003_execute.lto_priv.133+0xbc>)
  uint32_t n;

  /* [10.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 800240a:	4f2d      	ldr	r7, [pc, #180]	; (80024c0 <rt_test_010_003_execute.lto_priv.133+0xc0>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800240c:	4c2d      	ldr	r4, [pc, #180]	; (80024c4 <rt_test_010_003_execute.lto_priv.133+0xc4>)
static void rt_test_010_003_execute(void) {
  uint32_t n;

  /* [10.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 800240e:	603b      	str	r3, [r7, #0]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002410:	69b3      	ldr	r3, [r6, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8002412:	1c20      	adds	r0, r4, #0
 8002414:	6899      	ldr	r1, [r3, #8]
 8002416:	4a2c      	ldr	r2, [pc, #176]	; (80024c8 <rt_test_010_003_execute.lto_priv.133+0xc8>)
 8002418:	3101      	adds	r1, #1
 800241a:	2300      	movs	r3, #0
 800241c:	f002 fd70 	bl	8004f00 <chThdCreateStatic.constprop.40>
  }

  /* [10.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 8002420:	2302      	movs	r3, #2

  /* [10.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8002422:	4d2a      	ldr	r5, [pc, #168]	; (80024cc <rt_test_010_003_execute.lto_priv.133+0xcc>)
  }

  /* [10.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 8002424:	603b      	str	r3, [r7, #0]

  /* [10.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8002426:	6028      	str	r0, [r5, #0]

  /* [10.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8002428:	1c20      	adds	r0, r4, #0
 800242a:	69b3      	ldr	r3, [r6, #24]
 800242c:	3049      	adds	r0, #73	; 0x49
 800242e:	6899      	ldr	r1, [r3, #8]
 8002430:	4b27      	ldr	r3, [pc, #156]	; (80024d0 <rt_test_010_003_execute.lto_priv.133+0xd0>)
 8002432:	3902      	subs	r1, #2
 8002434:	4698      	mov	r8, r3
 8002436:	1c1a      	adds	r2, r3, #0
 8002438:	30ff      	adds	r0, #255	; 0xff
 800243a:	2300      	movs	r3, #0
 800243c:	f002 fd60 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 8002440:	23a4      	movs	r3, #164	; 0xa4
 8002442:	009b      	lsls	r3, r3, #2

  /* [10.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8002444:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 8002446:	18e0      	adds	r0, r4, r3
 8002448:	69b3      	ldr	r3, [r6, #24]
 800244a:	4642      	mov	r2, r8
 800244c:	6899      	ldr	r1, [r3, #8]
 800244e:	2300      	movs	r3, #0
 8002450:	3903      	subs	r1, #3
 8002452:	f002 fd55 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 8002456:	23f6      	movs	r3, #246	; 0xf6
 8002458:	009b      	lsls	r3, r3, #2
  /* [10.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 800245a:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 800245c:	18e0      	adds	r0, r4, r3
 800245e:	69b3      	ldr	r3, [r6, #24]
 8002460:	4642      	mov	r2, r8
 8002462:	6899      	ldr	r1, [r3, #8]
 8002464:	2300      	movs	r3, #0
 8002466:	3904      	subs	r1, #4
 8002468:	f002 fd4a 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 800246c:	23a4      	movs	r3, #164	; 0xa4
 800246e:	00db      	lsls	r3, r3, #3
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 8002470:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8002472:	18e0      	adds	r0, r4, r3
 8002474:	69b3      	ldr	r3, [r6, #24]
 8002476:	4642      	mov	r2, r8
 8002478:	6899      	ldr	r1, [r3, #8]
 800247a:	2300      	movs	r3, #0
 800247c:	3905      	subs	r1, #5
 800247e:	f002 fd3f 	bl	8004f00 <chThdCreateStatic.constprop.40>
  }

  /* [10.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 8002482:	2303      	movs	r3, #3
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8002484:	6128      	str	r0, [r5, #16]

  /* [10.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
  {
    n = msg_loop_test(threads[0]);
 8002486:	6828      	ldr	r0, [r5, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
  }

  /* [10.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 8002488:	603b      	str	r3, [r7, #0]
  {
    n = msg_loop_test(threads[0]);
 800248a:	f7ff ff99 	bl	80023c0 <msg_loop_test>
 800248e:	1c04      	adds	r4, r0, #0
    test_wait_threads();
 8002490:	f001 fa36 	bl	8003900 <test_wait_threads>
  }

  /* [10.3.4] Score is printed.*/
  test_set_step(4);
 8002494:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 8002496:	480f      	ldr	r0, [pc, #60]	; (80024d4 <rt_test_010_003_execute.lto_priv.133+0xd4>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [10.3.4] Score is printed.*/
  test_set_step(4);
 8002498:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 800249a:	f001 fa91 	bl	80039c0 <test_print>
    test_printn(n);
 800249e:	1c20      	adds	r0, r4, #0
 80024a0:	f001 f9ee 	bl	8003880 <test_printn>
    test_print(" msgs/S, ");
 80024a4:	480c      	ldr	r0, [pc, #48]	; (80024d8 <rt_test_010_003_execute.lto_priv.133+0xd8>)
 80024a6:	f001 fa8b 	bl	80039c0 <test_print>
    test_printn(n << 1);
 80024aa:	0060      	lsls	r0, r4, #1
 80024ac:	f001 f9e8 	bl	8003880 <test_printn>
    test_println(" ctxswc/S");
 80024b0:	480a      	ldr	r0, [pc, #40]	; (80024dc <rt_test_010_003_execute.lto_priv.133+0xdc>)
 80024b2:	f001 fa65 	bl	8003980 <test_println>
  }
}
 80024b6:	bc04      	pop	{r2}
 80024b8:	4690      	mov	r8, r2
 80024ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80024bc:	20000e84 	.word	0x20000e84
 80024c0:	20000d64 	.word	0x20000d64
 80024c4:	200006e8 	.word	0x200006e8
 80024c8:	08002371 	.word	0x08002371
 80024cc:	20000d68 	.word	0x20000d68
 80024d0:	08002c51 	.word	0x08002c51
 80024d4:	08005650 	.word	0x08005650
 80024d8:	0800568c 	.word	0x0800568c
 80024dc:	08005674 	.word	0x08005674

080024e0 <rt_test_010_002_execute.lto_priv.132>:
 *   second time window.
 * - [10.2.3] Score is printed.
 * .
 */

static void rt_test_010_002_execute(void) {
 80024e0:	b538      	push	{r3, r4, r5, lr}
  uint32_t n;

  /* [10.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 80024e2:	2301      	movs	r3, #1
 80024e4:	4d12      	ldr	r5, [pc, #72]	; (8002530 <rt_test_010_002_execute.lto_priv.132+0x50>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80024e6:	4a13      	ldr	r2, [pc, #76]	; (8002534 <rt_test_010_002_execute.lto_priv.132+0x54>)
static void rt_test_010_002_execute(void) {
  uint32_t n;

  /* [10.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 80024e8:	602b      	str	r3, [r5, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80024ea:	4b13      	ldr	r3, [pc, #76]	; (8002538 <rt_test_010_002_execute.lto_priv.132+0x58>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80024ec:	4813      	ldr	r0, [pc, #76]	; (800253c <rt_test_010_002_execute.lto_priv.132+0x5c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80024ee:	699b      	ldr	r3, [r3, #24]
 80024f0:	6899      	ldr	r1, [r3, #8]
 80024f2:	2300      	movs	r3, #0
 80024f4:	3101      	adds	r1, #1
 80024f6:	f002 fd03 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80024fa:	4b11      	ldr	r3, [pc, #68]	; (8002540 <rt_test_010_002_execute.lto_priv.132+0x60>)
 80024fc:	6018      	str	r0, [r3, #0]
  }

  /* [10.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 80024fe:	2302      	movs	r3, #2
 8002500:	602b      	str	r3, [r5, #0]
  {
    n = msg_loop_test(threads[0]);
 8002502:	f7ff ff5d 	bl	80023c0 <msg_loop_test>
 8002506:	1c04      	adds	r4, r0, #0
    test_wait_threads();
 8002508:	f001 f9fa 	bl	8003900 <test_wait_threads>
  }

  /* [10.2.3] Score is printed.*/
  test_set_step(3);
 800250c:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 800250e:	480d      	ldr	r0, [pc, #52]	; (8002544 <rt_test_010_002_execute.lto_priv.132+0x64>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [10.2.3] Score is printed.*/
  test_set_step(3);
 8002510:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Score : ");
 8002512:	f001 fa55 	bl	80039c0 <test_print>
    test_printn(n);
 8002516:	1c20      	adds	r0, r4, #0
 8002518:	f001 f9b2 	bl	8003880 <test_printn>
    test_print(" msgs/S, ");
 800251c:	480a      	ldr	r0, [pc, #40]	; (8002548 <rt_test_010_002_execute.lto_priv.132+0x68>)
 800251e:	f001 fa4f 	bl	80039c0 <test_print>
    test_printn(n << 1);
 8002522:	0060      	lsls	r0, r4, #1
 8002524:	f001 f9ac 	bl	8003880 <test_printn>
    test_println(" ctxswc/S");
 8002528:	4808      	ldr	r0, [pc, #32]	; (800254c <rt_test_010_002_execute.lto_priv.132+0x6c>)
 800252a:	f001 fa29 	bl	8003980 <test_println>
  }
}
 800252e:	bd38      	pop	{r3, r4, r5, pc}
 8002530:	20000d64 	.word	0x20000d64
 8002534:	08002371 	.word	0x08002371
 8002538:	20000e84 	.word	0x20000e84
 800253c:	200006e8 	.word	0x200006e8
 8002540:	20000d68 	.word	0x20000d68
 8002544:	08005650 	.word	0x08005650
 8002548:	0800568c 	.word	0x0800568c
 800254c:	08005674 	.word	0x08005674

08002550 <rt_test_010_001_execute.lto_priv.131>:
 *   second time window.
 * - [10.1.3] Score is printed.
 * .
 */

static void rt_test_010_001_execute(void) {
 8002550:	b538      	push	{r3, r4, r5, lr}
  uint32_t n;

  /* [10.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 8002552:	2301      	movs	r3, #1
 8002554:	4d12      	ldr	r5, [pc, #72]	; (80025a0 <rt_test_010_001_execute.lto_priv.131+0x50>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 8002556:	4a13      	ldr	r2, [pc, #76]	; (80025a4 <rt_test_010_001_execute.lto_priv.131+0x54>)
static void rt_test_010_001_execute(void) {
  uint32_t n;

  /* [10.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 8002558:	602b      	str	r3, [r5, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800255a:	4b13      	ldr	r3, [pc, #76]	; (80025a8 <rt_test_010_001_execute.lto_priv.131+0x58>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 800255c:	4813      	ldr	r0, [pc, #76]	; (80025ac <rt_test_010_001_execute.lto_priv.131+0x5c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800255e:	699b      	ldr	r3, [r3, #24]
 8002560:	6899      	ldr	r1, [r3, #8]
 8002562:	2300      	movs	r3, #0
 8002564:	3901      	subs	r1, #1
 8002566:	f002 fccb 	bl	8004f00 <chThdCreateStatic.constprop.40>
 800256a:	4b11      	ldr	r3, [pc, #68]	; (80025b0 <rt_test_010_001_execute.lto_priv.131+0x60>)
 800256c:	6018      	str	r0, [r3, #0]
  }

  /* [10.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 800256e:	2302      	movs	r3, #2
 8002570:	602b      	str	r3, [r5, #0]
  {
    n = msg_loop_test(threads[0]);
 8002572:	f7ff ff25 	bl	80023c0 <msg_loop_test>
 8002576:	1c04      	adds	r4, r0, #0
    test_wait_threads();
 8002578:	f001 f9c2 	bl	8003900 <test_wait_threads>
  }

  /* [10.1.3] Score is printed.*/
  test_set_step(3);
 800257c:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 800257e:	480d      	ldr	r0, [pc, #52]	; (80025b4 <rt_test_010_001_execute.lto_priv.131+0x64>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [10.1.3] Score is printed.*/
  test_set_step(3);
 8002580:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Score : ");
 8002582:	f001 fa1d 	bl	80039c0 <test_print>
    test_printn(n);
 8002586:	1c20      	adds	r0, r4, #0
 8002588:	f001 f97a 	bl	8003880 <test_printn>
    test_print(" msgs/S, ");
 800258c:	480a      	ldr	r0, [pc, #40]	; (80025b8 <rt_test_010_001_execute.lto_priv.131+0x68>)
 800258e:	f001 fa17 	bl	80039c0 <test_print>
    test_printn(n << 1);
 8002592:	0060      	lsls	r0, r4, #1
 8002594:	f001 f974 	bl	8003880 <test_printn>
    test_println(" ctxswc/S");
 8002598:	4808      	ldr	r0, [pc, #32]	; (80025bc <rt_test_010_001_execute.lto_priv.131+0x6c>)
 800259a:	f001 f9f1 	bl	8003980 <test_println>
  }
}
 800259e:	bd38      	pop	{r3, r4, r5, pc}
 80025a0:	20000d64 	.word	0x20000d64
 80025a4:	08002371 	.word	0x08002371
 80025a8:	20000e84 	.word	0x20000e84
 80025ac:	200006e8 	.word	0x200006e8
 80025b0:	20000d68 	.word	0x20000d68
 80025b4:	08005650 	.word	0x08005650
 80025b8:	0800568c 	.word	0x0800568c
 80025bc:	08005674 	.word	0x08005674

080025c0 <rt_test_009_002_execute.lto_priv.130>:
static void rt_test_009_002_execute(void) {
  unsigned i;
  tprio_t prio;

  /* [9.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 80025c0:	2301      	movs	r3, #1

static void rt_test_009_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void rt_test_009_002_execute(void) {
 80025c2:	b570      	push	{r4, r5, r6, lr}
  unsigned i;
  tprio_t prio;

  /* [9.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 80025c4:	4e3a      	ldr	r6, [pc, #232]	; (80026b0 <rt_test_009_002_execute.lto_priv.130+0xf0>)
 80025c6:	483b      	ldr	r0, [pc, #236]	; (80026b4 <rt_test_009_002_execute.lto_priv.130+0xf4>)
 80025c8:	6033      	str	r3, [r6, #0]
 80025ca:	2300      	movs	r3, #0
 80025cc:	493a      	ldr	r1, [pc, #232]	; (80026b8 <rt_test_009_002_execute.lto_priv.130+0xf8>)
  {
    for (i = 0; i < 4; i++)
      chPoolFree(&mp1, wa[i]);
 80025ce:	58c2      	ldr	r2, [r0, r3]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80025d0:	b672      	cpsid	i
  chDbgCheckClassI();
  chDbgCheck((mp != NULL) &&
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 80025d2:	680c      	ldr	r4, [r1, #0]
 80025d4:	6014      	str	r4, [r2, #0]
  mp->next = php;
 80025d6:	600a      	str	r2, [r1, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80025d8:	b662      	cpsie	i
 80025da:	3304      	adds	r3, #4
  tprio_t prio;

  /* [9.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
  {
    for (i = 0; i < 4; i++)
 80025dc:	2b10      	cmp	r3, #16
 80025de:	d1f6      	bne.n	80025ce <rt_test_009_002_execute.lto_priv.130+0xe>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80025e0:	4b36      	ldr	r3, [pc, #216]	; (80026bc <rt_test_009_002_execute.lto_priv.130+0xfc>)
  }

  /* [9.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 80025e2:	4a37      	ldr	r2, [pc, #220]	; (80026c0 <rt_test_009_002_execute.lto_priv.130+0x100>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80025e4:	699b      	ldr	r3, [r3, #24]
 80025e6:	4837      	ldr	r0, [pc, #220]	; (80026c4 <rt_test_009_002_execute.lto_priv.130+0x104>)
 80025e8:	689d      	ldr	r5, [r3, #8]
  {
    prio = chThdGetPriorityX();
  }

  /* [9.2.3] Creating the five threads.*/
  test_set_step(3);
 80025ea:	2303      	movs	r3, #3
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 80025ec:	1e69      	subs	r1, r5, #1
  {
    prio = chThdGetPriorityX();
  }

  /* [9.2.3] Creating the five threads.*/
  test_set_step(3);
 80025ee:	6033      	str	r3, [r6, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 80025f0:	f002 fe6e 	bl	80052d0 <chThdCreateFromMemoryPool.constprop.7>
 80025f4:	4c34      	ldr	r4, [pc, #208]	; (80026c8 <rt_test_009_002_execute.lto_priv.130+0x108>)
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 80025f6:	1ea9      	subs	r1, r5, #2
  }

  /* [9.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 80025f8:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 80025fa:	4a34      	ldr	r2, [pc, #208]	; (80026cc <rt_test_009_002_execute.lto_priv.130+0x10c>)
 80025fc:	4834      	ldr	r0, [pc, #208]	; (80026d0 <rt_test_009_002_execute.lto_priv.130+0x110>)
 80025fe:	f002 fe67 	bl	80052d0 <chThdCreateFromMemoryPool.constprop.7>
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8002602:	1ee9      	subs	r1, r5, #3

  /* [9.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8002604:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8002606:	4a33      	ldr	r2, [pc, #204]	; (80026d4 <rt_test_009_002_execute.lto_priv.130+0x114>)
 8002608:	4833      	ldr	r0, [pc, #204]	; (80026d8 <rt_test_009_002_execute.lto_priv.130+0x118>)
 800260a:	f002 fe61 	bl	80052d0 <chThdCreateFromMemoryPool.constprop.7>
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 800260e:	1f29      	subs	r1, r5, #4
  /* [9.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8002610:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8002612:	4a32      	ldr	r2, [pc, #200]	; (80026dc <rt_test_009_002_execute.lto_priv.130+0x11c>)
 8002614:	4832      	ldr	r0, [pc, #200]	; (80026e0 <rt_test_009_002_execute.lto_priv.130+0x120>)
 8002616:	f002 fe5b 	bl	80052d0 <chThdCreateFromMemoryPool.constprop.7>
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800261a:	1f69      	subs	r1, r5, #5
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 800261c:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800261e:	4a31      	ldr	r2, [pc, #196]	; (80026e4 <rt_test_009_002_execute.lto_priv.130+0x124>)
 8002620:	4831      	ldr	r0, [pc, #196]	; (80026e8 <rt_test_009_002_execute.lto_priv.130+0x128>)
 8002622:	f002 fe55 	bl	80052d0 <chThdCreateFromMemoryPool.constprop.7>
  }

  /* [9.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
 8002626:	2304      	movs	r3, #4
 8002628:	6033      	str	r3, [r6, #0]
  {
    test_assert((threads[0] != NULL) &&
 800262a:	6823      	ldr	r3, [r4, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 800262c:	6120      	str	r0, [r4, #16]
  }

  /* [9.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 800262e:	2b00      	cmp	r3, #0
 8002630:	d03c      	beq.n	80026ac <rt_test_009_002_execute.lto_priv.130+0xec>
 8002632:	6863      	ldr	r3, [r4, #4]
 8002634:	2b00      	cmp	r3, #0
 8002636:	d039      	beq.n	80026ac <rt_test_009_002_execute.lto_priv.130+0xec>
 8002638:	68a3      	ldr	r3, [r4, #8]
 800263a:	2b00      	cmp	r3, #0
 800263c:	d036      	beq.n	80026ac <rt_test_009_002_execute.lto_priv.130+0xec>
 800263e:	68e0      	ldr	r0, [r4, #12]
 8002640:	1e43      	subs	r3, r0, #1
 8002642:	4198      	sbcs	r0, r3
 8002644:	b2c0      	uxtb	r0, r0
 8002646:	4929      	ldr	r1, [pc, #164]	; (80026ec <rt_test_009_002_execute.lto_priv.130+0x12c>)
 8002648:	f001 fc5a 	bl	8003f00 <_test_assert>
 800264c:	2800      	cmp	r0, #0
 800264e:	d000      	beq.n	8002652 <rt_test_009_002_execute.lto_priv.130+0x92>
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
  }
}
 8002650:	bd70      	pop	{r4, r5, r6, pc}
    test_assert((threads[0] != NULL) &&
                (threads[1] != NULL) &&
                (threads[2] != NULL) &&
                (threads[3] != NULL),
                "thread creation failed");
    test_assert(threads[4] == NULL,
 8002652:	6923      	ldr	r3, [r4, #16]
 8002654:	4926      	ldr	r1, [pc, #152]	; (80026f0 <rt_test_009_002_execute.lto_priv.130+0x130>)
 8002656:	4258      	negs	r0, r3
 8002658:	4158      	adcs	r0, r3
 800265a:	b2c0      	uxtb	r0, r0
 800265c:	f001 fc50 	bl	8003f00 <_test_assert>
 8002660:	2800      	cmp	r0, #0
 8002662:	d1f5      	bne.n	8002650 <rt_test_009_002_execute.lto_priv.130+0x90>
                "thread creation not failed");
  }

  /* [9.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 8002664:	2305      	movs	r3, #5
 8002666:	6033      	str	r3, [r6, #0]
  {
    test_wait_threads();
 8002668:	f001 f94a 	bl	8003900 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 800266c:	4821      	ldr	r0, [pc, #132]	; (80026f4 <rt_test_009_002_execute.lto_priv.130+0x134>)
 800266e:	f002 fe5f 	bl	8005330 <_test_assert_sequence.constprop.3>
 8002672:	2800      	cmp	r0, #0
 8002674:	d1ec      	bne.n	8002650 <rt_test_009_002_execute.lto_priv.130+0x90>
  }

  /* [9.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
 8002676:	2306      	movs	r3, #6
 8002678:	2404      	movs	r4, #4
 800267a:	4d1f      	ldr	r5, [pc, #124]	; (80026f8 <rt_test_009_002_execute.lto_priv.130+0x138>)
 800267c:	6033      	str	r3, [r6, #0]
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 800267e:	f002 fe0f 	bl	80052a0 <chPoolAlloc.constprop.8>
 8002682:	1e43      	subs	r3, r0, #1
 8002684:	4198      	sbcs	r0, r3
 8002686:	1c29      	adds	r1, r5, #0
 8002688:	b2c0      	uxtb	r0, r0
 800268a:	f001 fc39 	bl	8003f00 <_test_assert>
 800268e:	2800      	cmp	r0, #0
 8002690:	d1de      	bne.n	8002650 <rt_test_009_002_execute.lto_priv.130+0x90>
 8002692:	3c01      	subs	r4, #1
  }

  /* [9.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
  {
    for (i = 0; i < 4; i++)
 8002694:	2c00      	cmp	r4, #0
 8002696:	d1f2      	bne.n	800267e <rt_test_009_002_execute.lto_priv.130+0xbe>
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8002698:	f002 fe02 	bl	80052a0 <chPoolAlloc.constprop.8>
 800269c:	1c03      	adds	r3, r0, #0
 800269e:	4258      	negs	r0, r3
 80026a0:	4158      	adcs	r0, r3
 80026a2:	4916      	ldr	r1, [pc, #88]	; (80026fc <rt_test_009_002_execute.lto_priv.130+0x13c>)
 80026a4:	b2c0      	uxtb	r0, r0
 80026a6:	f001 fc2b 	bl	8003f00 <_test_assert>
 80026aa:	e7d1      	b.n	8002650 <rt_test_009_002_execute.lto_priv.130+0x90>
  }

  /* [9.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 80026ac:	2000      	movs	r0, #0
 80026ae:	e7ca      	b.n	8002646 <rt_test_009_002_execute.lto_priv.130+0x86>
 80026b0:	20000d64 	.word	0x20000d64
 80026b4:	08005850 	.word	0x08005850
 80026b8:	20000f00 	.word	0x20000f00
 80026bc:	20000e84 	.word	0x20000e84
 80026c0:	0800557c 	.word	0x0800557c
 80026c4:	08005698 	.word	0x08005698
 80026c8:	20000d68 	.word	0x20000d68
 80026cc:	08005580 	.word	0x08005580
 80026d0:	080056a0 	.word	0x080056a0
 80026d4:	08005584 	.word	0x08005584
 80026d8:	080056a8 	.word	0x080056a8
 80026dc:	08005588 	.word	0x08005588
 80026e0:	080056b0 	.word	0x080056b0
 80026e4:	08005590 	.word	0x08005590
 80026e8:	080056b8 	.word	0x080056b8
 80026ec:	080056c0 	.word	0x080056c0
 80026f0:	080056d8 	.word	0x080056d8
 80026f4:	080056f4 	.word	0x080056f4
 80026f8:	080056fc 	.word	0x080056fc
 80026fc:	0800570c 	.word	0x0800570c

08002700 <dyn_thread1.lto_priv.52>:
#endif
#if CH_CFG_USE_MEMPOOLS
static memory_pool_t mp1;
#endif

static THD_FUNCTION(dyn_thread1, p) {
 8002700:	b508      	push	{r3, lr}

  test_emit_token(*(char *)p);
 8002702:	7800      	ldrb	r0, [r0, #0]
 8002704:	f001 f92c 	bl	8003960 <test_emit_token>
}
 8002708:	bd08      	pop	{r3, pc}
 800270a:	46c0      	nop			; (mov r8, r8)
 800270c:	46c0      	nop			; (mov r8, r8)
 800270e:	46c0      	nop			; (mov r8, r8)

08002710 <rt_test_009_001_execute.lto_priv.128>:

static void rt_test_009_001_setup(void) {
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}

static void rt_test_009_001_execute(void) {
 8002710:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002712:	4b5c      	ldr	r3, [pc, #368]	; (8002884 <rt_test_009_001_execute.lto_priv.128+0x174>)
 8002714:	464d      	mov	r5, r9
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002716:	699b      	ldr	r3, [r3, #24]
 8002718:	4644      	mov	r4, r8
 800271a:	689b      	ldr	r3, [r3, #8]
 800271c:	465f      	mov	r7, fp
 800271e:	4656      	mov	r6, sl
 8002720:	4699      	mov	r9, r3
  {
    prio = chThdGetPriorityX();
  }

  /* [9.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8002722:	2302      	movs	r3, #2

static void rt_test_009_001_setup(void) {
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}

static void rt_test_009_001_execute(void) {
 8002724:	b4f0      	push	{r4, r5, r6, r7}
  {
    prio = chThdGetPriorityX();
  }

  /* [9.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8002726:	4f58      	ldr	r7, [pc, #352]	; (8002888 <rt_test_009_001_execute.lto_priv.128+0x178>)
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
 8002728:	2600      	movs	r6, #0
 800272a:	603b      	str	r3, [r7, #0]

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 800272c:	4b57      	ldr	r3, [pc, #348]	; (800288c <rt_test_009_001_execute.lto_priv.128+0x17c>)
  tpages = 0U;
 800272e:	2500      	movs	r5, #0

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 8002730:	4698      	mov	r8, r3
 8002732:	1c18      	adds	r0, r3, #0
 8002734:	f7fe f884 	bl	8000840 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
 8002738:	4643      	mov	r3, r8
  }

  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
 800273a:	2400      	movs	r4, #0
  qp = &heapp->header;
 800273c:	3b08      	subs	r3, #8
  while (H_NEXT(qp) != NULL) {
 800273e:	681b      	ldr	r3, [r3, #0]
 8002740:	2b00      	cmp	r3, #0
 8002742:	d008      	beq.n	8002756 <rt_test_009_001_execute.lto_priv.128+0x46>
    size_t pages = H_PAGES(H_NEXT(qp));
 8002744:	6859      	ldr	r1, [r3, #4]

    /* Updating counters.*/
    n++;
 8002746:	3401      	adds	r4, #1
    tpages += pages;
 8002748:	186d      	adds	r5, r5, r1
 800274a:	428e      	cmp	r6, r1
 800274c:	d2f7      	bcs.n	800273e <rt_test_009_001_execute.lto_priv.128+0x2e>
  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 800274e:	681b      	ldr	r3, [r3, #0]
 8002750:	1c0e      	adds	r6, r1, #0
 8002752:	2b00      	cmp	r3, #0
 8002754:	d1f6      	bne.n	8002744 <rt_test_009_001_execute.lto_priv.128+0x34>

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
    *largestp = lpages * CH_HEAP_ALIGNMENT;
  }
  H_UNLOCK(heapp);
 8002756:	4640      	mov	r0, r8
 8002758:	f7fd ffda 	bl	8000710 <chMtxUnlock>
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
    test_assert(n1 == 1, "heap fragmented");
 800275c:	1e60      	subs	r0, r4, #1
 800275e:	4243      	negs	r3, r0
 8002760:	4158      	adcs	r0, r3
 8002762:	494b      	ldr	r1, [pc, #300]	; (8002890 <rt_test_009_001_execute.lto_priv.128+0x180>)
 8002764:	b2c0      	uxtb	r0, r0
 8002766:	f001 fbcb 	bl	8003f00 <_test_assert>
 800276a:	2800      	cmp	r0, #0
 800276c:	d005      	beq.n	800277a <rt_test_009_001_execute.lto_priv.128+0x6a>
    n2 = chHeapStatus(&heap1, &total2, &largest2);
    test_assert(n1 == n2, "fragmentation changed");
    test_assert(total1 == total2, "total free space changed");
    test_assert(largest1 == largest2, "largest fragment size changed");
  }
}
 800276e:	bc3c      	pop	{r2, r3, r4, r5}
 8002770:	4690      	mov	r8, r2
 8002772:	4699      	mov	r9, r3
 8002774:	46a2      	mov	sl, r4
 8002776:	46ab      	mov	fp, r5
 8002778:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    n1 = chHeapStatus(&heap1, &total1, &largest1);
    test_assert(n1 == 1, "heap fragmented");
  }

  /* [9.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
 800277a:	2303      	movs	r3, #3
 800277c:	603b      	str	r3, [r7, #0]
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 800277e:	464b      	mov	r3, r9
 8002780:	3049      	adds	r0, #73	; 0x49
 8002782:	1e5a      	subs	r2, r3, #1
 8002784:	4943      	ldr	r1, [pc, #268]	; (8002894 <rt_test_009_001_execute.lto_priv.128+0x184>)
 8002786:	4b44      	ldr	r3, [pc, #272]	; (8002898 <rt_test_009_001_execute.lto_priv.128+0x188>)
 8002788:	30ff      	adds	r0, #255	; 0xff
 800278a:	f002 fce9 	bl	8005160 <chThdCreateFromHeap.constprop.9>
 800278e:	4b43      	ldr	r3, [pc, #268]	; (800289c <rt_test_009_001_execute.lto_priv.128+0x18c>)
 8002790:	469a      	mov	sl, r3
 8002792:	6018      	str	r0, [r3, #0]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn1",
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
 8002794:	1e43      	subs	r3, r0, #1
 8002796:	4198      	sbcs	r0, r3
 8002798:	4b41      	ldr	r3, [pc, #260]	; (80028a0 <rt_test_009_001_execute.lto_priv.128+0x190>)
 800279a:	b2c0      	uxtb	r0, r0
 800279c:	1c19      	adds	r1, r3, #0
 800279e:	469b      	mov	fp, r3
 80027a0:	f001 fbae 	bl	8003f00 <_test_assert>
 80027a4:	2800      	cmp	r0, #0
 80027a6:	d1e2      	bne.n	800276e <rt_test_009_001_execute.lto_priv.128+0x5e>
  }

  /* [9.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
 80027a8:	2304      	movs	r3, #4
 80027aa:	603b      	str	r3, [r7, #0]
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 80027ac:	464b      	mov	r3, r9
 80027ae:	3049      	adds	r0, #73	; 0x49
 80027b0:	1e9a      	subs	r2, r3, #2
 80027b2:	493c      	ldr	r1, [pc, #240]	; (80028a4 <rt_test_009_001_execute.lto_priv.128+0x194>)
 80027b4:	4b3c      	ldr	r3, [pc, #240]	; (80028a8 <rt_test_009_001_execute.lto_priv.128+0x198>)
 80027b6:	30ff      	adds	r0, #255	; 0xff
 80027b8:	f002 fcd2 	bl	8005160 <chThdCreateFromHeap.constprop.9>
 80027bc:	4653      	mov	r3, sl
 80027be:	6058      	str	r0, [r3, #4]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
 80027c0:	1e43      	subs	r3, r0, #1
 80027c2:	4198      	sbcs	r0, r3
 80027c4:	4659      	mov	r1, fp
 80027c6:	b2c0      	uxtb	r0, r0
 80027c8:	f001 fb9a 	bl	8003f00 <_test_assert>
 80027cc:	2800      	cmp	r0, #0
 80027ce:	d1ce      	bne.n	800276e <rt_test_009_001_execute.lto_priv.128+0x5e>
  }

  /* [9.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
 80027d0:	2305      	movs	r3, #5
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80027d2:	464a      	mov	r2, r9
 80027d4:	2080      	movs	r0, #128	; 0x80
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
  }

  /* [9.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
 80027d6:	603b      	str	r3, [r7, #0]
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80027d8:	4934      	ldr	r1, [pc, #208]	; (80028ac <rt_test_009_001_execute.lto_priv.128+0x19c>)
 80027da:	4b35      	ldr	r3, [pc, #212]	; (80028b0 <rt_test_009_001_execute.lto_priv.128+0x1a0>)
 80027dc:	3a03      	subs	r2, #3
 80027de:	0600      	lsls	r0, r0, #24
 80027e0:	f002 fcbe 	bl	8005160 <chThdCreateFromHeap.constprop.9>
 80027e4:	4653      	mov	r3, sl
 80027e6:	6098      	str	r0, [r3, #8]
                                     (((size_t)-1) >> 1U) + 1U,
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 80027e8:	4243      	negs	r3, r0
 80027ea:	4158      	adcs	r0, r3
 80027ec:	4931      	ldr	r1, [pc, #196]	; (80028b4 <rt_test_009_001_execute.lto_priv.128+0x1a4>)
 80027ee:	b2c0      	uxtb	r0, r0
 80027f0:	f001 fb86 	bl	8003f00 <_test_assert>
 80027f4:	2800      	cmp	r0, #0
 80027f6:	d1ba      	bne.n	800276e <rt_test_009_001_execute.lto_priv.128+0x5e>
  }

  /* [9.1.6] Letting threads execute then checking the start order and
     freeing memory.*/
  test_set_step(6);
 80027f8:	2306      	movs	r3, #6
 80027fa:	603b      	str	r3, [r7, #0]
  {
    test_wait_threads();
 80027fc:	f001 f880 	bl	8003900 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 8002800:	482d      	ldr	r0, [pc, #180]	; (80028b8 <rt_test_009_001_execute.lto_priv.128+0x1a8>)
 8002802:	f002 fd95 	bl	8005330 <_test_assert_sequence.constprop.3>
 8002806:	2800      	cmp	r0, #0
 8002808:	d1b1      	bne.n	800276e <rt_test_009_001_execute.lto_priv.128+0x5e>
  }

  /* [9.1.7] Getting heap info again for verification.*/
  test_set_step(7);
 800280a:	2307      	movs	r3, #7

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 800280c:	4640      	mov	r0, r8
 800280e:	603b      	str	r3, [r7, #0]
 8002810:	f7fe f816 	bl	8000840 <chMtxLock>
  tpages = 0U;
 8002814:	2300      	movs	r3, #0
 8002816:	469a      	mov	sl, r3
  lpages = 0U;
  n = 0U;
 8002818:	4699      	mov	r9, r3
  qp = &heapp->header;
 800281a:	4643      	mov	r3, r8
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
 800281c:	2700      	movs	r7, #0
  n = 0U;
  qp = &heapp->header;
 800281e:	3b08      	subs	r3, #8
  while (H_NEXT(qp) != NULL) {
 8002820:	681b      	ldr	r3, [r3, #0]
 8002822:	2b00      	cmp	r3, #0
 8002824:	d00a      	beq.n	800283c <rt_test_009_001_execute.lto_priv.128+0x12c>
    size_t pages = H_PAGES(H_NEXT(qp));

    /* Updating counters.*/
    n++;
 8002826:	2101      	movs	r1, #1
 8002828:	468c      	mov	ip, r1
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
    size_t pages = H_PAGES(H_NEXT(qp));
 800282a:	685a      	ldr	r2, [r3, #4]

    /* Updating counters.*/
    n++;
 800282c:	44e1      	add	r9, ip
    tpages += pages;
 800282e:	4492      	add	sl, r2
 8002830:	4297      	cmp	r7, r2
 8002832:	d2f5      	bcs.n	8002820 <rt_test_009_001_execute.lto_priv.128+0x110>
  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8002834:	681b      	ldr	r3, [r3, #0]
 8002836:	1c17      	adds	r7, r2, #0
 8002838:	2b00      	cmp	r3, #0
 800283a:	d1f4      	bne.n	8002826 <rt_test_009_001_execute.lto_priv.128+0x116>

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
    *largestp = lpages * CH_HEAP_ALIGNMENT;
  }
  H_UNLOCK(heapp);
 800283c:	4640      	mov	r0, r8
 800283e:	f7fd ff67 	bl	8000710 <chMtxUnlock>
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
    test_assert(n1 == n2, "fragmentation changed");
 8002842:	464b      	mov	r3, r9
 8002844:	1b18      	subs	r0, r3, r4
 8002846:	4244      	negs	r4, r0
 8002848:	4160      	adcs	r0, r4
 800284a:	491c      	ldr	r1, [pc, #112]	; (80028bc <rt_test_009_001_execute.lto_priv.128+0x1ac>)
 800284c:	b2c0      	uxtb	r0, r0
 800284e:	f001 fb57 	bl	8003f00 <_test_assert>
 8002852:	2800      	cmp	r0, #0
 8002854:	d000      	beq.n	8002858 <rt_test_009_001_execute.lto_priv.128+0x148>
 8002856:	e78a      	b.n	800276e <rt_test_009_001_execute.lto_priv.128+0x5e>
    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 8002858:	4653      	mov	r3, sl
 800285a:	1ae8      	subs	r0, r5, r3
    test_assert(total1 == total2, "total free space changed");
 800285c:	00c0      	lsls	r0, r0, #3
 800285e:	4245      	negs	r5, r0
 8002860:	4168      	adcs	r0, r5
 8002862:	4917      	ldr	r1, [pc, #92]	; (80028c0 <rt_test_009_001_execute.lto_priv.128+0x1b0>)
 8002864:	b2c0      	uxtb	r0, r0
 8002866:	f001 fb4b 	bl	8003f00 <_test_assert>
 800286a:	2800      	cmp	r0, #0
 800286c:	d000      	beq.n	8002870 <rt_test_009_001_execute.lto_priv.128+0x160>
 800286e:	e77e      	b.n	800276e <rt_test_009_001_execute.lto_priv.128+0x5e>
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 8002870:	1bf0      	subs	r0, r6, r7
    test_assert(largest1 == largest2, "largest fragment size changed");
 8002872:	00c0      	lsls	r0, r0, #3
 8002874:	4246      	negs	r6, r0
 8002876:	4170      	adcs	r0, r6
 8002878:	4912      	ldr	r1, [pc, #72]	; (80028c4 <rt_test_009_001_execute.lto_priv.128+0x1b4>)
 800287a:	b2c0      	uxtb	r0, r0
 800287c:	f001 fb40 	bl	8003f00 <_test_assert>
 8002880:	e775      	b.n	800276e <rt_test_009_001_execute.lto_priv.128+0x5e>
 8002882:	46c0      	nop			; (mov r8, r8)
 8002884:	20000e84 	.word	0x20000e84
 8002888:	20000d64 	.word	0x20000d64
 800288c:	20000f48 	.word	0x20000f48
 8002890:	08005720 	.word	0x08005720
 8002894:	08005698 	.word	0x08005698
 8002898:	0800557c 	.word	0x0800557c
 800289c:	20000d68 	.word	0x20000d68
 80028a0:	080056c0 	.word	0x080056c0
 80028a4:	080056a0 	.word	0x080056a0
 80028a8:	08005580 	.word	0x08005580
 80028ac:	080056a8 	.word	0x080056a8
 80028b0:	08005584 	.word	0x08005584
 80028b4:	080056d8 	.word	0x080056d8
 80028b8:	08005730 	.word	0x08005730
 80028bc:	08005734 	.word	0x08005734
 80028c0:	0800574c 	.word	0x0800574c
 80028c4:	08005768 	.word	0x08005768
 80028c8:	46c0      	nop			; (mov r8, r8)
 80028ca:	46c0      	nop			; (mov r8, r8)
 80028cc:	46c0      	nop			; (mov r8, r8)
 80028ce:	46c0      	nop			; (mov r8, r8)

080028d0 <rt_test_008_007_setup.lto_priv.125>:
 *   has been emptied.
 * - [8.7.4] Unregistering from the Event Sources.
 * .
 */

static void rt_test_008_007_setup(void) {
 80028d0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80028d2:	f002 fbed 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 80028d6:	4b02      	ldr	r3, [pc, #8]	; (80028e0 <rt_test_008_007_setup.lto_priv.125+0x10>)
 80028d8:	601b      	str	r3, [r3, #0]
 80028da:	4b02      	ldr	r3, [pc, #8]	; (80028e4 <rt_test_008_007_setup.lto_priv.125+0x14>)
 80028dc:	601b      	str	r3, [r3, #0]
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}
 80028de:	bd08      	pop	{r3, pc}
 80028e0:	20000404 	.word	0x20000404
 80028e4:	20000400 	.word	0x20000400
 80028e8:	46c0      	nop			; (mov r8, r8)
 80028ea:	46c0      	nop			; (mov r8, r8)
 80028ec:	46c0      	nop			; (mov r8, r8)
 80028ee:	46c0      	nop			; (mov r8, r8)

080028f0 <rt_test_008_006_setup.lto_priv.123>:
 * - [8.6.2] The functions are invoked first with a 50mS timeout, the
 *   timeout condition is tested.
 * .
 */

static void rt_test_008_006_setup(void) {
 80028f0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80028f2:	f002 fbdd 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
}
 80028f6:	bd08      	pop	{r3, pc}
 80028f8:	46c0      	nop			; (mov r8, r8)
 80028fa:	46c0      	nop			; (mov r8, r8)
 80028fc:	46c0      	nop			; (mov r8, r8)
 80028fe:	46c0      	nop			; (mov r8, r8)

08002900 <rt_test_008_005_setup.lto_priv.121>:
 *   flags have been received after 50mS and that the event flags mask
 *   has been emptied.
 * .
 */

static void rt_test_008_005_setup(void) {
 8002900:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8002902:	f002 fbd5 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
}
 8002906:	bd08      	pop	{r3, pc}
 8002908:	46c0      	nop			; (mov r8, r8)
 800290a:	46c0      	nop			; (mov r8, r8)
 800290c:	46c0      	nop			; (mov r8, r8)
 800290e:	46c0      	nop			; (mov r8, r8)

08002910 <rt_test_008_007_execute.lto_priv.126>:
  chEvtGetAndClearEvents(ALL_EVENTS);
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void rt_test_008_007_execute(void) {
 8002910:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002912:	464e      	mov	r6, r9
 8002914:	4657      	mov	r7, sl
 8002916:	4645      	mov	r5, r8
  event_listener_t el1, el2;
  systime_t target_time;

  /* [8.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 8002918:	2301      	movs	r3, #1
  chEvtGetAndClearEvents(ALL_EVENTS);
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void rt_test_008_007_execute(void) {
 800291a:	b4e0      	push	{r5, r6, r7}
  event_listener_t el1, el2;
  systime_t target_time;

  /* [8.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 800291c:	4e39      	ldr	r6, [pc, #228]	; (8002a04 <rt_test_008_007_execute.lto_priv.126+0xf4>)
  chEvtGetAndClearEvents(ALL_EVENTS);
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void rt_test_008_007_execute(void) {
 800291e:	b08a      	sub	sp, #40	; 0x28
  event_listener_t el1, el2;
  systime_t target_time;

  /* [8.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 8002920:	6033      	str	r3, [r6, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002922:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002924:	4f38      	ldr	r7, [pc, #224]	; (8002a08 <rt_test_008_007_execute.lto_priv.126+0xf8>)
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
 8002926:	9302      	str	r3, [sp, #8]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002928:	683a      	ldr	r2, [r7, #0]
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 800292a:	3b02      	subs	r3, #2
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800292c:	9200      	str	r2, [sp, #0]
  esp->next     = elp;
 800292e:	466a      	mov	r2, sp
 8002930:	603a      	str	r2, [r7, #0]
  elp->listener = currp;
 8002932:	4a36      	ldr	r2, [pc, #216]	; (8002a0c <rt_test_008_007_execute.lto_priv.126+0xfc>)
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 8002934:	9304      	str	r3, [sp, #16]
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 8002936:	4692      	mov	sl, r2
 8002938:	6992      	ldr	r2, [r2, #24]
 800293a:	9201      	str	r2, [sp, #4]
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 800293c:	2200      	movs	r2, #0
 800293e:	9203      	str	r2, [sp, #12]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002940:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002942:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002944:	4932      	ldr	r1, [pc, #200]	; (8002a10 <rt_test_008_007_execute.lto_priv.126+0x100>)
 8002946:	ac05      	add	r4, sp, #20
 8002948:	4688      	mov	r8, r1
 800294a:	6809      	ldr	r1, [r1, #0]
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 800294c:	60e2      	str	r2, [r4, #12]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800294e:	9105      	str	r1, [sp, #20]
  esp->next     = elp;
 8002950:	4641      	mov	r1, r8
 8002952:	600c      	str	r4, [r1, #0]
  elp->listener = currp;
 8002954:	4651      	mov	r1, sl
 8002956:	6989      	ldr	r1, [r1, #24]
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 8002958:	6123      	str	r3, [r4, #16]
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 800295a:	6061      	str	r1, [r4, #4]
  elp->events   = events;
 800295c:	2104      	movs	r1, #4
 800295e:	4689      	mov	r9, r1
 8002960:	60a1      	str	r1, [r4, #8]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002962:	b662      	cpsie	i
  }

  /* [8.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 8002964:	3303      	adds	r3, #3
 8002966:	6033      	str	r3, [r6, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8002968:	f000 ffba 	bl	80038e0 <test_wait_tick>
 800296c:	4653      	mov	r3, sl
 800296e:	699b      	ldr	r3, [r3, #24]
 8002970:	1c05      	adds	r5, r0, #0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8002972:	6899      	ldr	r1, [r3, #8]
 8002974:	4a27      	ldr	r2, [pc, #156]	; (8002a14 <rt_test_008_007_execute.lto_priv.126+0x104>)
 8002976:	3901      	subs	r1, #1
 8002978:	4b27      	ldr	r3, [pc, #156]	; (8002a18 <rt_test_008_007_execute.lto_priv.126+0x108>)
 800297a:	4828      	ldr	r0, [pc, #160]	; (8002a1c <rt_test_008_007_execute.lto_priv.126+0x10c>)
 800297c:	f002 fac0 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8002980:	4b27      	ldr	r3, [pc, #156]	; (8002a20 <rt_test_008_007_execute.lto_priv.126+0x110>)
 8002982:	6018      	str	r0, [r3, #0]
  }

  /* [8.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8002984:	2303      	movs	r3, #3
 8002986:	6033      	str	r3, [r6, #0]
  {
    m = chEvtWaitAll(5);
 8002988:	f002 fbd2 	bl	8005130 <chEvtWaitAll.constprop.14>

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)((systime_t)-1));
#endif

  return systime + (systime_t)interval;
 800298c:	1c28      	adds	r0, r5, #0
 800298e:	2382      	movs	r3, #130	; 0x82
 8002990:	30f5      	adds	r0, #245	; 0xf5
 8002992:	009b      	lsls	r3, r3, #2
 8002994:	30ff      	adds	r0, #255	; 0xff
 8002996:	18e9      	adds	r1, r5, r3
    test_assert_time_window(target_time,
 8002998:	f002 fcfa 	bl	8005390 <_test_assert_time_window.constprop.2>
 800299c:	2800      	cmp	r0, #0
 800299e:	d005      	beq.n	80029ac <rt_test_008_007_execute.lto_priv.126+0x9c>
    chEvtUnregister(&es1, &el1);
    chEvtUnregister(&es2, &el2);
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  }
}
 80029a0:	b00a      	add	sp, #40	; 0x28
 80029a2:	bc1c      	pop	{r2, r3, r4}
 80029a4:	4690      	mov	r8, r2
 80029a6:	4699      	mov	r9, r3
 80029a8:	46a2      	mov	sl, r4
 80029aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  {
    m = chEvtWaitAll(5);
    test_assert_time_window(target_time,
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 80029ac:	f002 fb80 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
 80029b0:	1c03      	adds	r3, r0, #0
    test_assert(m == 0, "stuck event");
 80029b2:	4258      	negs	r0, r3
 80029b4:	4158      	adcs	r0, r3
 80029b6:	491b      	ldr	r1, [pc, #108]	; (8002a24 <rt_test_008_007_execute.lto_priv.126+0x114>)
 80029b8:	b2c0      	uxtb	r0, r0
 80029ba:	f001 faa1 	bl	8003f00 <_test_assert>
 80029be:	2800      	cmp	r0, #0
 80029c0:	d1ee      	bne.n	80029a0 <rt_test_008_007_execute.lto_priv.126+0x90>
    test_wait_threads();
 80029c2:	f000 ff9d 	bl	8003900 <test_wait_threads>
  }

  /* [8.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
 80029c6:	464b      	mov	r3, r9
  {
    chEvtUnregister(&es1, &el1);
 80029c8:	1c38      	adds	r0, r7, #0
 80029ca:	4669      	mov	r1, sp
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }

  /* [8.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
 80029cc:	6033      	str	r3, [r6, #0]
  {
    chEvtUnregister(&es1, &el1);
 80029ce:	f7fd fd0f 	bl	80003f0 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 80029d2:	1c21      	adds	r1, r4, #0
 80029d4:	4640      	mov	r0, r8
 80029d6:	f7fd fd0b 	bl	80003f0 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 80029da:	683b      	ldr	r3, [r7, #0]
 80029dc:	4c12      	ldr	r4, [pc, #72]	; (8002a28 <rt_test_008_007_execute.lto_priv.126+0x118>)
 80029de:	1bd8      	subs	r0, r3, r7
 80029e0:	4243      	negs	r3, r0
 80029e2:	4143      	adcs	r3, r0
 80029e4:	1c21      	adds	r1, r4, #0
 80029e6:	b2d8      	uxtb	r0, r3
 80029e8:	f001 fa8a 	bl	8003f00 <_test_assert>
 80029ec:	2800      	cmp	r0, #0
 80029ee:	d1d7      	bne.n	80029a0 <rt_test_008_007_execute.lto_priv.126+0x90>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 80029f0:	4643      	mov	r3, r8
 80029f2:	681a      	ldr	r2, [r3, #0]
 80029f4:	1c21      	adds	r1, r4, #0
 80029f6:	1ad0      	subs	r0, r2, r3
 80029f8:	4242      	negs	r2, r0
 80029fa:	4142      	adcs	r2, r0
 80029fc:	b2d0      	uxtb	r0, r2
 80029fe:	f001 fa7f 	bl	8003f00 <_test_assert>
 8002a02:	e7cd      	b.n	80029a0 <rt_test_008_007_execute.lto_priv.126+0x90>
 8002a04:	20000d64 	.word	0x20000d64
 8002a08:	20000404 	.word	0x20000404
 8002a0c:	20000e84 	.word	0x20000e84
 8002a10:	20000400 	.word	0x20000400
 8002a14:	08004581 	.word	0x08004581
 8002a18:	0800557c 	.word	0x0800557c
 8002a1c:	200006e8 	.word	0x200006e8
 8002a20:	20000d68 	.word	0x20000d68
 8002a24:	08005788 	.word	0x08005788
 8002a28:	08005794 	.word	0x08005794
 8002a2c:	46c0      	nop			; (mov r8, r8)
 8002a2e:	46c0      	nop			; (mov r8, r8)

08002a30 <rt_test_008_006_execute.lto_priv.124>:
static void rt_test_008_006_execute(void) {
  eventmask_t m;

  /* [8.6.1] The functions are invoked first with TIME_IMMEDIATE
     timeout, the timeout condition is tested.*/
  test_set_step(1);
 8002a30:	2301      	movs	r3, #1

static void rt_test_008_006_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void rt_test_008_006_execute(void) {
 8002a32:	b570      	push	{r4, r5, r6, lr}
  eventmask_t m;

  /* [8.6.1] The functions are invoked first with TIME_IMMEDIATE
     timeout, the timeout condition is tested.*/
  test_set_step(1);
 8002a34:	4d4b      	ldr	r5, [pc, #300]	; (8002b64 <rt_test_008_006_execute.lto_priv.124+0x134>)
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 8002a36:	4c4c      	ldr	r4, [pc, #304]	; (8002b68 <rt_test_008_006_execute.lto_priv.124+0x138>)
 8002a38:	602b      	str	r3, [r5, #0]
 8002a3a:	69a2      	ldr	r2, [r4, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a3c:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8002a3e:	6b53      	ldr	r3, [r2, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8002a40:	2b00      	cmp	r3, #0
 8002a42:	d108      	bne.n	8002a56 <rt_test_008_006_execute.lto_priv.124+0x26>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a44:	b662      	cpsie	i
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8002a46:	4e49      	ldr	r6, [pc, #292]	; (8002b6c <rt_test_008_006_execute.lto_priv.124+0x13c>)
 8002a48:	2001      	movs	r0, #1
 8002a4a:	1c31      	adds	r1, r6, #0
 8002a4c:	f001 fa58 	bl	8003f00 <_test_assert>
 8002a50:	2800      	cmp	r0, #0
 8002a52:	d00f      	beq.n	8002a74 <rt_test_008_006_execute.lto_priv.124+0x44>
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_MS2I(50));
    test_assert(m == 0, "spurious event");
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_MS2I(50));
    test_assert(m == 0, "spurious event");
  }
}
 8002a54:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 8002a56:	4258      	negs	r0, r3
 8002a58:	1c01      	adds	r1, r0, #0
 8002a5a:	4019      	ands	r1, r3
  ctp->epending &= ~m;
 8002a5c:	438b      	bics	r3, r1
 8002a5e:	6353      	str	r3, [r2, #52]	; 0x34
 8002a60:	b662      	cpsie	i
 8002a62:	4248      	negs	r0, r1
 8002a64:	4148      	adcs	r0, r1
  /* [8.6.1] The functions are invoked first with TIME_IMMEDIATE
     timeout, the timeout condition is tested.*/
  test_set_step(1);
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8002a66:	4e41      	ldr	r6, [pc, #260]	; (8002b6c <rt_test_008_006_execute.lto_priv.124+0x13c>)
 8002a68:	b2c0      	uxtb	r0, r0
 8002a6a:	1c31      	adds	r1, r6, #0
 8002a6c:	f001 fa48 	bl	8003f00 <_test_assert>
 8002a70:	2800      	cmp	r0, #0
 8002a72:	d1ef      	bne.n	8002a54 <rt_test_008_006_execute.lto_priv.124+0x24>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 8002a74:	69a3      	ldr	r3, [r4, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a76:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
 8002a78:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a7a:	2a00      	cmp	r2, #0
 8002a7c:	d063      	beq.n	8002b46 <rt_test_008_006_execute.lto_priv.124+0x116>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  ctp->epending &= ~m;
 8002a7e:	6358      	str	r0, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a80:	b662      	cpsie	i
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8002a82:	1c31      	adds	r1, r6, #0
 8002a84:	f001 fa3c 	bl	8003f00 <_test_assert>
 8002a88:	2800      	cmp	r0, #0
 8002a8a:	d1e3      	bne.n	8002a54 <rt_test_008_006_execute.lto_priv.124+0x24>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 8002a8c:	69a3      	ldr	r3, [r4, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a8e:	b672      	cpsid	i

  chSysLock();
  if ((ctp->epending & events) != events) {
 8002a90:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a92:	3201      	adds	r2, #1
 8002a94:	d05a      	beq.n	8002b4c <rt_test_008_006_execute.lto_priv.124+0x11c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a96:	b662      	cpsie	i
 8002a98:	3001      	adds	r0, #1
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8002a9a:	1c31      	adds	r1, r6, #0
 8002a9c:	f001 fa30 	bl	8003f00 <_test_assert>
 8002aa0:	2800      	cmp	r0, #0
 8002aa2:	d1d7      	bne.n	8002a54 <rt_test_008_006_execute.lto_priv.124+0x24>
  }

  /* [8.6.2] The functions are invoked first with a 50mS timeout, the
     timeout condition is tested.*/
  test_set_step(2);
 8002aa4:	2302      	movs	r3, #2
 8002aa6:	602b      	str	r3, [r5, #0]
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 8002aa8:	69a5      	ldr	r5, [r4, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002aaa:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8002aac:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8002aae:	2b00      	cmp	r3, #0
 8002ab0:	d109      	bne.n	8002ac6 <rt_test_008_006_execute.lto_priv.124+0x96>
    if (TIME_IMMEDIATE == timeout) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8002ab2:	21fa      	movs	r1, #250	; 0xfa
  if (m == (eventmask_t)0) {
    if (TIME_IMMEDIATE == timeout) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8002ab4:	3b01      	subs	r3, #1
 8002ab6:	626b      	str	r3, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8002ab8:	300a      	adds	r0, #10
 8002aba:	0049      	lsls	r1, r1, #1
 8002abc:	f7fe f8f0 	bl	8000ca0 <chSchGoSleepTimeoutS>
 8002ac0:	2800      	cmp	r0, #0
 8002ac2:	db46      	blt.n	8002b52 <rt_test_008_006_execute.lto_priv.124+0x122>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 8002ac4:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 8002ac6:	4258      	negs	r0, r3
 8002ac8:	1c02      	adds	r2, r0, #0
 8002aca:	401a      	ands	r2, r3
  ctp->epending &= ~m;
 8002acc:	4393      	bics	r3, r2
 8002ace:	636b      	str	r3, [r5, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002ad0:	b662      	cpsie	i
 8002ad2:	4250      	negs	r0, r2
 8002ad4:	4150      	adcs	r0, r2
 8002ad6:	b2c0      	uxtb	r0, r0
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_MS2I(50));
    test_assert(m == 0, "spurious event");
 8002ad8:	1c31      	adds	r1, r6, #0
 8002ada:	f001 fa11 	bl	8003f00 <_test_assert>
 8002ade:	2800      	cmp	r0, #0
 8002ae0:	d1b8      	bne.n	8002a54 <rt_test_008_006_execute.lto_priv.124+0x24>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 8002ae2:	69a5      	ldr	r5, [r4, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002ae4:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8002ae6:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8002ae8:	2b00      	cmp	r3, #0
 8002aea:	d109      	bne.n	8002b00 <rt_test_008_006_execute.lto_priv.124+0xd0>
    if (TIME_IMMEDIATE == timeout) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8002aec:	21fa      	movs	r1, #250	; 0xfa
  if (m == (eventmask_t)0) {
    if (TIME_IMMEDIATE == timeout) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8002aee:	3b01      	subs	r3, #1
 8002af0:	626b      	str	r3, [r5, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, timeout) < MSG_OK) {
 8002af2:	300a      	adds	r0, #10
 8002af4:	0049      	lsls	r1, r1, #1
 8002af6:	f7fe f8d3 	bl	8000ca0 <chSchGoSleepTimeoutS>
 8002afa:	2800      	cmp	r0, #0
 8002afc:	db2c      	blt.n	8002b58 <rt_test_008_006_execute.lto_priv.124+0x128>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 8002afe:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  }
  ctp->epending &= ~m;
 8002b00:	2200      	movs	r2, #0
 8002b02:	636a      	str	r2, [r5, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002b04:	b662      	cpsie	i
 8002b06:	4258      	negs	r0, r3
 8002b08:	4158      	adcs	r0, r3
 8002b0a:	b2c0      	uxtb	r0, r0
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_MS2I(50));
    test_assert(m == 0, "spurious event");
 8002b0c:	1c31      	adds	r1, r6, #0
 8002b0e:	f001 f9f7 	bl	8003f00 <_test_assert>
 8002b12:	1e05      	subs	r5, r0, #0
 8002b14:	d000      	beq.n	8002b18 <rt_test_008_006_execute.lto_priv.124+0xe8>
 8002b16:	e79d      	b.n	8002a54 <rt_test_008_006_execute.lto_priv.124+0x24>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, sysinterval_t timeout) {
  thread_t *ctp = currp;
 8002b18:	69a4      	ldr	r4, [r4, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002b1a:	b672      	cpsid	i

  chSysLock();
  if ((ctp->epending & events) != events) {
 8002b1c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002b1e:	3301      	adds	r3, #1
 8002b20:	d009      	beq.n	8002b36 <rt_test_008_006_execute.lto_priv.124+0x106>
    if (TIME_IMMEDIATE == timeout) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8002b22:	2301      	movs	r3, #1
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, timeout) < MSG_OK) {
 8002b24:	21fa      	movs	r1, #250	; 0xfa
  if ((ctp->epending & events) != events) {
    if (TIME_IMMEDIATE == timeout) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8002b26:	425b      	negs	r3, r3
 8002b28:	6263      	str	r3, [r4, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, timeout) < MSG_OK) {
 8002b2a:	200b      	movs	r0, #11
 8002b2c:	0049      	lsls	r1, r1, #1
 8002b2e:	f7fe f8b7 	bl	8000ca0 <chSchGoSleepTimeoutS>
 8002b32:	2800      	cmp	r0, #0
 8002b34:	db13      	blt.n	8002b5e <rt_test_008_006_execute.lto_priv.124+0x12e>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->epending &= ~events;
 8002b36:	2300      	movs	r3, #0
 8002b38:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002b3a:	b662      	cpsie	i
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_MS2I(50));
    test_assert(m == 0, "spurious event");
 8002b3c:	1c28      	adds	r0, r5, #0
 8002b3e:	1c31      	adds	r1, r6, #0
 8002b40:	f001 f9de 	bl	8003f00 <_test_assert>
 8002b44:	e786      	b.n	8002a54 <rt_test_008_006_execute.lto_priv.124+0x24>
 8002b46:	b662      	cpsie	i
 8002b48:	3001      	adds	r0, #1
 8002b4a:	e79a      	b.n	8002a82 <rt_test_008_006_execute.lto_priv.124+0x52>
 8002b4c:	6358      	str	r0, [r3, #52]	; 0x34
 8002b4e:	b662      	cpsie	i
 8002b50:	e7a3      	b.n	8002a9a <rt_test_008_006_execute.lto_priv.124+0x6a>
 8002b52:	b662      	cpsie	i
 8002b54:	2001      	movs	r0, #1
 8002b56:	e7bf      	b.n	8002ad8 <rt_test_008_006_execute.lto_priv.124+0xa8>
 8002b58:	b662      	cpsie	i
 8002b5a:	2001      	movs	r0, #1
 8002b5c:	e7d6      	b.n	8002b0c <rt_test_008_006_execute.lto_priv.124+0xdc>
 8002b5e:	b662      	cpsie	i
 8002b60:	3501      	adds	r5, #1
 8002b62:	e7eb      	b.n	8002b3c <rt_test_008_006_execute.lto_priv.124+0x10c>
 8002b64:	20000d64 	.word	0x20000d64
 8002b68:	20000e84 	.word	0x20000e84
 8002b6c:	080057a4 	.word	0x080057a4

08002b70 <rt_test_008_005_execute.lto_priv.122>:
static void rt_test_008_005_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [8.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8002b70:	2301      	movs	r3, #1

static void rt_test_008_005_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void rt_test_008_005_execute(void) {
 8002b72:	b570      	push	{r4, r5, r6, lr}
  eventmask_t m;
  systime_t target_time;

  /* [8.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8002b74:	4c2c      	ldr	r4, [pc, #176]	; (8002c28 <rt_test_008_005_execute.lto_priv.122+0xb8>)
  {
    chEvtAddEvents(5);
 8002b76:	2005      	movs	r0, #5
static void rt_test_008_005_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [8.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8002b78:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(5);
 8002b7a:	f7fd fc29 	bl	80003d0 <chEvtAddEvents>
  }

  /* [8.5.2] Calling chEvtWaitAll() one time, the two flags must be
     returned.*/
  test_set_step(2);
 8002b7e:	2302      	movs	r3, #2
 8002b80:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAll(5);
 8002b82:	f002 fad5 	bl	8005130 <chEvtWaitAll.constprop.14>
    test_assert(m == 5, "unexpected pending bit");
 8002b86:	3805      	subs	r0, #5
 8002b88:	4242      	negs	r2, r0
 8002b8a:	4142      	adcs	r2, r0
 8002b8c:	4927      	ldr	r1, [pc, #156]	; (8002c2c <rt_test_008_005_execute.lto_priv.122+0xbc>)
 8002b8e:	b2d0      	uxtb	r0, r2
 8002b90:	f001 f9b6 	bl	8003f00 <_test_assert>
 8002b94:	2800      	cmp	r0, #0
 8002b96:	d000      	beq.n	8002b9a <rt_test_008_005_execute.lto_priv.122+0x2a>
    test_assert(m == 5, "event flags error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }
}
 8002b98:	bd70      	pop	{r4, r5, r6, pc}
     returned.*/
  test_set_step(2);
  {
    m = chEvtWaitAll(5);
    test_assert(m == 5, "unexpected pending bit");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8002b9a:	f002 fa89 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
 8002b9e:	1c03      	adds	r3, r0, #0
    test_assert(m == 0, "stuck event");
 8002ba0:	4258      	negs	r0, r3
 8002ba2:	4158      	adcs	r0, r3
 8002ba4:	4d22      	ldr	r5, [pc, #136]	; (8002c30 <rt_test_008_005_execute.lto_priv.122+0xc0>)
 8002ba6:	b2c0      	uxtb	r0, r0
 8002ba8:	1c29      	adds	r1, r5, #0
 8002baa:	f001 f9a9 	bl	8003f00 <_test_assert>
 8002bae:	2800      	cmp	r0, #0
 8002bb0:	d1f2      	bne.n	8002b98 <rt_test_008_005_execute.lto_priv.122+0x28>
  }

  /* [8.5.3] Setting one event flag.*/
  test_set_step(3);
 8002bb2:	2303      	movs	r3, #3
  {
    chEvtAddEvents(4);
 8002bb4:	3004      	adds	r0, #4
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
  }

  /* [8.5.3] Setting one event flag.*/
  test_set_step(3);
 8002bb6:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(4);
 8002bb8:	f7fd fc0a 	bl	80003d0 <chEvtAddEvents>
  }

  /* [8.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
 8002bbc:	2304      	movs	r3, #4
 8002bbe:	6023      	str	r3, [r4, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 8002bc0:	f000 fe8e 	bl	80038e0 <test_wait_tick>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002bc4:	4b1b      	ldr	r3, [pc, #108]	; (8002c34 <rt_test_008_005_execute.lto_priv.122+0xc4>)
 8002bc6:	1c06      	adds	r6, r0, #0
 8002bc8:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8002bca:	481b      	ldr	r0, [pc, #108]	; (8002c38 <rt_test_008_005_execute.lto_priv.122+0xc8>)
 8002bcc:	689a      	ldr	r2, [r3, #8]
 8002bce:	1e51      	subs	r1, r2, #1
 8002bd0:	4a1a      	ldr	r2, [pc, #104]	; (8002c3c <rt_test_008_005_execute.lto_priv.122+0xcc>)
 8002bd2:	f002 f995 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8002bd6:	4b1a      	ldr	r3, [pc, #104]	; (8002c40 <rt_test_008_005_execute.lto_priv.122+0xd0>)
 8002bd8:	6018      	str	r0, [r3, #0]
  }

  /* [8.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
 8002bda:	2305      	movs	r3, #5
 8002bdc:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAll(5);
 8002bde:	f002 faa7 	bl	8005130 <chEvtWaitAll.constprop.14>
 8002be2:	2382      	movs	r3, #130	; 0x82
 8002be4:	1c04      	adds	r4, r0, #0
 8002be6:	1c30      	adds	r0, r6, #0
 8002be8:	009b      	lsls	r3, r3, #2
 8002bea:	30f5      	adds	r0, #245	; 0xf5
 8002bec:	30ff      	adds	r0, #255	; 0xff
 8002bee:	18f1      	adds	r1, r6, r3
    test_assert_time_window(target_time,
 8002bf0:	f002 fbce 	bl	8005390 <_test_assert_time_window.constprop.2>
 8002bf4:	2800      	cmp	r0, #0
 8002bf6:	d1cf      	bne.n	8002b98 <rt_test_008_005_execute.lto_priv.122+0x28>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    test_assert(m == 5, "event flags error");
 8002bf8:	1f60      	subs	r0, r4, #5
 8002bfa:	4243      	negs	r3, r0
 8002bfc:	4143      	adcs	r3, r0
 8002bfe:	4911      	ldr	r1, [pc, #68]	; (8002c44 <rt_test_008_005_execute.lto_priv.122+0xd4>)
 8002c00:	b2d8      	uxtb	r0, r3
 8002c02:	f001 f97d 	bl	8003f00 <_test_assert>
 8002c06:	2800      	cmp	r0, #0
 8002c08:	d1c6      	bne.n	8002b98 <rt_test_008_005_execute.lto_priv.122+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8002c0a:	f002 fa51 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
 8002c0e:	1c03      	adds	r3, r0, #0
    test_assert(m == 0, "stuck event");
 8002c10:	4258      	negs	r0, r3
 8002c12:	4158      	adcs	r0, r3
 8002c14:	1c29      	adds	r1, r5, #0
 8002c16:	b2c0      	uxtb	r0, r0
 8002c18:	f001 f972 	bl	8003f00 <_test_assert>
 8002c1c:	2800      	cmp	r0, #0
 8002c1e:	d1bb      	bne.n	8002b98 <rt_test_008_005_execute.lto_priv.122+0x28>
    test_wait_threads();
 8002c20:	f000 fe6e 	bl	8003900 <test_wait_threads>
 8002c24:	e7b8      	b.n	8002b98 <rt_test_008_005_execute.lto_priv.122+0x28>
 8002c26:	46c0      	nop			; (mov r8, r8)
 8002c28:	20000d64 	.word	0x20000d64
 8002c2c:	080057b4 	.word	0x080057b4
 8002c30:	08005788 	.word	0x08005788
 8002c34:	20000e84 	.word	0x20000e84
 8002c38:	200006e8 	.word	0x200006e8
 8002c3c:	080045c1 	.word	0x080045c1
 8002c40:	20000d68 	.word	0x20000d68
 8002c44:	080057cc 	.word	0x080057cc
 8002c48:	46c0      	nop			; (mov r8, r8)
 8002c4a:	46c0      	nop			; (mov r8, r8)
 8002c4c:	46c0      	nop			; (mov r8, r8)
 8002c4e:	46c0      	nop			; (mov r8, r8)

08002c50 <bmk_thread3>:
  (void)chMsgSend(tp, 0);
  return n;
}
#endif

static THD_FUNCTION(bmk_thread3, p) {
 8002c50:	b508      	push	{r3, lr}

  chThdExit((msg_t)p);
 8002c52:	f7fd fead 	bl	80009b0 <chThdExit>
}
 8002c56:	bd08      	pop	{r3, pc}
 8002c58:	46c0      	nop			; (mov r8, r8)
 8002c5a:	46c0      	nop			; (mov r8, r8)
 8002c5c:	46c0      	nop			; (mov r8, r8)
 8002c5e:	46c0      	nop			; (mov r8, r8)

08002c60 <rt_test_010_011_setup>:
 8002c60:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002c62:	4b02      	ldr	r3, [pc, #8]	; (8002c6c <rt_test_010_011_setup+0xc>)
 8002c64:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002c66:	605b      	str	r3, [r3, #4]
 8002c68:	609a      	str	r2, [r3, #8]
 * .
 */

static void rt_test_010_011_setup(void) {
  chMtxObjectInit(&mtx1);
}
 8002c6a:	4770      	bx	lr
 8002c6c:	20000e58 	.word	0x20000e58

08002c70 <rt_test_010_010_setup>:
 8002c70:	2201      	movs	r2, #1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002c72:	4b02      	ldr	r3, [pc, #8]	; (8002c7c <rt_test_010_010_setup+0xc>)
 8002c74:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002c76:	605b      	str	r3, [r3, #4]
 8002c78:	609a      	str	r2, [r3, #8]
 * .
 */

static void rt_test_010_010_setup(void) {
  chSemObjectInit(&sem1, 1);
}
 8002c7a:	4770      	bx	lr
 8002c7c:	20000e68 	.word	0x20000e68

08002c80 <Thread1>:

/*
 * Green LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8002c80:	b538      	push	{r3, r4, r5, lr}

  (void)arg;
  chRegSetThreadName("blinker");

  while (true) {
    palClearLine(LINE_LED_GREEN);
 8002c82:	2408      	movs	r4, #8
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8002c84:	4b06      	ldr	r3, [pc, #24]	; (8002ca0 <Thread1+0x20>)
 8002c86:	4a07      	ldr	r2, [pc, #28]	; (8002ca4 <Thread1+0x24>)
 8002c88:	699b      	ldr	r3, [r3, #24]
 8002c8a:	4d07      	ldr	r5, [pc, #28]	; (8002ca8 <Thread1+0x28>)
 8002c8c:	619a      	str	r2, [r3, #24]
 8002c8e:	836c      	strh	r4, [r5, #26]
    chThdSleepMilliseconds(500);
 8002c90:	4806      	ldr	r0, [pc, #24]	; (8002cac <Thread1+0x2c>)
 8002c92:	f7fe f98d 	bl	8000fb0 <chThdSleep>
    palSetLine(LINE_LED_GREEN);
 8002c96:	832c      	strh	r4, [r5, #24]
    chThdSleepMilliseconds(500);
 8002c98:	4804      	ldr	r0, [pc, #16]	; (8002cac <Thread1+0x2c>)
 8002c9a:	f7fe f989 	bl	8000fb0 <chThdSleep>
 8002c9e:	e7f6      	b.n	8002c8e <Thread1+0xe>
 8002ca0:	20000e84 	.word	0x20000e84
 8002ca4:	08005b50 	.word	0x08005b50
 8002ca8:	48000400 	.word	0x48000400
 8002cac:	00001388 	.word	0x00001388

08002cb0 <rt_test_010_012_execute>:
 * - [10.12.8] The size of an event listener is printed.
 * - [10.12.9] The size of a mailbox is printed.
 * .
 */

static void rt_test_010_012_execute(void) {
 8002cb0:	b538      	push	{r3, r4, r5, lr}

  /* [10.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8002cb2:	2301      	movs	r3, #1
 8002cb4:	4d32      	ldr	r5, [pc, #200]	; (8002d80 <rt_test_010_012_execute+0xd0>)
  {
    test_print("--- System: ");
 8002cb6:	4833      	ldr	r0, [pc, #204]	; (8002d84 <rt_test_010_012_execute+0xd4>)
 */

static void rt_test_010_012_execute(void) {

  /* [10.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8002cb8:	602b      	str	r3, [r5, #0]
  {
    test_print("--- System: ");
 8002cba:	f000 fe81 	bl	80039c0 <test_print>
    test_printn(sizeof(ch_system_t));
 8002cbe:	2074      	movs	r0, #116	; 0x74
 8002cc0:	f000 fdde 	bl	8003880 <test_printn>
    test_println(" bytes");
 8002cc4:	4c30      	ldr	r4, [pc, #192]	; (8002d88 <rt_test_010_012_execute+0xd8>)
 8002cc6:	1c20      	adds	r0, r4, #0
 8002cc8:	f000 fe5a 	bl	8003980 <test_println>
  }

  /* [10.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 8002ccc:	2302      	movs	r3, #2
  {
    test_print("--- Thread: ");
 8002cce:	482f      	ldr	r0, [pc, #188]	; (8002d8c <rt_test_010_012_execute+0xdc>)
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
  }

  /* [10.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 8002cd0:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Thread: ");
 8002cd2:	f000 fe75 	bl	80039c0 <test_print>
    test_printn(sizeof(thread_t));
 8002cd6:	2044      	movs	r0, #68	; 0x44
 8002cd8:	f000 fdd2 	bl	8003880 <test_printn>
    test_println(" bytes");
 8002cdc:	1c20      	adds	r0, r4, #0
 8002cde:	f000 fe4f 	bl	8003980 <test_println>
  }

  /* [10.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 8002ce2:	2303      	movs	r3, #3
  {
    test_print("--- Timer : ");
 8002ce4:	482a      	ldr	r0, [pc, #168]	; (8002d90 <rt_test_010_012_execute+0xe0>)
    test_printn(sizeof(thread_t));
    test_println(" bytes");
  }

  /* [10.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 8002ce6:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Timer : ");
 8002ce8:	f000 fe6a 	bl	80039c0 <test_print>
    test_printn(sizeof(virtual_timer_t));
 8002cec:	2014      	movs	r0, #20
 8002cee:	f000 fdc7 	bl	8003880 <test_printn>
    test_println(" bytes");
 8002cf2:	1c20      	adds	r0, r4, #0
 8002cf4:	f000 fe44 	bl	8003980 <test_println>
  }

  /* [10.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 8002cf8:	2304      	movs	r3, #4
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 8002cfa:	4826      	ldr	r0, [pc, #152]	; (8002d94 <rt_test_010_012_execute+0xe4>)
    test_printn(sizeof(virtual_timer_t));
    test_println(" bytes");
  }

  /* [10.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 8002cfc:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 8002cfe:	f000 fe5f 	bl	80039c0 <test_print>
    test_printn(sizeof(semaphore_t));
 8002d02:	200c      	movs	r0, #12
 8002d04:	f000 fdbc 	bl	8003880 <test_printn>
    test_println(" bytes");
 8002d08:	1c20      	adds	r0, r4, #0
 8002d0a:	f000 fe39 	bl	8003980 <test_println>
#endif
  }

  /* [10.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 8002d0e:	2305      	movs	r3, #5
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 8002d10:	4821      	ldr	r0, [pc, #132]	; (8002d98 <rt_test_010_012_execute+0xe8>)
    test_println(" bytes");
#endif
  }

  /* [10.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 8002d12:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 8002d14:	f000 fe54 	bl	80039c0 <test_print>
    test_printn(sizeof(mutex_t));
 8002d18:	2010      	movs	r0, #16
 8002d1a:	f000 fdb1 	bl	8003880 <test_printn>
    test_println(" bytes");
 8002d1e:	1c20      	adds	r0, r4, #0
 8002d20:	f000 fe2e 	bl	8003980 <test_println>
#endif
  }

  /* [10.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8002d24:	2306      	movs	r3, #6
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 8002d26:	481d      	ldr	r0, [pc, #116]	; (8002d9c <rt_test_010_012_execute+0xec>)
    test_println(" bytes");
#endif
  }

  /* [10.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8002d28:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 8002d2a:	f000 fe49 	bl	80039c0 <test_print>
    test_printn(sizeof(condition_variable_t));
 8002d2e:	2008      	movs	r0, #8
 8002d30:	f000 fda6 	bl	8003880 <test_printn>
    test_println(" bytes");
 8002d34:	1c20      	adds	r0, r4, #0
 8002d36:	f000 fe23 	bl	8003980 <test_println>
#endif
  }

  /* [10.12.7] The size of an event source is printed.*/
  test_set_step(7);
 8002d3a:	2307      	movs	r3, #7
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 8002d3c:	4818      	ldr	r0, [pc, #96]	; (8002da0 <rt_test_010_012_execute+0xf0>)
    test_println(" bytes");
#endif
  }

  /* [10.12.7] The size of an event source is printed.*/
  test_set_step(7);
 8002d3e:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 8002d40:	f000 fe3e 	bl	80039c0 <test_print>
    test_printn(sizeof(event_source_t));
 8002d44:	2004      	movs	r0, #4
 8002d46:	f000 fd9b 	bl	8003880 <test_printn>
    test_println(" bytes");
 8002d4a:	1c20      	adds	r0, r4, #0
 8002d4c:	f000 fe18 	bl	8003980 <test_println>
#endif
  }

  /* [10.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 8002d50:	2308      	movs	r3, #8
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 8002d52:	4814      	ldr	r0, [pc, #80]	; (8002da4 <rt_test_010_012_execute+0xf4>)
    test_println(" bytes");
#endif
  }

  /* [10.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 8002d54:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 8002d56:	f000 fe33 	bl	80039c0 <test_print>
    test_printn(sizeof(event_listener_t));
 8002d5a:	2014      	movs	r0, #20
 8002d5c:	f000 fd90 	bl	8003880 <test_printn>
    test_println(" bytes");
 8002d60:	1c20      	adds	r0, r4, #0
 8002d62:	f000 fe0d 	bl	8003980 <test_println>
#endif
  }

  /* [10.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 8002d66:	2309      	movs	r3, #9
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 8002d68:	480f      	ldr	r0, [pc, #60]	; (8002da8 <rt_test_010_012_execute+0xf8>)
    test_println(" bytes");
#endif
  }

  /* [10.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 8002d6a:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 8002d6c:	f000 fe28 	bl	80039c0 <test_print>
    test_printn(sizeof(mailbox_t));
 8002d70:	2028      	movs	r0, #40	; 0x28
 8002d72:	f000 fd85 	bl	8003880 <test_printn>
    test_println(" bytes");
 8002d76:	1c20      	adds	r0, r4, #0
 8002d78:	f000 fe02 	bl	8003980 <test_println>
#endif
  }
}
 8002d7c:	bd38      	pop	{r3, r4, r5, pc}
 8002d7e:	46c0      	nop			; (mov r8, r8)
 8002d80:	20000d64 	.word	0x20000d64
 8002d84:	08005b58 	.word	0x08005b58
 8002d88:	08005b68 	.word	0x08005b68
 8002d8c:	08005b70 	.word	0x08005b70
 8002d90:	08005b80 	.word	0x08005b80
 8002d94:	08005b90 	.word	0x08005b90
 8002d98:	08005ba0 	.word	0x08005ba0
 8002d9c:	08005bb0 	.word	0x08005bb0
 8002da0:	08005bc0 	.word	0x08005bc0
 8002da4:	08005bd0 	.word	0x08005bd0
 8002da8:	08005be0 	.word	0x08005be0
 8002dac:	46c0      	nop			; (mov r8, r8)
 8002dae:	46c0      	nop			; (mov r8, r8)

08002db0 <rt_test_010_011_execute>:

static void rt_test_010_011_setup(void) {
  chMtxObjectInit(&mtx1);
}

static void rt_test_010_011_execute(void) {
 8002db0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;

  /* [10.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002db2:	4b1f      	ldr	r3, [pc, #124]	; (8002e30 <rt_test_010_011_execute+0x80>)

static void rt_test_010_011_setup(void) {
  chMtxObjectInit(&mtx1);
}

static void rt_test_010_011_execute(void) {
 8002db4:	464f      	mov	r7, r9
  uint32_t n;

  /* [10.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002db6:	4699      	mov	r9, r3

static void rt_test_010_011_setup(void) {
  chMtxObjectInit(&mtx1);
}

static void rt_test_010_011_execute(void) {
 8002db8:	4646      	mov	r6, r8
  uint32_t n;

  /* [10.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002dba:	2301      	movs	r3, #1
 8002dbc:	464a      	mov	r2, r9

static void rt_test_010_011_setup(void) {
  chMtxObjectInit(&mtx1);
}

static void rt_test_010_011_execute(void) {
 8002dbe:	b4c0      	push	{r6, r7}
  uint32_t n;

  /* [10.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002dc0:	6013      	str	r3, [r2, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8002dc2:	f000 fd8d 	bl	80038e0 <test_wait_tick>
 8002dc6:	2780      	movs	r7, #128	; 0x80
 8002dc8:	4680      	mov	r8, r0
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 8002dca:	2500      	movs	r5, #0
 8002dcc:	4c19      	ldr	r4, [pc, #100]	; (8002e34 <rt_test_010_011_execute+0x84>)
      chMtxUnlock(&mtx1);
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8002dce:	4e1a      	ldr	r6, [pc, #104]	; (8002e38 <rt_test_010_011_execute+0x88>)
 8002dd0:	05ff      	lsls	r7, r7, #23

    n = 0;
    start = test_wait_tick();
    end = chTimeAddX(start, TIME_MS2I(1000));
    do {
      chMtxLock(&mtx1);
 8002dd2:	1c20      	adds	r0, r4, #0
 8002dd4:	f7fd fd34 	bl	8000840 <chMtxLock>
      chMtxUnlock(&mtx1);
 8002dd8:	1c20      	adds	r0, r4, #0
 8002dda:	f7fd fc99 	bl	8000710 <chMtxUnlock>
      chMtxLock(&mtx1);
 8002dde:	1c20      	adds	r0, r4, #0
 8002de0:	f7fd fd2e 	bl	8000840 <chMtxLock>
      chMtxUnlock(&mtx1);
 8002de4:	1c20      	adds	r0, r4, #0
 8002de6:	f7fd fc93 	bl	8000710 <chMtxUnlock>
      chMtxLock(&mtx1);
 8002dea:	1c20      	adds	r0, r4, #0
 8002dec:	f7fd fd28 	bl	8000840 <chMtxLock>
      chMtxUnlock(&mtx1);
 8002df0:	1c20      	adds	r0, r4, #0
 8002df2:	f7fd fc8d 	bl	8000710 <chMtxUnlock>
      chMtxLock(&mtx1);
 8002df6:	1c20      	adds	r0, r4, #0
 8002df8:	f7fd fd22 	bl	8000840 <chMtxLock>
      chMtxUnlock(&mtx1);
 8002dfc:	1c20      	adds	r0, r4, #0
 8002dfe:	f7fd fc87 	bl	8000710 <chMtxUnlock>
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((time - start) < (end - start));
 8002e02:	4642      	mov	r2, r8
 8002e04:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      n++;
 8002e06:	3501      	adds	r5, #1
 8002e08:	1a9b      	subs	r3, r3, r2
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8002e0a:	42b3      	cmp	r3, r6
 8002e0c:	d9e1      	bls.n	8002dd2 <rt_test_010_011_execute+0x22>
  }

  /* [10.11.2] The score is printed.*/
  test_set_step(2);
 8002e0e:	464a      	mov	r2, r9
 8002e10:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 8002e12:	480a      	ldr	r0, [pc, #40]	; (8002e3c <rt_test_010_011_execute+0x8c>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [10.11.2] The score is printed.*/
  test_set_step(2);
 8002e14:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 8002e16:	f000 fdd3 	bl	80039c0 <test_print>
    test_printn(n * 4);
 8002e1a:	00a8      	lsls	r0, r5, #2
 8002e1c:	f000 fd30 	bl	8003880 <test_printn>
    test_println(" lock+unlock/S");
 8002e20:	4807      	ldr	r0, [pc, #28]	; (8002e40 <rt_test_010_011_execute+0x90>)
 8002e22:	f000 fdad 	bl	8003980 <test_println>
  }
}
 8002e26:	bc0c      	pop	{r2, r3}
 8002e28:	4690      	mov	r8, r2
 8002e2a:	4699      	mov	r9, r3
 8002e2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002e2e:	46c0      	nop			; (mov r8, r8)
 8002e30:	20000d64 	.word	0x20000d64
 8002e34:	20000e58 	.word	0x20000e58
 8002e38:	0000270f 	.word	0x0000270f
 8002e3c:	08005650 	.word	0x08005650
 8002e40:	08005bf0 	.word	0x08005bf0
 8002e44:	46c0      	nop			; (mov r8, r8)
 8002e46:	46c0      	nop			; (mov r8, r8)
 8002e48:	46c0      	nop			; (mov r8, r8)
 8002e4a:	46c0      	nop			; (mov r8, r8)
 8002e4c:	46c0      	nop			; (mov r8, r8)
 8002e4e:	46c0      	nop			; (mov r8, r8)

08002e50 <rt_test_010_010_execute>:

static void rt_test_010_010_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void rt_test_010_010_execute(void) {
 8002e50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;

  /* [10.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002e52:	4b1f      	ldr	r3, [pc, #124]	; (8002ed0 <rt_test_010_010_execute+0x80>)

static void rt_test_010_010_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void rt_test_010_010_execute(void) {
 8002e54:	464f      	mov	r7, r9
  uint32_t n;

  /* [10.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002e56:	4699      	mov	r9, r3

static void rt_test_010_010_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void rt_test_010_010_execute(void) {
 8002e58:	4646      	mov	r6, r8
  uint32_t n;

  /* [10.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002e5a:	2301      	movs	r3, #1
 8002e5c:	464a      	mov	r2, r9

static void rt_test_010_010_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void rt_test_010_010_execute(void) {
 8002e5e:	b4c0      	push	{r6, r7}
  uint32_t n;

  /* [10.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002e60:	6013      	str	r3, [r2, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8002e62:	f000 fd3d 	bl	80038e0 <test_wait_tick>
 8002e66:	2780      	movs	r7, #128	; 0x80
 8002e68:	4680      	mov	r8, r0
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 8002e6a:	2500      	movs	r5, #0
 8002e6c:	4c19      	ldr	r4, [pc, #100]	; (8002ed4 <rt_test_010_010_execute+0x84>)
      chSemSignal(&sem1);
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8002e6e:	4e1a      	ldr	r6, [pc, #104]	; (8002ed8 <rt_test_010_010_execute+0x88>)
 8002e70:	05ff      	lsls	r7, r7, #23

    n = 0;
    start = test_wait_tick();
    end = chTimeAddX(start, TIME_MS2I(1000));
    do {
      chSemWait(&sem1);
 8002e72:	1c20      	adds	r0, r4, #0
 8002e74:	f7fd fbec 	bl	8000650 <chSemWait>
      chSemSignal(&sem1);
 8002e78:	1c20      	adds	r0, r4, #0
 8002e7a:	f7fd fbb9 	bl	80005f0 <chSemSignal>
      chSemWait(&sem1);
 8002e7e:	1c20      	adds	r0, r4, #0
 8002e80:	f7fd fbe6 	bl	8000650 <chSemWait>
      chSemSignal(&sem1);
 8002e84:	1c20      	adds	r0, r4, #0
 8002e86:	f7fd fbb3 	bl	80005f0 <chSemSignal>
      chSemWait(&sem1);
 8002e8a:	1c20      	adds	r0, r4, #0
 8002e8c:	f7fd fbe0 	bl	8000650 <chSemWait>
      chSemSignal(&sem1);
 8002e90:	1c20      	adds	r0, r4, #0
 8002e92:	f7fd fbad 	bl	80005f0 <chSemSignal>
      chSemWait(&sem1);
 8002e96:	1c20      	adds	r0, r4, #0
 8002e98:	f7fd fbda 	bl	8000650 <chSemWait>
      chSemSignal(&sem1);
 8002e9c:	1c20      	adds	r0, r4, #0
 8002e9e:	f7fd fba7 	bl	80005f0 <chSemSignal>
 8002ea2:	4642      	mov	r2, r8
 8002ea4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      n++;
 8002ea6:	3501      	adds	r5, #1
 8002ea8:	1a9b      	subs	r3, r3, r2
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8002eaa:	42b3      	cmp	r3, r6
 8002eac:	d9e1      	bls.n	8002e72 <rt_test_010_010_execute+0x22>
  }

  /* [10.10.2] The score is printed.*/
  test_set_step(2);
 8002eae:	464a      	mov	r2, r9
 8002eb0:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 8002eb2:	480a      	ldr	r0, [pc, #40]	; (8002edc <rt_test_010_010_execute+0x8c>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [10.10.2] The score is printed.*/
  test_set_step(2);
 8002eb4:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 8002eb6:	f000 fd83 	bl	80039c0 <test_print>
    test_printn(n * 4);
 8002eba:	00a8      	lsls	r0, r5, #2
 8002ebc:	f000 fce0 	bl	8003880 <test_printn>
    test_println(" wait+signal/S");
 8002ec0:	4807      	ldr	r0, [pc, #28]	; (8002ee0 <rt_test_010_010_execute+0x90>)
 8002ec2:	f000 fd5d 	bl	8003980 <test_println>
  }
}
 8002ec6:	bc0c      	pop	{r2, r3}
 8002ec8:	4690      	mov	r8, r2
 8002eca:	4699      	mov	r9, r3
 8002ecc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002ece:	46c0      	nop			; (mov r8, r8)
 8002ed0:	20000d64 	.word	0x20000d64
 8002ed4:	20000e68 	.word	0x20000e68
 8002ed8:	0000270f 	.word	0x0000270f
 8002edc:	08005650 	.word	0x08005650
 8002ee0:	08005c00 	.word	0x08005c00
 8002ee4:	46c0      	nop			; (mov r8, r8)
 8002ee6:	46c0      	nop			; (mov r8, r8)
 8002ee8:	46c0      	nop			; (mov r8, r8)
 8002eea:	46c0      	nop			; (mov r8, r8)
 8002eec:	46c0      	nop			; (mov r8, r8)
 8002eee:	46c0      	nop			; (mov r8, r8)

08002ef0 <rt_test_010_009_execute>:
 *   one-second time window.
 * - [10.9.2] The score is printed.
 * .
 */

static void rt_test_010_009_execute(void) {
 8002ef0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t n;

  /* [10.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8002ef2:	4b21      	ldr	r3, [pc, #132]	; (8002f78 <rt_test_010_009_execute+0x88>)
 *   one-second time window.
 * - [10.9.2] The score is printed.
 * .
 */

static void rt_test_010_009_execute(void) {
 8002ef4:	465f      	mov	r7, fp
  uint32_t n;

  /* [10.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8002ef6:	469b      	mov	fp, r3
 *   one-second time window.
 * - [10.9.2] The score is printed.
 * .
 */

static void rt_test_010_009_execute(void) {
 8002ef8:	4656      	mov	r6, sl
 8002efa:	464d      	mov	r5, r9
 8002efc:	4644      	mov	r4, r8
  uint32_t n;

  /* [10.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8002efe:	2301      	movs	r3, #1
 8002f00:	465a      	mov	r2, fp
 *   one-second time window.
 * - [10.9.2] The score is printed.
 * .
 */

static void rt_test_010_009_execute(void) {
 8002f02:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t n;

  /* [10.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8002f04:	6013      	str	r3, [r2, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8002f06:	f000 fceb 	bl	80038e0 <test_wait_tick>
 8002f0a:	2380      	movs	r3, #128	; 0x80
 8002f0c:	05db      	lsls	r3, r3, #23
 8002f0e:	4699      	mov	r9, r3
      chSysUnlock();
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8002f10:	4b1a      	ldr	r3, [pc, #104]	; (8002f7c <rt_test_010_009_execute+0x8c>)
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8002f12:	4682      	mov	sl, r0
     one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 8002f14:	2400      	movs	r4, #0
      chSysUnlock();
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8002f16:	4698      	mov	r8, r3
 8002f18:	4f19      	ldr	r7, [pc, #100]	; (8002f80 <rt_test_010_009_execute+0x90>)
 8002f1a:	4e1a      	ldr	r6, [pc, #104]	; (8002f84 <rt_test_010_009_execute+0x94>)
 8002f1c:	4d1a      	ldr	r5, [pc, #104]	; (8002f88 <rt_test_010_009_execute+0x98>)
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002f1e:	b672      	cpsid	i
    n = 0;
    start = test_wait_tick();
    end = chTimeAddX(start, TIME_MS2I(1000));
    do {
      chSysLock();
      chVTDoSetI(&vt1, 1, tmo, NULL);
 8002f20:	2101      	movs	r1, #1
 8002f22:	1c38      	adds	r0, r7, #0
 8002f24:	1c32      	adds	r2, r6, #0
 8002f26:	2300      	movs	r3, #0
 8002f28:	f7fd fe72 	bl	8000c10 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 8002f2c:	4917      	ldr	r1, [pc, #92]	; (8002f8c <rt_test_010_009_execute+0x9c>)
 8002f2e:	1c32      	adds	r2, r6, #0
 8002f30:	2300      	movs	r3, #0
 8002f32:	1c28      	adds	r0, r5, #0
 8002f34:	f7fd fe6c 	bl	8000c10 <chVTDoSetI>
      chVTDoResetI(&vt1);
 8002f38:	1c38      	adds	r0, r7, #0
 8002f3a:	f7fd fe29 	bl	8000b90 <chVTDoResetI>
      chVTDoResetI(&vt2);
 8002f3e:	1c28      	adds	r0, r5, #0
 8002f40:	f7fd fe26 	bl	8000b90 <chVTDoResetI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002f44:	b662      	cpsie	i
 8002f46:	464b      	mov	r3, r9
 8002f48:	4652      	mov	r2, sl
 8002f4a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      chSysUnlock();
      n++;
 8002f4c:	3401      	adds	r4, #1
 8002f4e:	1a9b      	subs	r3, r3, r2
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8002f50:	4543      	cmp	r3, r8
 8002f52:	d9e4      	bls.n	8002f1e <rt_test_010_009_execute+0x2e>
  }

  /* [10.9.2] The score is printed.*/
  test_set_step(2);
 8002f54:	465a      	mov	r2, fp
 8002f56:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 8002f58:	480d      	ldr	r0, [pc, #52]	; (8002f90 <rt_test_010_009_execute+0xa0>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [10.9.2] The score is printed.*/
  test_set_step(2);
 8002f5a:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 8002f5c:	f000 fd30 	bl	80039c0 <test_print>
    test_printn(n * 2);
 8002f60:	0060      	lsls	r0, r4, #1
 8002f62:	f000 fc8d 	bl	8003880 <test_printn>
    test_println(" timers/S");
 8002f66:	480b      	ldr	r0, [pc, #44]	; (8002f94 <rt_test_010_009_execute+0xa4>)
 8002f68:	f000 fd0a 	bl	8003980 <test_println>
  }
}
 8002f6c:	bc3c      	pop	{r2, r3, r4, r5}
 8002f6e:	4690      	mov	r8, r2
 8002f70:	4699      	mov	r9, r3
 8002f72:	46a2      	mov	sl, r4
 8002f74:	46ab      	mov	fp, r5
 8002f76:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002f78:	20000d64 	.word	0x20000d64
 8002f7c:	0000270f 	.word	0x0000270f
 8002f80:	20000588 	.word	0x20000588
 8002f84:	08001fa1 	.word	0x08001fa1
 8002f88:	20000d50 	.word	0x20000d50
 8002f8c:	00002710 	.word	0x00002710
 8002f90:	08005650 	.word	0x08005650
 8002f94:	08005c10 	.word	0x08005c10
 8002f98:	46c0      	nop			; (mov r8, r8)
 8002f9a:	46c0      	nop			; (mov r8, r8)
 8002f9c:	46c0      	nop			; (mov r8, r8)
 8002f9e:	46c0      	nop			; (mov r8, r8)

08002fa0 <rt_test_010_008_execute>:
  uint32_t n;

  /* [10.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 8002fa0:	4b2f      	ldr	r3, [pc, #188]	; (8003060 <rt_test_010_008_execute+0xc0>)
 * - [10.8.2] Waiting one second then terminating the 5 threads.
 * - [10.8.3] The score is printed.
 * .
 */

static void rt_test_010_008_execute(void) {
 8002fa2:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002fa4:	4647      	mov	r7, r8
  uint32_t n;

  /* [10.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 8002fa6:	4698      	mov	r8, r3
 8002fa8:	2301      	movs	r3, #1
 8002faa:	4642      	mov	r2, r8
 * - [10.8.2] Waiting one second then terminating the 5 threads.
 * - [10.8.3] The score is printed.
 * .
 */

static void rt_test_010_008_execute(void) {
 8002fac:	b480      	push	{r7}
  uint32_t n;

  /* [10.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 8002fae:	6013      	str	r3, [r2, #0]
  {
    n = 0;
 8002fb0:	2300      	movs	r3, #0
 * - [10.8.2] Waiting one second then terminating the 5 threads.
 * - [10.8.3] The score is printed.
 * .
 */

static void rt_test_010_008_execute(void) {
 8002fb2:	b082      	sub	sp, #8
  /* [10.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
  {
    n = 0;
 8002fb4:	9301      	str	r3, [sp, #4]
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8002fb6:	f000 fc93 	bl	80038e0 <test_wait_tick>
 8002fba:	4f2a      	ldr	r7, [pc, #168]	; (8003064 <rt_test_010_008_execute+0xc4>)
 8002fbc:	4c2a      	ldr	r4, [pc, #168]	; (8003068 <rt_test_010_008_execute+0xc8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002fbe:	69bb      	ldr	r3, [r7, #24]
 8002fc0:	4e2a      	ldr	r6, [pc, #168]	; (800306c <rt_test_010_008_execute+0xcc>)
 8002fc2:	6899      	ldr	r1, [r3, #8]
 8002fc4:	1c32      	adds	r2, r6, #0
 8002fc6:	ab01      	add	r3, sp, #4
 8002fc8:	3901      	subs	r1, #1
 8002fca:	1c20      	adds	r0, r4, #0
 8002fcc:	f001 ff98 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8002fd0:	4d27      	ldr	r5, [pc, #156]	; (8003070 <rt_test_010_008_execute+0xd0>)
 8002fd2:	69bb      	ldr	r3, [r7, #24]
 8002fd4:	6028      	str	r0, [r5, #0]

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8002fd6:	1c20      	adds	r0, r4, #0
 8002fd8:	6899      	ldr	r1, [r3, #8]
 8002fda:	3049      	adds	r0, #73	; 0x49
 8002fdc:	1c32      	adds	r2, r6, #0
 8002fde:	ab01      	add	r3, sp, #4
 8002fe0:	3901      	subs	r1, #1
 8002fe2:	30ff      	adds	r0, #255	; 0xff
 8002fe4:	f001 ff8c 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8002fe8:	23a4      	movs	r3, #164	; 0xa4
 8002fea:	009b      	lsls	r3, r3, #2
  test_set_step(1);
  {
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8002fec:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8002fee:	18e0      	adds	r0, r4, r3
 8002ff0:	69bb      	ldr	r3, [r7, #24]
 8002ff2:	1c32      	adds	r2, r6, #0
 8002ff4:	6899      	ldr	r1, [r3, #8]
 8002ff6:	ab01      	add	r3, sp, #4
 8002ff8:	3901      	subs	r1, #1
 8002ffa:	f001 ff81 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8002ffe:	23f6      	movs	r3, #246	; 0xf6
 8003000:	009b      	lsls	r3, r3, #2
  {
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003002:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003004:	18e0      	adds	r0, r4, r3
 8003006:	69bb      	ldr	r3, [r7, #24]
 8003008:	1c32      	adds	r2, r6, #0
 800300a:	6899      	ldr	r1, [r3, #8]
 800300c:	ab01      	add	r3, sp, #4
 800300e:	3901      	subs	r1, #1
 8003010:	f001 ff76 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003014:	23a4      	movs	r3, #164	; 0xa4
 8003016:	00db      	lsls	r3, r3, #3
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8003018:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800301a:	18e0      	adds	r0, r4, r3
 800301c:	69bb      	ldr	r3, [r7, #24]
 800301e:	1c32      	adds	r2, r6, #0
 8003020:	6899      	ldr	r1, [r3, #8]
 8003022:	ab01      	add	r3, sp, #4
 8003024:	3901      	subs	r1, #1
 8003026:	f001 ff6b 	bl	8004f00 <chThdCreateStatic.constprop.40>
  }

  /* [10.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 800302a:	4642      	mov	r2, r8
 800302c:	2302      	movs	r3, #2
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 800302e:	6128      	str	r0, [r5, #16]
  }

  /* [10.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
  {
    chThdSleepSeconds(1);
 8003030:	4810      	ldr	r0, [pc, #64]	; (8003074 <rt_test_010_008_execute+0xd4>)
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  }

  /* [10.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 8003032:	6013      	str	r3, [r2, #0]
  {
    chThdSleepSeconds(1);
 8003034:	f7fd ffbc 	bl	8000fb0 <chThdSleep>
    test_terminate_threads();
 8003038:	f000 fc7a 	bl	8003930 <test_terminate_threads>
    test_wait_threads();
 800303c:	f000 fc60 	bl	8003900 <test_wait_threads>
  }

  /* [10.8.3] The score is printed.*/
  test_set_step(3);
 8003040:	2303      	movs	r3, #3
 8003042:	4642      	mov	r2, r8
  {
    test_print("--- Score : ");
 8003044:	480c      	ldr	r0, [pc, #48]	; (8003078 <rt_test_010_008_execute+0xd8>)
    test_terminate_threads();
    test_wait_threads();
  }

  /* [10.8.3] The score is printed.*/
  test_set_step(3);
 8003046:	6013      	str	r3, [r2, #0]
  {
    test_print("--- Score : ");
 8003048:	f000 fcba 	bl	80039c0 <test_print>
    test_printn(n);
 800304c:	9801      	ldr	r0, [sp, #4]
 800304e:	f000 fc17 	bl	8003880 <test_printn>
    test_println(" ctxswc/S");
 8003052:	480a      	ldr	r0, [pc, #40]	; (800307c <rt_test_010_008_execute+0xdc>)
 8003054:	f000 fc94 	bl	8003980 <test_println>
  }
}
 8003058:	b002      	add	sp, #8
 800305a:	bc04      	pop	{r2}
 800305c:	4690      	mov	r8, r2
 800305e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003060:	20000d64 	.word	0x20000d64
 8003064:	20000e84 	.word	0x20000e84
 8003068:	200006e8 	.word	0x200006e8
 800306c:	08002391 	.word	0x08002391
 8003070:	20000d68 	.word	0x20000d68
 8003074:	00002710 	.word	0x00002710
 8003078:	08005650 	.word	0x08005650
 800307c:	08005674 	.word	0x08005674

08003080 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8003080:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003082:	4644      	mov	r4, r8
 8003084:	465f      	mov	r7, fp
 8003086:	4656      	mov	r6, sl
 8003088:	464d      	mov	r5, r9
void hal_lld_init(void) {

  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB(~STM32_GPIO_EN_MASK);
 800308a:	4bf4      	ldr	r3, [pc, #976]	; (800345c <main+0x3dc>)
 800308c:	49f4      	ldr	r1, [pc, #976]	; (8003460 <main+0x3e0>)
 800308e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8003090:	b4f0      	push	{r4, r5, r6, r7}
 8003092:	430a      	orrs	r2, r1
 8003094:	629a      	str	r2, [r3, #40]	; 0x28
 8003096:	229c      	movs	r2, #156	; 0x9c
 8003098:	6a99      	ldr	r1, [r3, #40]	; 0x28
 800309a:	03d2      	lsls	r2, r2, #15
 800309c:	400a      	ands	r2, r1
 800309e:	629a      	str	r2, [r3, #40]	; 0x28
 80030a0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 80030a2:	691a      	ldr	r2, [r3, #16]
 80030a4:	2201      	movs	r2, #1
 80030a6:	2100      	movs	r1, #0
 80030a8:	4252      	negs	r2, r2
 80030aa:	611a      	str	r2, [r3, #16]
 80030ac:	691a      	ldr	r2, [r3, #16]
 80030ae:	6119      	str	r1, [r3, #16]
 80030b0:	691a      	ldr	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 80030b2:	48ec      	ldr	r0, [pc, #944]	; (8003464 <main+0x3e4>)
 80030b4:	68da      	ldr	r2, [r3, #12]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80030b6:	2480      	movs	r4, #128	; 0x80
  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB(~STM32_GPIO_EN_MASK);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 80030b8:	4302      	orrs	r2, r0
 80030ba:	60da      	str	r2, [r3, #12]
 80030bc:	2280      	movs	r2, #128	; 0x80
 80030be:	68d8      	ldr	r0, [r3, #12]
 80030c0:	03d2      	lsls	r2, r2, #15
 80030c2:	4002      	ands	r2, r0

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 80030c4:	2080      	movs	r0, #128	; 0x80
  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB(~STM32_GPIO_EN_MASK);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 80030c6:	60da      	str	r2, [r3, #12]
 80030c8:	68da      	ldr	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 80030ca:	69da      	ldr	r2, [r3, #28]
 80030cc:	0540      	lsls	r0, r0, #21
 80030ce:	4302      	orrs	r2, r0
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80030d0:	48e5      	ldr	r0, [pc, #916]	; (8003468 <main+0x3e8>)
  rccResetAHB(~STM32_GPIO_EN_MASK);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 80030d2:	61da      	str	r2, [r3, #28]
 80030d4:	69da      	ldr	r2, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80030d6:	6802      	ldr	r2, [r0, #0]
 80030d8:	0064      	lsls	r4, r4, #1
 80030da:	4322      	orrs	r2, r4
 80030dc:	6002      	str	r2, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 80030de:	22c0      	movs	r2, #192	; 0xc0
 80030e0:	6a18      	ldr	r0, [r3, #32]
 80030e2:	0092      	lsls	r2, r2, #2
 80030e4:	4002      	ands	r2, r0
 80030e6:	2080      	movs	r0, #128	; 0x80
 80030e8:	b083      	sub	sp, #12
 80030ea:	0080      	lsls	r0, r0, #2
 80030ec:	4282      	cmp	r2, r0
 80030ee:	d003      	beq.n	80030f8 <main+0x78>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 80030f0:	2280      	movs	r2, #128	; 0x80
 80030f2:	0252      	lsls	r2, r2, #9
 80030f4:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 80030f6:	6219      	str	r1, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 80030f8:	2080      	movs	r0, #128	; 0x80
 80030fa:	4bd8      	ldr	r3, [pc, #864]	; (800345c <main+0x3dc>)
 80030fc:	0200      	lsls	r0, r0, #8
 80030fe:	6a1a      	ldr	r2, [r3, #32]
 8003100:	4202      	tst	r2, r0
 8003102:	d107      	bne.n	8003114 <main+0x94>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8003104:	2280      	movs	r2, #128	; 0x80
 8003106:	6a19      	ldr	r1, [r3, #32]
 8003108:	0092      	lsls	r2, r2, #2
 800310a:	4311      	orrs	r1, r2
 800310c:	6219      	str	r1, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 800310e:	6a1a      	ldr	r2, [r3, #32]
 8003110:	4302      	orrs	r2, r0
 8003112:	621a      	str	r2, [r3, #32]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8003114:	21c1      	movs	r1, #193	; 0xc1
 8003116:	4ad5      	ldr	r2, [pc, #852]	; (800346c <main+0x3ec>)
 8003118:	0089      	lsls	r1, r1, #2
 800311a:	5850      	ldr	r0, [r2, r1]
 800311c:	4bd4      	ldr	r3, [pc, #848]	; (8003470 <main+0x3f0>)
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800311e:	27c0      	movs	r7, #192	; 0xc0
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8003120:	4003      	ands	r3, r0
 8003122:	20c0      	movs	r0, #192	; 0xc0
 8003124:	0200      	lsls	r0, r0, #8
 8003126:	4303      	orrs	r3, r0
 8003128:	5053      	str	r3, [r2, r1]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800312a:	2320      	movs	r3, #32
 800312c:	007f      	lsls	r7, r7, #1
 800312e:	51d3      	str	r3, [r2, r7]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8003130:	6013      	str	r3, [r2, #0]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8003132:	5853      	ldr	r3, [r2, r1]
 8003134:	48cf      	ldr	r0, [pc, #828]	; (8003474 <main+0x3f4>)
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003136:	2680      	movs	r6, #128	; 0x80
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8003138:	4683      	mov	fp, r0
 800313a:	4003      	ands	r3, r0
 800313c:	20c0      	movs	r0, #192	; 0xc0
 800313e:	0400      	lsls	r0, r0, #16
 8003140:	4303      	orrs	r3, r0
 8003142:	5053      	str	r3, [r2, r1]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003144:	2340      	movs	r3, #64	; 0x40
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8003146:	20c0      	movs	r0, #192	; 0xc0
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003148:	51d3      	str	r3, [r2, r7]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800314a:	6013      	str	r3, [r2, #0]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 800314c:	5853      	ldr	r3, [r2, r1]
 800314e:	0600      	lsls	r0, r0, #24
 8003150:	021b      	lsls	r3, r3, #8
 8003152:	0a1b      	lsrs	r3, r3, #8
 8003154:	4303      	orrs	r3, r0
 8003156:	5053      	str	r3, [r2, r1]
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {

  sdp->vmt = &vmt;
 8003158:	4bc7      	ldr	r3, [pc, #796]	; (8003478 <main+0x3f8>)
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800315a:	51d6      	str	r6, [r2, r7]
 800315c:	4698      	mov	r8, r3
 800315e:	4641      	mov	r1, r8
 8003160:	4bc6      	ldr	r3, [pc, #792]	; (800347c <main+0x3fc>)
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8003162:	6016      	str	r6, [r2, #0]
 8003164:	c302      	stmia	r3!, {r1}
 8003166:	49c5      	ldr	r1, [pc, #788]	; (800347c <main+0x3fc>)
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8003168:	4682      	mov	sl, r0
 800316a:	604b      	str	r3, [r1, #4]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800316c:	1c0b      	adds	r3, r1, #0
 800316e:	2001      	movs	r0, #1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8003170:	330c      	adds	r3, #12
 8003172:	7208      	strb	r0, [r1, #8]
 8003174:	60cb      	str	r3, [r1, #12]
  tqp->prev = (thread_t *)tqp;
 8003176:	610b      	str	r3, [r1, #16]
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8003178:	2100      	movs	r1, #0
 800317a:	4bc0      	ldr	r3, [pc, #768]	; (800347c <main+0x3fc>)
  iqp->q_buffer  = bp;
 800317c:	4cbf      	ldr	r4, [pc, #764]	; (800347c <main+0x3fc>)
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800317e:	6159      	str	r1, [r3, #20]
  iqp->q_buffer  = bp;
 8003180:	4bbf      	ldr	r3, [pc, #764]	; (8003480 <main+0x400>)
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8003182:	62a1      	str	r1, [r4, #40]	; 0x28
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8003184:	61a3      	str	r3, [r4, #24]
  iqp->q_rdptr   = bp;
 8003186:	6263      	str	r3, [r4, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8003188:	6223      	str	r3, [r4, #32]
  iqp->q_top     = bp + size;
 800318a:	3310      	adds	r3, #16
 800318c:	61e3      	str	r3, [r4, #28]
  iqp->q_notify  = infy;
 800318e:	1c23      	adds	r3, r4, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8003190:	3330      	adds	r3, #48	; 0x30
 8003192:	6323      	str	r3, [r4, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 8003194:	6363      	str	r3, [r4, #52]	; 0x34
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8003196:	2310      	movs	r3, #16
 8003198:	469c      	mov	ip, r3
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 800319a:	62e4      	str	r4, [r4, #44]	; 0x2c
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800319c:	1c23      	adds	r3, r4, #0
 800319e:	4664      	mov	r4, ip
 80031a0:	639c      	str	r4, [r3, #56]	; 0x38
  oqp->q_buffer  = bp;
 80031a2:	4bb8      	ldr	r3, [pc, #736]	; (8003484 <main+0x404>)
 80031a4:	4cb5      	ldr	r4, [pc, #724]	; (800347c <main+0x3fc>)
 80031a6:	4655      	mov	r5, sl
 80031a8:	63e3      	str	r3, [r4, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 80031aa:	64a3      	str	r3, [r4, #72]	; 0x48
  oqp->q_wrptr   = bp;
 80031ac:	6463      	str	r3, [r4, #68]	; 0x44
  oqp->q_top     = bp + size;
 80031ae:	3310      	adds	r3, #16
 80031b0:	6423      	str	r3, [r4, #64]	; 0x40
  oqp->q_notify  = onfy;
 80031b2:	4bb5      	ldr	r3, [pc, #724]	; (8003488 <main+0x408>)
  oqp->q_link    = link;
 80031b4:	6524      	str	r4, [r4, #80]	; 0x50
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 80031b6:	64e3      	str	r3, [r4, #76]	; 0x4c

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1);
  iqObjectInit(&SD1.iqueue, sd_in_buf1, sizeof sd_in_buf1, NULL, &SD1);
  oqObjectInit(&SD1.oqueue, sd_out_buf1, sizeof sd_out_buf1, notify1, &SD1);
  SD1.usart = USART1;
 80031b8:	4bb4      	ldr	r3, [pc, #720]	; (800348c <main+0x40c>)
 80031ba:	6563      	str	r3, [r4, #84]	; 0x54
  SD1.clock = STM32_USART1CLK;
 80031bc:	1c23      	adds	r3, r4, #0
 80031be:	4cb4      	ldr	r4, [pc, #720]	; (8003490 <main+0x410>)
 80031c0:	659c      	str	r4, [r3, #88]	; 0x58
 80031c2:	23c6      	movs	r3, #198	; 0xc6
 80031c4:	009b      	lsls	r3, r3, #2
 80031c6:	4699      	mov	r9, r3
 80031c8:	58d3      	ldr	r3, [r2, r3]
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {

  sdp->vmt = &vmt;
 80031ca:	4644      	mov	r4, r8
 80031cc:	021b      	lsls	r3, r3, #8
 80031ce:	0a1b      	lsrs	r3, r3, #8
 80031d0:	432b      	orrs	r3, r5
 80031d2:	464d      	mov	r5, r9
 80031d4:	5153      	str	r3, [r2, r5]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80031d6:	2380      	movs	r3, #128	; 0x80
 80031d8:	051b      	lsls	r3, r3, #20
 80031da:	51d3      	str	r3, [r2, r7]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80031dc:	6013      	str	r3, [r2, #0]
 80031de:	4bad      	ldr	r3, [pc, #692]	; (8003494 <main+0x414>)
 80031e0:	1c1d      	adds	r5, r3, #0
 80031e2:	c510      	stmia	r5!, {r4}
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80031e4:	240c      	movs	r4, #12
 80031e6:	46a0      	mov	r8, r4
 80031e8:	4498      	add	r8, r3
 80031ea:	4644      	mov	r4, r8
 80031ec:	60dc      	str	r4, [r3, #12]
  tqp->prev = (thread_t *)tqp;
 80031ee:	611c      	str	r4, [r3, #16]
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80031f0:	4ca9      	ldr	r4, [pc, #676]	; (8003498 <main+0x418>)
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80031f2:	6159      	str	r1, [r3, #20]
  iqp->q_buffer  = bp;
 80031f4:	619c      	str	r4, [r3, #24]
  iqp->q_rdptr   = bp;
 80031f6:	625c      	str	r4, [r3, #36]	; 0x24
  iqp->q_wrptr   = bp;
 80031f8:	621c      	str	r4, [r3, #32]
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80031fa:	46a0      	mov	r8, r4
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 80031fc:	2410      	movs	r4, #16
 80031fe:	46a1      	mov	r9, r4
 8003200:	44c8      	add	r8, r9
 8003202:	4644      	mov	r4, r8
 8003204:	61dc      	str	r4, [r3, #28]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8003206:	2430      	movs	r4, #48	; 0x30
 8003208:	46a0      	mov	r8, r4
 800320a:	4498      	add	r8, r3
 800320c:	4644      	mov	r4, r8
 800320e:	631c      	str	r4, [r3, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 8003210:	635c      	str	r4, [r3, #52]	; 0x34
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8003212:	4664      	mov	r4, ip
 8003214:	639c      	str	r4, [r3, #56]	; 0x38
  oqp->q_buffer  = bp;
 8003216:	4ca1      	ldr	r4, [pc, #644]	; (800349c <main+0x41c>)
 8003218:	605d      	str	r5, [r3, #4]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 800321a:	7218      	strb	r0, [r3, #8]
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 800321c:	6299      	str	r1, [r3, #40]	; 0x28
  iqp->q_link    = link;
 800321e:	62db      	str	r3, [r3, #44]	; 0x2c
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8003220:	46a4      	mov	ip, r4
 8003222:	63dc      	str	r4, [r3, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8003224:	649c      	str	r4, [r3, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8003226:	645c      	str	r4, [r3, #68]	; 0x44
  oqp->q_top     = bp + size;
 8003228:	2410      	movs	r4, #16
 800322a:	46a0      	mov	r8, r4
 800322c:	44c4      	add	ip, r8
 800322e:	4664      	mov	r4, ip
 8003230:	641c      	str	r4, [r3, #64]	; 0x40
  oqp->q_notify  = onfy;
 8003232:	4c9b      	ldr	r4, [pc, #620]	; (80034a0 <main+0x420>)
  oqp->q_link    = link;
 8003234:	651b      	str	r3, [r3, #80]	; 0x50
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8003236:	64dc      	str	r4, [r3, #76]	; 0x4c

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2);
  iqObjectInit(&SD2.iqueue, sd_in_buf2, sizeof sd_in_buf2, NULL, &SD2);
  oqObjectInit(&SD2.oqueue, sd_out_buf2, sizeof sd_out_buf2, notify2, &SD2);
  SD2.usart = USART2;
 8003238:	4c9a      	ldr	r4, [pc, #616]	; (80034a4 <main+0x424>)
 800323a:	655c      	str	r4, [r3, #84]	; 0x54
  SD2.clock = STM32_USART2CLK;
 800323c:	4c94      	ldr	r4, [pc, #592]	; (8003490 <main+0x410>)
 800323e:	659c      	str	r4, [r3, #88]	; 0x58
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8003240:	23c7      	movs	r3, #199	; 0xc7
 8003242:	24ff      	movs	r4, #255	; 0xff
 8003244:	009b      	lsls	r3, r3, #2
 8003246:	469c      	mov	ip, r3
 8003248:	58d3      	ldr	r3, [r2, r3]
 800324a:	43a3      	bics	r3, r4
 800324c:	1c1c      	adds	r4, r3, #0
 800324e:	23c0      	movs	r3, #192	; 0xc0
 8003250:	4323      	orrs	r3, r4
 8003252:	4664      	mov	r4, ip
 8003254:	5113      	str	r3, [r2, r4]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003256:	2380      	movs	r3, #128	; 0x80

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8003258:	4c80      	ldr	r4, [pc, #512]	; (800345c <main+0x3dc>)
 800325a:	055b      	lsls	r3, r3, #21
 800325c:	51d3      	str	r3, [r2, r7]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800325e:	6013      	str	r3, [r2, #0]
 8003260:	69e3      	ldr	r3, [r4, #28]
 8003262:	4303      	orrs	r3, r0
 8003264:	61e3      	str	r3, [r4, #28]
 8003266:	69e3      	ldr	r3, [r4, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8003268:	4b8f      	ldr	r3, [pc, #572]	; (80034a8 <main+0x428>)
 800326a:	469c      	mov	ip, r3
 800326c:	4665      	mov	r5, ip
 800326e:	689b      	ldr	r3, [r3, #8]
 8003270:	4303      	orrs	r3, r0
 8003272:	60ab      	str	r3, [r5, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8003274:	2380      	movs	r3, #128	; 0x80
 8003276:	4d8d      	ldr	r5, [pc, #564]	; (80034ac <main+0x42c>)
 8003278:	05db      	lsls	r3, r3, #23
 800327a:	629d      	str	r5, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800327c:	2501      	movs	r5, #1
 800327e:	426d      	negs	r5, r5
 8003280:	62dd      	str	r5, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8003282:	6199      	str	r1, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8003284:	6359      	str	r1, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8003286:	60d9      	str	r1, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8003288:	6059      	str	r1, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800328a:	6158      	str	r0, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 800328c:	6018      	str	r0, [r3, #0]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 800328e:	23c3      	movs	r3, #195	; 0xc3
  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8003290:	46ac      	mov	ip, r5
 8003292:	009b      	lsls	r3, r3, #2
 8003294:	2580      	movs	r5, #128	; 0x80
 8003296:	4698      	mov	r8, r3
 8003298:	58d3      	ldr	r3, [r2, r3]
 800329a:	062d      	lsls	r5, r5, #24
 800329c:	021b      	lsls	r3, r3, #8
 800329e:	0a1b      	lsrs	r3, r3, #8
 80032a0:	432b      	orrs	r3, r5
 80032a2:	4645      	mov	r5, r8
 80032a4:	5153      	str	r3, [r2, r5]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80032a6:	2380      	movs	r3, #128	; 0x80
 80032a8:	021b      	lsls	r3, r3, #8
 80032aa:	51d3      	str	r3, [r2, r7]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80032ac:	6013      	str	r3, [r2, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80032ae:	4b80      	ldr	r3, [pc, #512]	; (80034b0 <main+0x430>)
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
  mp->align = align;
 80032b0:	2504      	movs	r5, #4
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 80032b2:	1c1a      	adds	r2, r3, #0
 80032b4:	321c      	adds	r2, #28
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 80032b6:	6099      	str	r1, [r3, #8]
 80032b8:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80032ba:	605b      	str	r3, [r3, #4]
 80032bc:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 80032be:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (sysinterval_t)-1;
 80032c0:	4662      	mov	r2, ip
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 80032c2:	4f7c      	ldr	r7, [pc, #496]	; (80034b4 <main+0x434>)
 80032c4:	625a      	str	r2, [r3, #36]	; 0x24
 80032c6:	4a7c      	ldr	r2, [pc, #496]	; (80034b8 <main+0x438>)
 80032c8:	46ac      	mov	ip, r5
 80032ca:	6017      	str	r7, [r2, #0]
  ch_memcore.endmem  = __heap_end__;
 80032cc:	4f7b      	ldr	r7, [pc, #492]	; (80034bc <main+0x43c>)
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 80032ce:	6299      	str	r1, [r3, #40]	; 0x28
 80032d0:	6057      	str	r7, [r2, #4]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80032d2:	4a7b      	ldr	r2, [pc, #492]	; (80034c0 <main+0x440>)
 80032d4:	4f7b      	ldr	r7, [pc, #492]	; (80034c4 <main+0x444>)
  H_NEXT(&default_heap.header) = NULL;
 80032d6:	6051      	str	r1, [r2, #4]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80032d8:	6017      	str	r7, [r2, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80032da:	1c17      	adds	r7, r2, #0
 80032dc:	370c      	adds	r7, #12
  H_NEXT(&default_heap.header) = NULL;
  H_PAGES(&default_heap.header) = 0;
 80032de:	6091      	str	r1, [r2, #8]
  tqp->prev = (thread_t *)tqp;
 80032e0:	6117      	str	r7, [r2, #16]
 80032e2:	6151      	str	r1, [r2, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80032e4:	60d7      	str	r7, [r2, #12]
 80032e6:	4a78      	ldr	r2, [pc, #480]	; (80034c8 <main+0x448>)
 80032e8:	61d5      	str	r5, [r2, #28]
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 80032ea:	3520      	adds	r5, #32
 80032ec:	46a8      	mov	r8, r5
 80032ee:	4490      	add	r8, r2
 80032f0:	4645      	mov	r5, r8
 80032f2:	6255      	str	r5, [r2, #36]	; 0x24
 80032f4:	2528      	movs	r5, #40	; 0x28
 80032f6:	1c17      	adds	r7, r2, #0
 80032f8:	46a8      	mov	r8, r5
 80032fa:	3710      	adds	r7, #16
 80032fc:	6117      	str	r7, [r2, #16]
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 80032fe:	2714      	movs	r7, #20
 8003300:	4490      	add	r8, r2
 8003302:	4645      	mov	r5, r8
 8003304:	6197      	str	r7, [r2, #24]
  mp->align = align;
  mp->provider = provider;
 8003306:	4f71      	ldr	r7, [pc, #452]	; (80034cc <main+0x44c>)
 8003308:	6295      	str	r5, [r2, #40]	; 0x28
 800330a:	6217      	str	r7, [r2, #32]
 800330c:	6397      	str	r7, [r2, #56]	; 0x38
 800330e:	1c17      	adds	r7, r2, #0
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 8003310:	251c      	movs	r5, #28
 8003312:	373c      	adds	r7, #60	; 0x3c
 8003314:	63d7      	str	r7, [r2, #60]	; 0x3c
 8003316:	1c17      	adds	r7, r2, #0
 8003318:	6315      	str	r5, [r2, #48]	; 0x30
  mp->align = align;
 800331a:	4665      	mov	r5, ip
 800331c:	3740      	adds	r7, #64	; 0x40
 800331e:	6091      	str	r1, [r2, #8]
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8003320:	6151      	str	r1, [r2, #20]
 8003322:	62d1      	str	r1, [r2, #44]	; 0x2c
  mp->object_size = size;
  mp->align = align;
 8003324:	6355      	str	r5, [r2, #52]	; 0x34
 8003326:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 8003328:	6052      	str	r2, [r2, #4]
 800332a:	6417      	str	r7, [r2, #64]	; 0x40
 800332c:	1c17      	adds	r7, r2, #0
 800332e:	3744      	adds	r7, #68	; 0x44
 8003330:	6457      	str	r7, [r2, #68]	; 0x44
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8003332:	2251      	movs	r2, #81	; 0x51
 8003334:	5499      	strb	r1, [r3, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8003336:	3201      	adds	r2, #1
 8003338:	5498      	strb	r0, [r3, r2]
  tp->name      = name;
 800333a:	4a65      	ldr	r2, [pc, #404]	; (80034d0 <main+0x450>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 800333c:	639e      	str	r6, [r3, #56]	; 0x38
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 800333e:	66de      	str	r6, [r3, #108]	; 0x6c
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8003340:	1c1e      	adds	r6, r3, #0
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8003342:	649a      	str	r2, [r3, #72]	; 0x48
  REG_INSERT(tp);
 8003344:	1c1a      	adds	r2, r3, #0
 8003346:	3658      	adds	r6, #88	; 0x58
 8003348:	3230      	adds	r2, #48	; 0x30
 800334a:	659e      	str	r6, [r3, #88]	; 0x58
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800334c:	1c1e      	adds	r6, r3, #0
 800334e:	611a      	str	r2, [r3, #16]
 8003350:	615a      	str	r2, [r3, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8003352:	619a      	str	r2, [r3, #24]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8003354:	2250      	movs	r2, #80	; 0x50
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8003356:	465d      	mov	r5, fp
 8003358:	365c      	adds	r6, #92	; 0x5c
 800335a:	5498      	strb	r0, [r3, r2]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 800335c:	6699      	str	r1, [r3, #104]	; 0x68
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800335e:	6659      	str	r1, [r3, #100]	; 0x64
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8003360:	641b      	str	r3, [r3, #64]	; 0x40
 8003362:	645b      	str	r3, [r3, #68]	; 0x44
 8003364:	65de      	str	r6, [r3, #92]	; 0x5c
  tqp->prev = (thread_t *)tqp;
 8003366:	661e      	str	r6, [r3, #96]	; 0x60
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 8003368:	64d9      	str	r1, [r3, #76]	; 0x4c
 800336a:	4b5a      	ldr	r3, [pc, #360]	; (80034d4 <main+0x454>)
 800336c:	6a1a      	ldr	r2, [r3, #32]
 800336e:	4015      	ands	r5, r2
 8003370:	621d      	str	r5, [r3, #32]
 8003372:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003374:	b672      	cpsid	i
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 8003376:	4858      	ldr	r0, [pc, #352]	; (80034d8 <main+0x458>)
 8003378:	f7fd f872 	bl	8000460 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 800337c:	2100      	movs	r1, #0
 800337e:	f7fd f907 	bl	8000590 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003382:	b662      	cpsie	i
  chSysInit();

  /*
   * Activates the serial driver 2 using the driver default configuration.
   */
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 8003384:	2080      	movs	r0, #128	; 0x80
 8003386:	0080      	lsls	r0, r0, #2
 8003388:	f001 fd6a 	bl	8004e60 <_pal_lld_setgroupmode.constprop.45>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
 800338c:	2080      	movs	r0, #128	; 0x80
 800338e:	00c0      	lsls	r0, r0, #3
 8003390:	f001 fd66 	bl	8004e60 <_pal_lld_setgroupmode.constprop.45>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003394:	b672      	cpsid	i
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8003396:	4b39      	ldr	r3, [pc, #228]	; (800347c <main+0x3fc>)
 8003398:	7a1b      	ldrb	r3, [r3, #8]
 800339a:	2b01      	cmp	r3, #1
 800339c:	d105      	bne.n	80033aa <main+0x32a>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(true);
 800339e:	2280      	movs	r2, #128	; 0x80
 80033a0:	69a3      	ldr	r3, [r4, #24]
 80033a2:	01d2      	lsls	r2, r2, #7
 80033a4:	4313      	orrs	r3, r2
 80033a6:	61a3      	str	r3, [r4, #24]
 80033a8:	69a3      	ldr	r3, [r4, #24]
    fck = (uint32_t)(((uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  {
    fck = (uint32_t)(sdp->clock / config->speed);
 80033aa:	21e1      	movs	r1, #225	; 0xe1
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  uint32_t fck;
  USART_TypeDef *u = sdp->usart;
 80033ac:	4b33      	ldr	r3, [pc, #204]	; (800347c <main+0x3fc>)
    fck = (uint32_t)(((uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  {
    fck = (uint32_t)(sdp->clock / config->speed);
 80033ae:	0249      	lsls	r1, r1, #9
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  uint32_t fck;
  USART_TypeDef *u = sdp->usart;
 80033b0:	6d5c      	ldr	r4, [r3, #84]	; 0x54
    fck = (uint32_t)(((uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  {
    fck = (uint32_t)(sdp->clock / config->speed);
 80033b2:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80033b4:	1c18      	adds	r0, r3, #0
 80033b6:	9301      	str	r3, [sp, #4]
 80033b8:	f7fc ff0e 	bl	80001d8 <__aeabi_uidiv>
  if (config->cr1 & USART_CR1_OVER8)
    fck = ((fck & ~7) * 2) | (fck & 7);
  u->BRR = fck;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80033bc:	2340      	movs	r3, #64	; 0x40
  /* Correcting USARTDIV when oversampling by 8 instead of 16.
     Fraction is still 4 bits wide, but only lower 3 bits used.
     Mantissa is doubled, but Fraction is left the same.*/
  if (config->cr1 & USART_CR1_OVER8)
    fck = ((fck & ~7) * 2) | (fck & 7);
  u->BRR = fck;
 80033be:	60e0      	str	r0, [r4, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80033c0:	6063      	str	r3, [r4, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80033c2:	3b3f      	subs	r3, #63	; 0x3f
 80033c4:	60a3      	str	r3, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80033c6:	232e      	movs	r3, #46	; 0x2e
    default:
      sdp->rxmask = 0xFF;
    }
  }
  else {
    sdp->rxmask = 0xFF;
 80033c8:	225c      	movs	r2, #92	; 0x5c
  u->BRR = fck;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 80033ca:	33ff      	adds	r3, #255	; 0xff
 80033cc:	6023      	str	r3, [r4, #0]
    default:
      sdp->rxmask = 0xFF;
    }
  }
  else {
    sdp->rxmask = 0xFF;
 80033ce:	492b      	ldr	r1, [pc, #172]	; (800347c <main+0x3fc>)
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 80033d0:	3b2f      	subs	r3, #47	; 0x2f
 80033d2:	3bff      	subs	r3, #255	; 0xff
 80033d4:	6223      	str	r3, [r4, #32]
    default:
      sdp->rxmask = 0xFF;
    }
  }
  else {
    sdp->rxmask = 0xFF;
 80033d6:	548b      	strb	r3, [r1, r2]

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 80033d8:	3303      	adds	r3, #3
 80033da:	720b      	strb	r3, [r1, #8]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80033dc:	b662      	cpsie	i
  sdStart(&SD1, NULL);

  /*
   * Creates the blinker thread.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 80033de:	2300      	movs	r3, #0
 80033e0:	483e      	ldr	r0, [pc, #248]	; (80034dc <main+0x45c>)
 80033e2:	2180      	movs	r1, #128	; 0x80
 80033e4:	4a3e      	ldr	r2, [pc, #248]	; (80034e0 <main+0x460>)
 80033e6:	f001 fd8b 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80033ea:	4b3e      	ldr	r3, [pc, #248]	; (80034e4 <main+0x464>)
 80033ec:	4c3e      	ldr	r4, [pc, #248]	; (80034e8 <main+0x468>)
 80033ee:	469a      	mov	sl, r3
 80033f0:	4b3e      	ldr	r3, [pc, #248]	; (80034ec <main+0x46c>)
 80033f2:	4e3f      	ldr	r6, [pc, #252]	; (80034f0 <main+0x470>)
 80033f4:	469b      	mov	fp, r3
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream, const testsuite_t *tsp) {
  int tseq, tcase;

  test_chp = stream;
 80033f6:	4b21      	ldr	r3, [pc, #132]	; (800347c <main+0x3fc>)
  test_println("");
 80033f8:	483e      	ldr	r0, [pc, #248]	; (80034f4 <main+0x474>)
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream, const testsuite_t *tsp) {
  int tseq, tcase;

  test_chp = stream;
 80033fa:	6023      	str	r3, [r4, #0]
  test_println("");
 80033fc:	f000 fac0 	bl	8003980 <test_println>
 8003400:	212a      	movs	r1, #42	; 0x2a
 8003402:	4d3d      	ldr	r5, [pc, #244]	; (80034f8 <main+0x478>)
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003404:	6820      	ldr	r0, [r4, #0]
 8003406:	3501      	adds	r5, #1
 8003408:	6803      	ldr	r3, [r0, #0]
 800340a:	68db      	ldr	r3, [r3, #12]
 800340c:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 800340e:	7829      	ldrb	r1, [r5, #0]
 8003410:	2900      	cmp	r1, #0
 8003412:	d1f7      	bne.n	8003404 <main+0x384>

  test_chp = stream;
  test_println("");
  if (tsp->name != NULL) {
    test_print("*** ");
    test_println(tsp->name);
 8003414:	4839      	ldr	r0, [pc, #228]	; (80034fc <main+0x47c>)
 8003416:	f000 fab3 	bl	8003980 <test_println>
  }
  else {
    test_println("*** Test Suite");
  }
  test_println("***");
 800341a:	4839      	ldr	r0, [pc, #228]	; (8003500 <main+0x480>)
 800341c:	f000 fab0 	bl	8003980 <test_println>
 8003420:	212a      	movs	r1, #42	; 0x2a
 8003422:	4d38      	ldr	r5, [pc, #224]	; (8003504 <main+0x484>)
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003424:	6820      	ldr	r0, [r4, #0]
 8003426:	3501      	adds	r5, #1
 8003428:	6803      	ldr	r3, [r0, #0]
 800342a:	68db      	ldr	r3, [r3, #12]
 800342c:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 800342e:	7829      	ldrb	r1, [r5, #0]
 8003430:	2900      	cmp	r1, #0
 8003432:	d1f7      	bne.n	8003424 <main+0x3a4>
  else {
    test_println("*** Test Suite");
  }
  test_println("***");
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8003434:	4834      	ldr	r0, [pc, #208]	; (8003508 <main+0x488>)
 8003436:	f000 faa3 	bl	8003980 <test_println>
 800343a:	212a      	movs	r1, #42	; 0x2a
 800343c:	4d33      	ldr	r5, [pc, #204]	; (800350c <main+0x48c>)
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 800343e:	6820      	ldr	r0, [r4, #0]
 8003440:	3501      	adds	r5, #1
 8003442:	6803      	ldr	r3, [r0, #0]
 8003444:	68db      	ldr	r3, [r3, #12]
 8003446:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003448:	7829      	ldrb	r1, [r5, #0]
 800344a:	2900      	cmp	r1, #0
 800344c:	d1f7      	bne.n	800343e <main+0x3be>
  test_println("***");
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 800344e:	252a      	movs	r5, #42	; 0x2a
 8003450:	482f      	ldr	r0, [pc, #188]	; (8003510 <main+0x490>)
 8003452:	f000 fa95 	bl	8003980 <test_println>
 8003456:	1c29      	adds	r1, r5, #0
 8003458:	4f2e      	ldr	r7, [pc, #184]	; (8003514 <main+0x494>)
 800345a:	e05d      	b.n	8003518 <main+0x498>
 800345c:	40021000 	.word	0x40021000
 8003460:	ffb1ffff 	.word	0xffb1ffff
 8003464:	ffbfffff 	.word	0xffbfffff
 8003468:	40007000 	.word	0x40007000
 800346c:	e000e100 	.word	0xe000e100
 8003470:	ffff00ff 	.word	0xffff00ff
 8003474:	ff00ffff 	.word	0xff00ffff
 8003478:	080058d8 	.word	0x080058d8
 800347c:	20000624 	.word	0x20000624
 8003480:	2000059c 	.word	0x2000059c
 8003484:	20000604 	.word	0x20000604
 8003488:	08000381 	.word	0x08000381
 800348c:	40013800 	.word	0x40013800
 8003490:	02dc6c00 	.word	0x02dc6c00
 8003494:	20000684 	.word	0x20000684
 8003498:	200005ac 	.word	0x200005ac
 800349c:	20000614 	.word	0x20000614
 80034a0:	08000371 	.word	0x08000371
 80034a4:	40004400 	.word	0x40004400
 80034a8:	40015800 	.word	0x40015800
 80034ac:	000012bf 	.word	0x000012bf
 80034b0:	20000e84 	.word	0x20000e84
 80034b4:	20000f60 	.word	0x20000f60
 80034b8:	20000434 	.word	0x20000434
 80034bc:	20001800 	.word	0x20001800
 80034c0:	20000f10 	.word	0x20000f10
 80034c4:	08003821 	.word	0x08003821
 80034c8:	200005bc 	.word	0x200005bc
 80034cc:	080037f1 	.word	0x080037f1
 80034d0:	08005884 	.word	0x08005884
 80034d4:	e000ed00 	.word	0xe000ed00
 80034d8:	08006464 	.word	0x08006464
 80034dc:	20000440 	.word	0x20000440
 80034e0:	08002c81 	.word	0x08002c81
 80034e4:	20000f2c 	.word	0x20000f2c
 80034e8:	200006e4 	.word	0x200006e4
 80034ec:	20000d64 	.word	0x20000d64
 80034f0:	20000efc 	.word	0x20000efc
 80034f4:	08006e98 	.word	0x08006e98
 80034f8:	08005c1c 	.word	0x08005c1c
 80034fc:	08005d0c 	.word	0x08005d0c
 8003500:	08005d24 	.word	0x08005d24
 8003504:	08005c24 	.word	0x08005c24
 8003508:	08005d28 	.word	0x08005d28
 800350c:	08005c38 	.word	0x08005c38
 8003510:	08005d40 	.word	0x08005d40
 8003514:	08005c4c 	.word	0x08005c4c
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003518:	6820      	ldr	r0, [r4, #0]
 800351a:	3701      	adds	r7, #1
 800351c:	6803      	ldr	r3, [r0, #0]
 800351e:	68db      	ldr	r3, [r3, #12]
 8003520:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003522:	7839      	ldrb	r1, [r7, #0]
 8003524:	2900      	cmp	r1, #0
 8003526:	d1f7      	bne.n	8003518 <main+0x498>
 8003528:	1c0d      	adds	r5, r1, #0
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 800352a:	488d      	ldr	r0, [pc, #564]	; (8003760 <main+0x6e0>)
 800352c:	f000 fa28 	bl	8003980 <test_println>
#endif
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");
 8003530:	488c      	ldr	r0, [pc, #560]	; (8003764 <main+0x6e4>)
 8003532:	f000 fa25 	bl	8003980 <test_println>

  test_global_fail = false;
 8003536:	4b8c      	ldr	r3, [pc, #560]	; (8003768 <main+0x6e8>)
 8003538:	701d      	strb	r5, [r3, #0]
 800353a:	4b8c      	ldr	r3, [pc, #560]	; (800376c <main+0x6ec>)
 800353c:	4699      	mov	r9, r3
  tseq = 0;
 800353e:	2300      	movs	r3, #0
 8003540:	9301      	str	r3, [sp, #4]
  while (tsp->sequences[tseq] != NULL) {
 8003542:	464b      	mov	r3, r9
 8003544:	681b      	ldr	r3, [r3, #0]
 8003546:	2b00      	cmp	r3, #0
 8003548:	d100      	bne.n	800354c <main+0x4cc>
 800354a:	e0e7      	b.n	800371c <main+0x69c>
 800354c:	254c      	movs	r5, #76	; 0x4c

static void print_fat_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
    streamPut(test_chp, '=');
 800354e:	6820      	ldr	r0, [r4, #0]
 8003550:	213d      	movs	r1, #61	; 0x3d
 8003552:	6803      	ldr	r3, [r0, #0]
 8003554:	3d01      	subs	r5, #1
 8003556:	68db      	ldr	r3, [r3, #12]
 8003558:	4798      	blx	r3
}

static void print_fat_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 800355a:	2d00      	cmp	r5, #0
 800355c:	d1f7      	bne.n	800354e <main+0x4ce>
    streamPut(test_chp, '=');
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 800355e:	6820      	ldr	r0, [r4, #0]
 8003560:	4983      	ldr	r1, [pc, #524]	; (8003770 <main+0x6f0>)
 8003562:	6803      	ldr	r3, [r0, #0]
 8003564:	2202      	movs	r2, #2
 8003566:	685b      	ldr	r3, [r3, #4]
 8003568:	4798      	blx	r3
 800356a:	213d      	movs	r1, #61	; 0x3d
 800356c:	4d81      	ldr	r5, [pc, #516]	; (8003774 <main+0x6f4>)
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 800356e:	6820      	ldr	r0, [r4, #0]
 8003570:	3501      	adds	r5, #1
 8003572:	6803      	ldr	r3, [r0, #0]
 8003574:	68db      	ldr	r3, [r3, #12]
 8003576:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003578:	7829      	ldrb	r1, [r5, #0]
 800357a:	2900      	cmp	r1, #0
 800357c:	d1f7      	bne.n	800356e <main+0x4ee>
  tseq = 0;
  while (tsp->sequences[tseq] != NULL) {
#if TEST_SHOW_SEQUENCES == TRUE
    print_fat_line();
    test_print("=== Test Sequence ");
    test_printn(tseq + 1);
 800357e:	9b01      	ldr	r3, [sp, #4]
 8003580:	3301      	adds	r3, #1
 8003582:	1c18      	adds	r0, r3, #0
 8003584:	9301      	str	r3, [sp, #4]
 8003586:	f000 f97b 	bl	8003880 <test_printn>
 800358a:	2120      	movs	r1, #32
 800358c:	4d7a      	ldr	r5, [pc, #488]	; (8003778 <main+0x6f8>)
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 800358e:	6820      	ldr	r0, [r4, #0]
 8003590:	3501      	adds	r5, #1
 8003592:	6803      	ldr	r3, [r0, #0]
 8003594:	68db      	ldr	r3, [r3, #12]
 8003596:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003598:	7829      	ldrb	r1, [r5, #0]
 800359a:	2900      	cmp	r1, #0
 800359c:	d1f7      	bne.n	800358e <main+0x50e>
#if TEST_SHOW_SEQUENCES == TRUE
    print_fat_line();
    test_print("=== Test Sequence ");
    test_printn(tseq + 1);
    test_print(" (");
    test_print(tsp->sequences[tseq]->name);
 800359e:	464b      	mov	r3, r9
 80035a0:	681b      	ldr	r3, [r3, #0]
 80035a2:	681d      	ldr	r5, [r3, #0]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80035a4:	7829      	ldrb	r1, [r5, #0]
 80035a6:	2900      	cmp	r1, #0
 80035a8:	d007      	beq.n	80035ba <main+0x53a>
    streamPut(test_chp, *msgp++);
 80035aa:	6820      	ldr	r0, [r4, #0]
 80035ac:	3501      	adds	r5, #1
 80035ae:	6803      	ldr	r3, [r0, #0]
 80035b0:	68db      	ldr	r3, [r3, #12]
 80035b2:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80035b4:	7829      	ldrb	r1, [r5, #0]
 80035b6:	2900      	cmp	r1, #0
 80035b8:	d1f7      	bne.n	80035aa <main+0x52a>
    test_printn(tseq + 1);
    test_print(" (");
    test_print(tsp->sequences[tseq]->name);
    test_println(")");
#endif
    tcase = 0;
 80035ba:	2700      	movs	r7, #0
    print_fat_line();
    test_print("=== Test Sequence ");
    test_printn(tseq + 1);
    test_print(" (");
    test_print(tsp->sequences[tseq]->name);
    test_println(")");
 80035bc:	486f      	ldr	r0, [pc, #444]	; (800377c <main+0x6fc>)
 80035be:	f000 f9df 	bl	8003980 <test_println>
 80035c2:	46b8      	mov	r8, r7
 80035c4:	4643      	mov	r3, r8
 80035c6:	009f      	lsls	r7, r3, #2
#endif
    tcase = 0;
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
 80035c8:	464b      	mov	r3, r9
 80035ca:	681b      	ldr	r3, [r3, #0]
 80035cc:	685b      	ldr	r3, [r3, #4]
 80035ce:	59db      	ldr	r3, [r3, r7]
 80035d0:	2b00      	cmp	r3, #0
 80035d2:	d100      	bne.n	80035d6 <main+0x556>
 80035d4:	e09a      	b.n	800370c <main+0x68c>
      print_line();
 80035d6:	f000 fd4b 	bl	8004070 <print_line.lto_priv.139>
 80035da:	212d      	movs	r1, #45	; 0x2d
 80035dc:	4d68      	ldr	r5, [pc, #416]	; (8003780 <main+0x700>)
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 80035de:	6820      	ldr	r0, [r4, #0]
 80035e0:	3501      	adds	r5, #1
 80035e2:	6803      	ldr	r3, [r0, #0]
 80035e4:	68db      	ldr	r3, [r3, #12]
 80035e6:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80035e8:	7829      	ldrb	r1, [r5, #0]
 80035ea:	2900      	cmp	r1, #0
 80035ec:	d1f7      	bne.n	80035de <main+0x55e>
#endif
    tcase = 0;
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
      print_line();
      test_print("--- Test Case ");
      test_printn(tseq + 1);
 80035ee:	9801      	ldr	r0, [sp, #4]
 80035f0:	f000 f946 	bl	8003880 <test_printn>
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 80035f4:	6820      	ldr	r0, [r4, #0]
 80035f6:	212e      	movs	r1, #46	; 0x2e
 80035f8:	6803      	ldr	r3, [r0, #0]
 80035fa:	68db      	ldr	r3, [r3, #12]
 80035fc:	4798      	blx	r3
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
      print_line();
      test_print("--- Test Case ");
      test_printn(tseq + 1);
      test_print(".");
      test_printn(tcase + 1);
 80035fe:	2301      	movs	r3, #1
 8003600:	469c      	mov	ip, r3
 8003602:	44e0      	add	r8, ip
 8003604:	4640      	mov	r0, r8
 8003606:	f000 f93b 	bl	8003880 <test_printn>
 800360a:	2120      	movs	r1, #32
 800360c:	4d5a      	ldr	r5, [pc, #360]	; (8003778 <main+0x6f8>)
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 800360e:	6820      	ldr	r0, [r4, #0]
 8003610:	3501      	adds	r5, #1
 8003612:	6803      	ldr	r3, [r0, #0]
 8003614:	68db      	ldr	r3, [r3, #12]
 8003616:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003618:	7829      	ldrb	r1, [r5, #0]
 800361a:	2900      	cmp	r1, #0
 800361c:	d1f7      	bne.n	800360e <main+0x58e>
      test_print("--- Test Case ");
      test_printn(tseq + 1);
      test_print(".");
      test_printn(tcase + 1);
      test_print(" (");
      test_print(tsp->sequences[tseq]->cases[tcase]->name);
 800361e:	464b      	mov	r3, r9
 8003620:	681b      	ldr	r3, [r3, #0]
 8003622:	685b      	ldr	r3, [r3, #4]
 8003624:	59db      	ldr	r3, [r3, r7]
 8003626:	681d      	ldr	r5, [r3, #0]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003628:	7829      	ldrb	r1, [r5, #0]
 800362a:	2900      	cmp	r1, #0
 800362c:	d007      	beq.n	800363e <main+0x5be>
    streamPut(test_chp, *msgp++);
 800362e:	6820      	ldr	r0, [r4, #0]
 8003630:	3501      	adds	r5, #1
 8003632:	6803      	ldr	r3, [r0, #0]
 8003634:	68db      	ldr	r3, [r3, #12]
 8003636:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003638:	7829      	ldrb	r1, [r5, #0]
 800363a:	2900      	cmp	r1, #0
 800363c:	d1f7      	bne.n	800362e <main+0x5ae>
      test_printn(tseq + 1);
      test_print(".");
      test_printn(tcase + 1);
      test_print(" (");
      test_print(tsp->sequences[tseq]->cases[tcase]->name);
      test_println(")");
 800363e:	484f      	ldr	r0, [pc, #316]	; (800377c <main+0x6fc>)
 8003640:	f000 f99e 	bl	8003980 <test_println>
 *
 * @api
 */
static inline void osalThreadSleep(sysinterval_t delay) {

  chThdSleep(delay);
 8003644:	20fa      	movs	r0, #250	; 0xfa
 8003646:	00c0      	lsls	r0, r0, #3
 8003648:	f7fd fcb2 	bl	8000fb0 <chThdSleep>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(tsp->sequences[tseq]->cases[tcase]);
 800364c:	464b      	mov	r3, r9
 800364e:	681b      	ldr	r3, [r3, #0]

static void execute_test(const testcase_t *tcp) {

  /* Initialization */
  clear_tokens();
  test_local_fail = false;
 8003650:	4a4c      	ldr	r2, [pc, #304]	; (8003784 <main+0x704>)
      test_print(tsp->sequences[tseq]->cases[tcase]->name);
      test_println(")");
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(tsp->sequences[tseq]->cases[tcase]);
 8003652:	685b      	ldr	r3, [r3, #4]
 8003654:	59dd      	ldr	r5, [r3, r7]
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8003656:	4653      	mov	r3, sl
 8003658:	6033      	str	r3, [r6, #0]

static void execute_test(const testcase_t *tcp) {

  /* Initialization */
  clear_tokens();
  test_local_fail = false;
 800365a:	2300      	movs	r3, #0
 800365c:	7013      	strb	r3, [r2, #0]

  if (tcp->setup != NULL)
 800365e:	686b      	ldr	r3, [r5, #4]
 8003660:	2b00      	cmp	r3, #0
 8003662:	d000      	beq.n	8003666 <main+0x5e6>
    tcp->setup();
 8003664:	4798      	blx	r3
  tcp->execute();
 8003666:	68eb      	ldr	r3, [r5, #12]
 8003668:	4798      	blx	r3
  if (tcp->teardown != NULL)
 800366a:	68ab      	ldr	r3, [r5, #8]
 800366c:	2b00      	cmp	r3, #0
 800366e:	d000      	beq.n	8003672 <main+0x5f2>
    tcp->teardown();
 8003670:	4798      	blx	r3
      test_println(")");
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(tsp->sequences[tseq]->cases[tcase]);
      if (test_local_fail) {
 8003672:	4b44      	ldr	r3, [pc, #272]	; (8003784 <main+0x704>)
 8003674:	781b      	ldrb	r3, [r3, #0]
 8003676:	2b00      	cmp	r3, #0
 8003678:	d06a      	beq.n	8003750 <main+0x6d0>
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
      print_line();
      test_print("--- Test Case ");
      test_printn(tseq + 1);
      test_print(".");
      test_printn(tcase + 1);
 800367a:	212d      	movs	r1, #45	; 0x2d
 800367c:	4d42      	ldr	r5, [pc, #264]	; (8003788 <main+0x708>)
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 800367e:	6820      	ldr	r0, [r4, #0]
 8003680:	3501      	adds	r5, #1
 8003682:	6803      	ldr	r3, [r0, #0]
 8003684:	68db      	ldr	r3, [r3, #12]
 8003686:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003688:	7829      	ldrb	r1, [r5, #0]
 800368a:	2900      	cmp	r1, #0
 800368c:	d1f7      	bne.n	800367e <main+0x5fe>
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(tsp->sequences[tseq]->cases[tcase]);
      if (test_local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
 800368e:	465b      	mov	r3, fp
 8003690:	6818      	ldr	r0, [r3, #0]
 8003692:	f000 f8f5 	bl	8003880 <test_printn>
 8003696:	2120      	movs	r1, #32
 8003698:	4d3c      	ldr	r5, [pc, #240]	; (800378c <main+0x70c>)
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 800369a:	6820      	ldr	r0, [r4, #0]
 800369c:	3501      	adds	r5, #1
 800369e:	6803      	ldr	r3, [r0, #0]
 80036a0:	68db      	ldr	r3, [r3, #12]
 80036a2:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80036a4:	7829      	ldrb	r1, [r5, #0]
 80036a6:	2900      	cmp	r1, #0
 80036a8:	d1f7      	bne.n	800369a <main+0x61a>
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 80036aa:	6833      	ldr	r3, [r6, #0]
 80036ac:	4655      	mov	r5, sl
 80036ae:	4553      	cmp	r3, sl
 80036b0:	d909      	bls.n	80036c6 <main+0x646>
    streamPut(test_chp, *cp++);
 80036b2:	6820      	ldr	r0, [r4, #0]
 80036b4:	3501      	adds	r5, #1
 80036b6:	6803      	ldr	r3, [r0, #0]
 80036b8:	1e6a      	subs	r2, r5, #1
 80036ba:	68db      	ldr	r3, [r3, #12]
 80036bc:	7811      	ldrb	r1, [r2, #0]
 80036be:	4798      	blx	r3
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 80036c0:	6833      	ldr	r3, [r6, #0]
 80036c2:	429d      	cmp	r5, r3
 80036c4:	d3f5      	bcc.n	80036b2 <main+0x632>
 80036c6:	215d      	movs	r1, #93	; 0x5d
 80036c8:	4d31      	ldr	r5, [pc, #196]	; (8003790 <main+0x710>)
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 80036ca:	6820      	ldr	r0, [r4, #0]
 80036cc:	3501      	adds	r5, #1
 80036ce:	6803      	ldr	r3, [r0, #0]
 80036d0:	68db      	ldr	r3, [r3, #12]
 80036d2:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80036d4:	7829      	ldrb	r1, [r5, #0]
 80036d6:	2900      	cmp	r1, #0
 80036d8:	d1f7      	bne.n	80036ca <main+0x64a>
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
 80036da:	4b2e      	ldr	r3, [pc, #184]	; (8003794 <main+0x714>)
 80036dc:	681d      	ldr	r5, [r3, #0]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80036de:	7829      	ldrb	r1, [r5, #0]
 80036e0:	2900      	cmp	r1, #0
 80036e2:	d007      	beq.n	80036f4 <main+0x674>
    streamPut(test_chp, *msgp++);
 80036e4:	6820      	ldr	r0, [r4, #0]
 80036e6:	3501      	adds	r5, #1
 80036e8:	6803      	ldr	r3, [r0, #0]
 80036ea:	68db      	ldr	r3, [r3, #12]
 80036ec:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80036ee:	7829      	ldrb	r1, [r5, #0]
 80036f0:	2900      	cmp	r1, #0
 80036f2:	d1f7      	bne.n	80036e4 <main+0x664>
        test_printn(test_step);
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
        test_println("\")");
 80036f4:	4828      	ldr	r0, [pc, #160]	; (8003798 <main+0x718>)
 80036f6:	f000 f943 	bl	8003980 <test_println>
 80036fa:	4643      	mov	r3, r8
 80036fc:	009f      	lsls	r7, r3, #2
    test_print(" (");
    test_print(tsp->sequences[tseq]->name);
    test_println(")");
#endif
    tcase = 0;
    while (tsp->sequences[tseq]->cases[tcase] != NULL) {
 80036fe:	464b      	mov	r3, r9
 8003700:	681b      	ldr	r3, [r3, #0]
 8003702:	685b      	ldr	r3, [r3, #4]
 8003704:	59db      	ldr	r3, [r3, r7]
 8003706:	2b00      	cmp	r3, #0
 8003708:	d000      	beq.n	800370c <main+0x68c>
 800370a:	e764      	b.n	80035d6 <main+0x556>
 800370c:	3304      	adds	r3, #4
 800370e:	469c      	mov	ip, r3
 8003710:	44e1      	add	r9, ip
#endif
  test_println("");

  test_global_fail = false;
  tseq = 0;
  while (tsp->sequences[tseq] != NULL) {
 8003712:	464b      	mov	r3, r9
 8003714:	681b      	ldr	r3, [r3, #0]
 8003716:	2b00      	cmp	r3, #0
 8003718:	d000      	beq.n	800371c <main+0x69c>
 800371a:	e717      	b.n	800354c <main+0x4cc>
      }
      tcase++;
    }
    tseq++;
  }
  print_line();
 800371c:	f000 fca8 	bl	8004070 <print_line.lto_priv.139>
  test_println("");
 8003720:	4810      	ldr	r0, [pc, #64]	; (8003764 <main+0x6e4>)
 8003722:	f000 f92d 	bl	8003980 <test_println>
 8003726:	2146      	movs	r1, #70	; 0x46
 8003728:	4d1c      	ldr	r5, [pc, #112]	; (800379c <main+0x71c>)
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 800372a:	6820      	ldr	r0, [r4, #0]
 800372c:	3501      	adds	r5, #1
 800372e:	6803      	ldr	r3, [r0, #0]
 8003730:	68db      	ldr	r3, [r3, #12]
 8003732:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003734:	7829      	ldrb	r1, [r5, #0]
 8003736:	2900      	cmp	r1, #0
 8003738:	d1f7      	bne.n	800372a <main+0x6aa>
    tseq++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
 800373a:	4b0b      	ldr	r3, [pc, #44]	; (8003768 <main+0x6e8>)
 800373c:	781b      	ldrb	r3, [r3, #0]
 800373e:	2b00      	cmp	r3, #0
 8003740:	d10a      	bne.n	8003758 <main+0x6d8>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8003742:	4817      	ldr	r0, [pc, #92]	; (80037a0 <main+0x720>)
 8003744:	f000 f91c 	bl	8003980 <test_println>
  while (true) {
//    if (!palReadLine(LINE_ARD_D3)) {
test_execute((BaseSequentialStream *)&SD1, &rt_test_suite);
//      test_execute((BaseSequentialStream *)&SD2, &oslib_test_suite);
  //  }
    chThdSleepMilliseconds(500);
 8003748:	4816      	ldr	r0, [pc, #88]	; (80037a4 <main+0x724>)
 800374a:	f7fd fc31 	bl	8000fb0 <chThdSleep>
 800374e:	e652      	b.n	80033f6 <main+0x376>
        test_print("] \"");
        test_print(test_failure_message);
        test_println("\")");
      }
      else {
        test_println("--- Result: SUCCESS");
 8003750:	4815      	ldr	r0, [pc, #84]	; (80037a8 <main+0x728>)
 8003752:	f000 f915 	bl	8003980 <test_println>
 8003756:	e735      	b.n	80035c4 <main+0x544>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
 8003758:	4814      	ldr	r0, [pc, #80]	; (80037ac <main+0x72c>)
 800375a:	f000 f911 	bl	8003980 <test_println>
 800375e:	e7f3      	b.n	8003748 <main+0x6c8>
 8003760:	08005cb8 	.word	0x08005cb8
 8003764:	08006e98 	.word	0x08006e98
 8003768:	20000f58 	.word	0x20000f58
 800376c:	080064d0 	.word	0x080064d0
 8003770:	08005ce4 	.word	0x08005ce4
 8003774:	08005c60 	.word	0x08005c60
 8003778:	08005c74 	.word	0x08005c74
 800377c:	08005ce8 	.word	0x08005ce8
 8003780:	08005c78 	.word	0x08005c78
 8003784:	20000ef8 	.word	0x20000ef8
 8003788:	08005c88 	.word	0x08005c88
 800378c:	08005ca0 	.word	0x08005ca0
 8003790:	08005ca4 	.word	0x08005ca4
 8003794:	20000e80 	.word	0x20000e80
 8003798:	08005cec 	.word	0x08005cec
 800379c:	08005ca8 	.word	0x08005ca8
 80037a0:	08005cfc 	.word	0x08005cfc
 80037a4:	00001388 	.word	0x00001388
 80037a8:	08005cf0 	.word	0x08005cf0
 80037ac:	08005d04 	.word	0x08005d04

080037b0 <rt_test_002_003_execute.lto_priv.78>:

static void rt_test_002_003_execute(void) {

  /* [2.3.1] Testing chSysSuspend(), chSysDisable() and
     chSysEnable().*/
  test_set_step(1);
 80037b0:	2201      	movs	r2, #1
 80037b2:	4b03      	ldr	r3, [pc, #12]	; (80037c0 <rt_test_002_003_execute.lto_priv.78+0x10>)
 80037b4:	601a      	str	r2, [r3, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80037b6:	b672      	cpsid	i
 80037b8:	b672      	cpsid	i
 80037ba:	b672      	cpsid	i
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80037bc:	b662      	cpsie	i
    chSysSuspend();
    chSysDisable();
    chSysSuspend();
    chSysEnable();
  }
}
 80037be:	4770      	bx	lr
 80037c0:	20000d64 	.word	0x20000d64
 80037c4:	46c0      	nop			; (mov r8, r8)
 80037c6:	46c0      	nop			; (mov r8, r8)
 80037c8:	46c0      	nop			; (mov r8, r8)
 80037ca:	46c0      	nop			; (mov r8, r8)
 80037cc:	46c0      	nop			; (mov r8, r8)
 80037ce:	46c0      	nop			; (mov r8, r8)

080037d0 <test_printn.part.0>:
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
void test_printn(uint32_t n) {
 80037d0:	b508      	push	{r3, lr}
  char buf[16], *p;

  if (!n)
    streamPut(test_chp, '0');
 80037d2:	4b03      	ldr	r3, [pc, #12]	; (80037e0 <test_printn.part.0+0x10>)
 80037d4:	2130      	movs	r1, #48	; 0x30
 80037d6:	6818      	ldr	r0, [r3, #0]
 80037d8:	6803      	ldr	r3, [r0, #0]
 80037da:	68db      	ldr	r3, [r3, #12]
 80037dc:	4798      	blx	r3
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
      streamPut(test_chp, *--p);
  }
}
 80037de:	bd08      	pop	{r3, pc}
 80037e0:	200006e4 	.word	0x200006e4
 80037e4:	46c0      	nop			; (mov r8, r8)
 80037e6:	46c0      	nop			; (mov r8, r8)
 80037e8:	46c0      	nop			; (mov r8, r8)
 80037ea:	46c0      	nop			; (mov r8, r8)
 80037ec:	46c0      	nop			; (mov r8, r8)
 80037ee:	46c0      	nop			; (mov r8, r8)

080037f0 <chCoreAllocAlignedI.lto_priv.57>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 80037f0:	b570      	push	{r4, r5, r6, lr}

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80037f2:	4c0a      	ldr	r4, [pc, #40]	; (800381c <chCoreAllocAlignedI.lto_priv.57+0x2c>)
 80037f4:	1e4a      	subs	r2, r1, #1
 80037f6:	6826      	ldr	r6, [r4, #0]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80037f8:	424d      	negs	r5, r1
 80037fa:	1e73      	subs	r3, r6, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80037fc:	185b      	adds	r3, r3, r1
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80037fe:	1811      	adds	r1, r2, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8003800:	402b      	ands	r3, r5
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8003802:	4029      	ands	r1, r5
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8003804:	6862      	ldr	r2, [r4, #4]
  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;
 8003806:	1859      	adds	r1, r3, r1

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8003808:	4291      	cmp	r1, r2
 800380a:	d804      	bhi.n	8003816 <chCoreAllocAlignedI.lto_priv.57+0x26>
 800380c:	428e      	cmp	r6, r1
 800380e:	d802      	bhi.n	8003816 <chCoreAllocAlignedI.lto_priv.57+0x26>
    return NULL;
  }

  ch_memcore.nextmem = next;

  return p;
 8003810:	1c18      	adds	r0, r3, #0
  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
    return NULL;
  }

  ch_memcore.nextmem = next;
 8003812:	6021      	str	r1, [r4, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 8003814:	bd70      	pop	{r4, r5, r6, pc}
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
    return NULL;
 8003816:	2000      	movs	r0, #0
 8003818:	e7fc      	b.n	8003814 <chCoreAllocAlignedI.lto_priv.57+0x24>
 800381a:	46c0      	nop			; (mov r8, r8)
 800381c:	20000434 	.word	0x20000434

08003820 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8003820:	b530      	push	{r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003822:	b672      	cpsid	i

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8003824:	4b0a      	ldr	r3, [pc, #40]	; (8003850 <chCoreAllocAlignedWithOffset+0x30>)
 8003826:	1e4c      	subs	r4, r1, #1
 8003828:	681d      	ldr	r5, [r3, #0]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 800382a:	4249      	negs	r1, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800382c:	18aa      	adds	r2, r5, r2
 800382e:	1912      	adds	r2, r2, r4
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8003830:	1820      	adds	r0, r4, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8003832:	400a      	ands	r2, r1
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8003834:	4008      	ands	r0, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 8003836:	6859      	ldr	r1, [r3, #4]
  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;
 8003838:	1810      	adds	r0, r2, r0

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800383a:	4288      	cmp	r0, r1
 800383c:	d805      	bhi.n	800384a <chCoreAllocAlignedWithOffset+0x2a>
 800383e:	4285      	cmp	r5, r0
 8003840:	d803      	bhi.n	800384a <chCoreAllocAlignedWithOffset+0x2a>
    return NULL;
  }

  ch_memcore.nextmem = next;
 8003842:	6018      	str	r0, [r3, #0]

  return p;
 8003844:	1c10      	adds	r0, r2, #0
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003846:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
 8003848:	bd30      	pop	{r4, r5, pc}
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
    return NULL;
 800384a:	2000      	movs	r0, #0
 800384c:	e7fb      	b.n	8003846 <chCoreAllocAlignedWithOffset+0x26>
 800384e:	46c0      	nop			; (mov r8, r8)
 8003850:	20000434 	.word	0x20000434
 8003854:	46c0      	nop			; (mov r8, r8)
 8003856:	46c0      	nop			; (mov r8, r8)
 8003858:	46c0      	nop			; (mov r8, r8)
 800385a:	46c0      	nop			; (mov r8, r8)
 800385c:	46c0      	nop			; (mov r8, r8)
 800385e:	46c0      	nop			; (mov r8, r8)

08003860 <vtcb>:
/****************************************************************************
 * Shared code.
 ****************************************************************************/

/* Timer callback for testing system functions in ISR context.*/
static void vtcb(void *p) {
 8003860:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003862:	b672      	cpsid	i
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003864:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003866:	b672      	cpsid	i
  chSysLockFromISR();
  chSysUnlockFromISR();

  /* Reentrant case.*/
  chSysLockFromISR();
  sts = chSysGetStatusAndLockX();
 8003868:	f7fd fbba 	bl	8000fe0 <chSysGetStatusAndLockX>
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 800386c:	07c3      	lsls	r3, r0, #31
 800386e:	d401      	bmi.n	8003874 <vtcb+0x14>
 8003870:	f7fd fba6 	bl	8000fc0 <chSysRestoreStatusX.part.2.lto_priv.154>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003874:	b662      	cpsie	i
  chSysRestoreStatusX(sts);
  chSysUnlockFromISR();
}
 8003876:	bd08      	pop	{r3, pc}
 8003878:	46c0      	nop			; (mov r8, r8)
 800387a:	46c0      	nop			; (mov r8, r8)
 800387c:	46c0      	nop			; (mov r8, r8)
 800387e:	46c0      	nop			; (mov r8, r8)

08003880 <test_printn>:
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
void test_printn(uint32_t n) {
 8003880:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003882:	4647      	mov	r7, r8
 8003884:	b480      	push	{r7}
 8003886:	1c06      	adds	r6, r0, #0
 8003888:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 800388a:	2800      	cmp	r0, #0
 800388c:	d023      	beq.n	80038d6 <test_printn+0x56>
 800388e:	46e8      	mov	r8, sp
 8003890:	466f      	mov	r7, sp
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8003892:	1c30      	adds	r0, r6, #0
 8003894:	210a      	movs	r1, #10
 8003896:	f7fc fd25 	bl	80002e4 <__aeabi_uidivmod>
 800389a:	3701      	adds	r7, #1
 800389c:	3130      	adds	r1, #48	; 0x30
 800389e:	b2cc      	uxtb	r4, r1
 80038a0:	1e7d      	subs	r5, r7, #1
 80038a2:	1c30      	adds	r0, r6, #0
 80038a4:	702c      	strb	r4, [r5, #0]
 80038a6:	210a      	movs	r1, #10
 80038a8:	f7fc fc96 	bl	80001d8 <__aeabi_uidiv>
 80038ac:	1e06      	subs	r6, r0, #0

  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
 80038ae:	d1f0      	bne.n	8003892 <test_printn+0x12>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 80038b0:	4547      	cmp	r7, r8
 80038b2:	d90c      	bls.n	80038ce <test_printn+0x4e>
 80038b4:	466b      	mov	r3, sp
 80038b6:	4e09      	ldr	r6, [pc, #36]	; (80038dc <test_printn+0x5c>)
 80038b8:	1e5f      	subs	r7, r3, #1
 80038ba:	e000      	b.n	80038be <test_printn+0x3e>
 80038bc:	782c      	ldrb	r4, [r5, #0]
      streamPut(test_chp, *--p);
 80038be:	6830      	ldr	r0, [r6, #0]
 80038c0:	1c21      	adds	r1, r4, #0
 80038c2:	6803      	ldr	r3, [r0, #0]
 80038c4:	3d01      	subs	r5, #1
 80038c6:	68db      	ldr	r3, [r3, #12]
 80038c8:	4798      	blx	r3
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 80038ca:	42bd      	cmp	r5, r7
 80038cc:	d1f6      	bne.n	80038bc <test_printn+0x3c>
      streamPut(test_chp, *--p);
  }
}
 80038ce:	b004      	add	sp, #16
 80038d0:	bc04      	pop	{r2}
 80038d2:	4690      	mov	r8, r2
 80038d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80038d6:	f7ff ff7b 	bl	80037d0 <test_printn.part.0>
 80038da:	e7f8      	b.n	80038ce <test_printn+0x4e>
 80038dc:	200006e4 	.word	0x200006e4

080038e0 <test_wait_tick>:
}

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 80038e0:	b508      	push	{r3, lr}

  chThdSleep(1);
 80038e2:	2001      	movs	r0, #1
 80038e4:	f7fd fb64 	bl	8000fb0 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80038e8:	b672      	cpsid	i
 80038ea:	2380      	movs	r3, #128	; 0x80
 80038ec:	05db      	lsls	r3, r3, #23
 80038ee:	6a58      	ldr	r0, [r3, #36]	; 0x24
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80038f0:	b662      	cpsie	i
  return chVTGetSystemTime();
}
 80038f2:	bd08      	pop	{r3, pc}
 80038f4:	46c0      	nop			; (mov r8, r8)
 80038f6:	46c0      	nop			; (mov r8, r8)
 80038f8:	46c0      	nop			; (mov r8, r8)
 80038fa:	46c0      	nop			; (mov r8, r8)
 80038fc:	46c0      	nop			; (mov r8, r8)
 80038fe:	46c0      	nop			; (mov r8, r8)

08003900 <test_wait_threads>:
}

/*
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8003900:	b570      	push	{r4, r5, r6, lr}
 8003902:	4c07      	ldr	r4, [pc, #28]	; (8003920 <test_wait_threads+0x20>)
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8003904:	2600      	movs	r6, #0
 8003906:	1c25      	adds	r5, r4, #0
 8003908:	3514      	adds	r5, #20
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 800390a:	6820      	ldr	r0, [r4, #0]
 800390c:	2800      	cmp	r0, #0
 800390e:	d002      	beq.n	8003916 <test_wait_threads+0x16>
      chThdWait(threads[i]);
 8003910:	f7fd f806 	bl	8000920 <chThdWait>
      threads[i] = NULL;
 8003914:	6026      	str	r6, [r4, #0]
 8003916:	3404      	adds	r4, #4
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8003918:	42ac      	cmp	r4, r5
 800391a:	d1f6      	bne.n	800390a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 800391c:	bd70      	pop	{r4, r5, r6, pc}
 800391e:	46c0      	nop			; (mov r8, r8)
 8003920:	20000d68 	.word	0x20000d68
 8003924:	46c0      	nop			; (mov r8, r8)
 8003926:	46c0      	nop			; (mov r8, r8)
 8003928:	46c0      	nop			; (mov r8, r8)
 800392a:	46c0      	nop			; (mov r8, r8)
 800392c:	46c0      	nop			; (mov r8, r8)
 800392e:	46c0      	nop			; (mov r8, r8)

08003930 <test_terminate_threads>:
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8003930:	b530      	push	{r4, r5, lr}
 8003932:	2300      	movs	r3, #0
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->flags |= CH_FLAG_TERMINATE;
 8003934:	2021      	movs	r0, #33	; 0x21
 8003936:	2504      	movs	r5, #4
 8003938:	4c06      	ldr	r4, [pc, #24]	; (8003954 <test_terminate_threads+0x24>)
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 800393a:	58e2      	ldr	r2, [r4, r3]
 800393c:	2a00      	cmp	r2, #0
 800393e:	d004      	beq.n	800394a <test_terminate_threads+0x1a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003940:	b672      	cpsid	i
 8003942:	5c11      	ldrb	r1, [r2, r0]
 8003944:	4329      	orrs	r1, r5
 8003946:	5411      	strb	r1, [r2, r0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003948:	b662      	cpsie	i
 800394a:	3304      	adds	r3, #4
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 800394c:	2b14      	cmp	r3, #20
 800394e:	d1f4      	bne.n	800393a <test_terminate_threads+0xa>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 8003950:	bd30      	pop	{r4, r5, pc}
 8003952:	46c0      	nop			; (mov r8, r8)
 8003954:	20000d68 	.word	0x20000d68
 8003958:	46c0      	nop			; (mov r8, r8)
 800395a:	46c0      	nop			; (mov r8, r8)
 800395c:	46c0      	nop			; (mov r8, r8)
 800395e:	46c0      	nop			; (mov r8, r8)

08003960 <test_emit_token>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003960:	b672      	cpsid	i
 * @api
 */
void test_emit_token(char token) {

  osalSysLock();
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
 8003962:	4a05      	ldr	r2, [pc, #20]	; (8003978 <test_emit_token+0x18>)
 8003964:	4905      	ldr	r1, [pc, #20]	; (800397c <test_emit_token+0x1c>)
 8003966:	6813      	ldr	r3, [r2, #0]
 8003968:	428b      	cmp	r3, r1
 800396a:	d202      	bcs.n	8003972 <test_emit_token+0x12>
    *test_tokp++ = token;
 800396c:	1c59      	adds	r1, r3, #1
 800396e:	6011      	str	r1, [r2, #0]
 8003970:	7018      	strb	r0, [r3, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003972:	b662      	cpsie	i
  osalSysUnlock();
}
 8003974:	4770      	bx	lr
 8003976:	46c0      	nop			; (mov r8, r8)
 8003978:	20000efc 	.word	0x20000efc
 800397c:	20000f3c 	.word	0x20000f3c

08003980 <test_println>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 8003980:	b538      	push	{r3, r4, r5, lr}
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003982:	7801      	ldrb	r1, [r0, #0]
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 8003984:	1c04      	adds	r4, r0, #0
 8003986:	4d09      	ldr	r5, [pc, #36]	; (80039ac <test_println+0x2c>)
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003988:	2900      	cmp	r1, #0
 800398a:	d007      	beq.n	800399c <test_println+0x1c>
    streamPut(test_chp, *msgp++);
 800398c:	6828      	ldr	r0, [r5, #0]
 800398e:	3401      	adds	r4, #1
 8003990:	6803      	ldr	r3, [r0, #0]
 8003992:	68db      	ldr	r3, [r3, #12]
 8003994:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003996:	7821      	ldrb	r1, [r4, #0]
 8003998:	2900      	cmp	r1, #0
 800399a:	d1f7      	bne.n	800398c <test_println+0xc>
 * @api
 */
void test_println(const char *msgp) {

  test_print(msgp);
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 800399c:	6828      	ldr	r0, [r5, #0]
 800399e:	4904      	ldr	r1, [pc, #16]	; (80039b0 <test_println+0x30>)
 80039a0:	6803      	ldr	r3, [r0, #0]
 80039a2:	2202      	movs	r2, #2
 80039a4:	685b      	ldr	r3, [r3, #4]
 80039a6:	4798      	blx	r3
}
 80039a8:	bd38      	pop	{r3, r4, r5, pc}
 80039aa:	46c0      	nop			; (mov r8, r8)
 80039ac:	200006e4 	.word	0x200006e4
 80039b0:	08005ce4 	.word	0x08005ce4
 80039b4:	46c0      	nop			; (mov r8, r8)
 80039b6:	46c0      	nop			; (mov r8, r8)
 80039b8:	46c0      	nop			; (mov r8, r8)
 80039ba:	46c0      	nop			; (mov r8, r8)
 80039bc:	46c0      	nop			; (mov r8, r8)
 80039be:	46c0      	nop			; (mov r8, r8)

080039c0 <test_print>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_print(const char *msgp) {
 80039c0:	b538      	push	{r3, r4, r5, lr}

  while (*msgp)
 80039c2:	7801      	ldrb	r1, [r0, #0]
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_print(const char *msgp) {
 80039c4:	1c04      	adds	r4, r0, #0

  while (*msgp)
 80039c6:	2900      	cmp	r1, #0
 80039c8:	d008      	beq.n	80039dc <test_print+0x1c>
 80039ca:	4d05      	ldr	r5, [pc, #20]	; (80039e0 <test_print+0x20>)
    streamPut(test_chp, *msgp++);
 80039cc:	6828      	ldr	r0, [r5, #0]
 80039ce:	3401      	adds	r4, #1
 80039d0:	6803      	ldr	r3, [r0, #0]
 80039d2:	68db      	ldr	r3, [r3, #12]
 80039d4:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 80039d6:	7821      	ldrb	r1, [r4, #0]
 80039d8:	2900      	cmp	r1, #0
 80039da:	d1f7      	bne.n	80039cc <test_print+0xc>
    streamPut(test_chp, *msgp++);
}
 80039dc:	bd38      	pop	{r3, r4, r5, pc}
 80039de:	46c0      	nop			; (mov r8, r8)
 80039e0:	200006e4 	.word	0x200006e4
 80039e4:	46c0      	nop			; (mov r8, r8)
 80039e6:	46c0      	nop			; (mov r8, r8)
 80039e8:	46c0      	nop			; (mov r8, r8)
 80039ea:	46c0      	nop			; (mov r8, r8)
 80039ec:	46c0      	nop			; (mov r8, r8)
 80039ee:	46c0      	nop			; (mov r8, r8)

080039f0 <rt_test_001_003_execute.lto_priv.75>:
 */

static void rt_test_001_003_execute(void) {

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
 80039f0:	2201      	movs	r2, #1
 80039f2:	4bc1      	ldr	r3, [pc, #772]	; (8003cf8 <rt_test_001_003_execute.lto_priv.75+0x308>)
 * <h2>Test Steps</h2>
 * - [1.3.1] Prints the configuration options settings.
 * .
 */

static void rt_test_001_003_execute(void) {
 80039f4:	b510      	push	{r4, lr}

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
  {
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
 80039f6:	48c1      	ldr	r0, [pc, #772]	; (8003cfc <rt_test_001_003_execute.lto_priv.75+0x30c>)
 */

static void rt_test_001_003_execute(void) {

  /* [1.3.1] Prints the configuration options settings.*/
  test_set_step(1);
 80039f8:	601a      	str	r2, [r3, #0]
  {
    test_print("--- CH_CFG_ST_RESOLUTION:               ");
 80039fa:	f7ff ffe1 	bl	80039c0 <test_print>
    test_printn(CH_CFG_ST_RESOLUTION);
 80039fe:	2020      	movs	r0, #32
 8003a00:	f7ff ff3e 	bl	8003880 <test_printn>
    test_println("");
 8003a04:	4cbe      	ldr	r4, [pc, #760]	; (8003d00 <rt_test_001_003_execute.lto_priv.75+0x310>)
 8003a06:	1c20      	adds	r0, r4, #0
 8003a08:	f7ff ffba 	bl	8003980 <test_println>
    test_print("--- CH_CFG_ST_FREQUENCY:                ");
 8003a0c:	48bd      	ldr	r0, [pc, #756]	; (8003d04 <rt_test_001_003_execute.lto_priv.75+0x314>)
 8003a0e:	f7ff ffd7 	bl	80039c0 <test_print>
    test_printn(CH_CFG_ST_FREQUENCY);
 8003a12:	48bd      	ldr	r0, [pc, #756]	; (8003d08 <rt_test_001_003_execute.lto_priv.75+0x318>)
 8003a14:	f7ff ff34 	bl	8003880 <test_printn>
    test_println("");
 8003a18:	1c20      	adds	r0, r4, #0
 8003a1a:	f7ff ffb1 	bl	8003980 <test_println>
    test_print("--- CH_CFG_INTERVALS_SIZE:              ");
 8003a1e:	48bb      	ldr	r0, [pc, #748]	; (8003d0c <rt_test_001_003_execute.lto_priv.75+0x31c>)
 8003a20:	f7ff ffce 	bl	80039c0 <test_print>
    test_printn(CH_CFG_INTERVALS_SIZE);
 8003a24:	2020      	movs	r0, #32
 8003a26:	f7ff ff2b 	bl	8003880 <test_printn>
    test_println("");
 8003a2a:	1c20      	adds	r0, r4, #0
 8003a2c:	f7ff ffa8 	bl	8003980 <test_println>
    test_print("--- CH_CFG_TIME_TYPES_SIZE:             ");
 8003a30:	48b7      	ldr	r0, [pc, #732]	; (8003d10 <rt_test_001_003_execute.lto_priv.75+0x320>)
 8003a32:	f7ff ffc5 	bl	80039c0 <test_print>
    test_printn(CH_CFG_TIME_TYPES_SIZE);
 8003a36:	2020      	movs	r0, #32
 8003a38:	f7ff ff22 	bl	8003880 <test_printn>
    test_println("");
 8003a3c:	1c20      	adds	r0, r4, #0
 8003a3e:	f7ff ff9f 	bl	8003980 <test_println>
    test_print("--- CH_CFG_ST_TIMEDELTA:                ");
 8003a42:	48b4      	ldr	r0, [pc, #720]	; (8003d14 <rt_test_001_003_execute.lto_priv.75+0x324>)
 8003a44:	f7ff ffbc 	bl	80039c0 <test_print>
    test_printn(CH_CFG_ST_TIMEDELTA);
 8003a48:	2002      	movs	r0, #2
 8003a4a:	f7ff ff19 	bl	8003880 <test_printn>
    test_println("");
 8003a4e:	1c20      	adds	r0, r4, #0
 8003a50:	f7ff ff96 	bl	8003980 <test_println>
    test_print("--- CH_CFG_TIME_QUANTUM:                ");
 8003a54:	48b0      	ldr	r0, [pc, #704]	; (8003d18 <rt_test_001_003_execute.lto_priv.75+0x328>)
 8003a56:	f7ff ffb3 	bl	80039c0 <test_print>
 8003a5a:	f7ff feb9 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_CFG_TIME_QUANTUM);
    test_println("");
 8003a5e:	1c20      	adds	r0, r4, #0
 8003a60:	f7ff ff8e 	bl	8003980 <test_println>
    test_print("--- CH_CFG_MEMCORE_SIZE:                ");
 8003a64:	48ad      	ldr	r0, [pc, #692]	; (8003d1c <rt_test_001_003_execute.lto_priv.75+0x32c>)
 8003a66:	f7ff ffab 	bl	80039c0 <test_print>
 8003a6a:	f7ff feb1 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_CFG_MEMCORE_SIZE);
    test_println("");
 8003a6e:	1c20      	adds	r0, r4, #0
 8003a70:	f7ff ff86 	bl	8003980 <test_println>
    test_print("--- CH_CFG_NO_IDLE_THREAD:              ");
 8003a74:	48aa      	ldr	r0, [pc, #680]	; (8003d20 <rt_test_001_003_execute.lto_priv.75+0x330>)
 8003a76:	f7ff ffa3 	bl	80039c0 <test_print>
 8003a7a:	f7ff fea9 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_CFG_NO_IDLE_THREAD);
    test_println("");
 8003a7e:	1c20      	adds	r0, r4, #0
 8003a80:	f7ff ff7e 	bl	8003980 <test_println>
    test_print("--- CH_CFG_OPTIMIZE_SPEED:              ");
 8003a84:	48a7      	ldr	r0, [pc, #668]	; (8003d24 <rt_test_001_003_execute.lto_priv.75+0x334>)
 8003a86:	f7ff ff9b 	bl	80039c0 <test_print>
    test_printn(CH_CFG_OPTIMIZE_SPEED);
 8003a8a:	2001      	movs	r0, #1
 8003a8c:	f7ff fef8 	bl	8003880 <test_printn>
    test_println("");
 8003a90:	1c20      	adds	r0, r4, #0
 8003a92:	f7ff ff75 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_TM:                      ");
 8003a96:	48a4      	ldr	r0, [pc, #656]	; (8003d28 <rt_test_001_003_execute.lto_priv.75+0x338>)
 8003a98:	f7ff ff92 	bl	80039c0 <test_print>
 8003a9c:	f7ff fe98 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_CFG_USE_TM);
    test_println("");
 8003aa0:	1c20      	adds	r0, r4, #0
 8003aa2:	f7ff ff6d 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_REGISTRY:                ");
 8003aa6:	48a1      	ldr	r0, [pc, #644]	; (8003d2c <rt_test_001_003_execute.lto_priv.75+0x33c>)
 8003aa8:	f7ff ff8a 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_REGISTRY);
 8003aac:	2001      	movs	r0, #1
 8003aae:	f7ff fee7 	bl	8003880 <test_printn>
    test_println("");
 8003ab2:	1c20      	adds	r0, r4, #0
 8003ab4:	f7ff ff64 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_WAITEXIT:                ");
 8003ab8:	489d      	ldr	r0, [pc, #628]	; (8003d30 <rt_test_001_003_execute.lto_priv.75+0x340>)
 8003aba:	f7ff ff81 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_WAITEXIT);
 8003abe:	2001      	movs	r0, #1
 8003ac0:	f7ff fede 	bl	8003880 <test_printn>
    test_println("");
 8003ac4:	1c20      	adds	r0, r4, #0
 8003ac6:	f7ff ff5b 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES:              ");
 8003aca:	489a      	ldr	r0, [pc, #616]	; (8003d34 <rt_test_001_003_execute.lto_priv.75+0x344>)
 8003acc:	f7ff ff78 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_SEMAPHORES);
 8003ad0:	2001      	movs	r0, #1
 8003ad2:	f7ff fed5 	bl	8003880 <test_printn>
    test_println("");
 8003ad6:	1c20      	adds	r0, r4, #0
 8003ad8:	f7ff ff52 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_SEMAPHORES_PRIORITY:     ");
 8003adc:	4896      	ldr	r0, [pc, #600]	; (8003d38 <rt_test_001_003_execute.lto_priv.75+0x348>)
 8003ade:	f7ff ff6f 	bl	80039c0 <test_print>
 8003ae2:	f7ff fe75 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_CFG_USE_SEMAPHORES_PRIORITY);
    test_println("");
 8003ae6:	1c20      	adds	r0, r4, #0
 8003ae8:	f7ff ff4a 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES:                 ");
 8003aec:	4893      	ldr	r0, [pc, #588]	; (8003d3c <rt_test_001_003_execute.lto_priv.75+0x34c>)
 8003aee:	f7ff ff67 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_MUTEXES);
 8003af2:	2001      	movs	r0, #1
 8003af4:	f7ff fec4 	bl	8003880 <test_printn>
    test_println("");
 8003af8:	1c20      	adds	r0, r4, #0
 8003afa:	f7ff ff41 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_MUTEXES_RECURSIVE:       ");
 8003afe:	4890      	ldr	r0, [pc, #576]	; (8003d40 <rt_test_001_003_execute.lto_priv.75+0x350>)
 8003b00:	f7ff ff5e 	bl	80039c0 <test_print>
 8003b04:	f7ff fe64 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_CFG_USE_MUTEXES_RECURSIVE);
    test_println("");   
 8003b08:	1c20      	adds	r0, r4, #0
 8003b0a:	f7ff ff39 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS:                ");
 8003b0e:	488d      	ldr	r0, [pc, #564]	; (8003d44 <rt_test_001_003_execute.lto_priv.75+0x354>)
 8003b10:	f7ff ff56 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_CONDVARS);
 8003b14:	2001      	movs	r0, #1
 8003b16:	f7ff feb3 	bl	8003880 <test_printn>
    test_println("");
 8003b1a:	1c20      	adds	r0, r4, #0
 8003b1c:	f7ff ff30 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_CONDVARS_TIMEOUT:        ");
 8003b20:	4889      	ldr	r0, [pc, #548]	; (8003d48 <rt_test_001_003_execute.lto_priv.75+0x358>)
 8003b22:	f7ff ff4d 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_CONDVARS_TIMEOUT);
 8003b26:	2001      	movs	r0, #1
 8003b28:	f7ff feaa 	bl	8003880 <test_printn>
    test_println("");
 8003b2c:	1c20      	adds	r0, r4, #0
 8003b2e:	f7ff ff27 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_EVENTS:                  ");
 8003b32:	4886      	ldr	r0, [pc, #536]	; (8003d4c <rt_test_001_003_execute.lto_priv.75+0x35c>)
 8003b34:	f7ff ff44 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_EVENTS);
 8003b38:	2001      	movs	r0, #1
 8003b3a:	f7ff fea1 	bl	8003880 <test_printn>
    test_println("");
 8003b3e:	1c20      	adds	r0, r4, #0
 8003b40:	f7ff ff1e 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_EVENTS_TIMEOUT:          ");
 8003b44:	4882      	ldr	r0, [pc, #520]	; (8003d50 <rt_test_001_003_execute.lto_priv.75+0x360>)
 8003b46:	f7ff ff3b 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_EVENTS_TIMEOUT);
 8003b4a:	2001      	movs	r0, #1
 8003b4c:	f7ff fe98 	bl	8003880 <test_printn>
    test_println("");
 8003b50:	1c20      	adds	r0, r4, #0
 8003b52:	f7ff ff15 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES:                ");
 8003b56:	487f      	ldr	r0, [pc, #508]	; (8003d54 <rt_test_001_003_execute.lto_priv.75+0x364>)
 8003b58:	f7ff ff32 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_MESSAGES);
 8003b5c:	2001      	movs	r0, #1
 8003b5e:	f7ff fe8f 	bl	8003880 <test_printn>
    test_println("");
 8003b62:	1c20      	adds	r0, r4, #0
 8003b64:	f7ff ff0c 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_MESSAGES_PRIORITY:       ");
 8003b68:	487b      	ldr	r0, [pc, #492]	; (8003d58 <rt_test_001_003_execute.lto_priv.75+0x368>)
 8003b6a:	f7ff ff29 	bl	80039c0 <test_print>
 8003b6e:	f7ff fe2f 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_CFG_USE_MESSAGES_PRIORITY);
    test_println("");
 8003b72:	1c20      	adds	r0, r4, #0
 8003b74:	f7ff ff04 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_MAILBOXES:               ");
 8003b78:	4878      	ldr	r0, [pc, #480]	; (8003d5c <rt_test_001_003_execute.lto_priv.75+0x36c>)
 8003b7a:	f7ff ff21 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_MAILBOXES);
 8003b7e:	2001      	movs	r0, #1
 8003b80:	f7ff fe7e 	bl	8003880 <test_printn>
    test_println("");
 8003b84:	1c20      	adds	r0, r4, #0
 8003b86:	f7ff fefb 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_MEMCORE:                 ");
 8003b8a:	4875      	ldr	r0, [pc, #468]	; (8003d60 <rt_test_001_003_execute.lto_priv.75+0x370>)
 8003b8c:	f7ff ff18 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_MEMCORE);
 8003b90:	2001      	movs	r0, #1
 8003b92:	f7ff fe75 	bl	8003880 <test_printn>
    test_println("");
 8003b96:	1c20      	adds	r0, r4, #0
 8003b98:	f7ff fef2 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_HEAP:                    ");
 8003b9c:	4871      	ldr	r0, [pc, #452]	; (8003d64 <rt_test_001_003_execute.lto_priv.75+0x374>)
 8003b9e:	f7ff ff0f 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_HEAP);
 8003ba2:	2001      	movs	r0, #1
 8003ba4:	f7ff fe6c 	bl	8003880 <test_printn>
    test_println("");
 8003ba8:	1c20      	adds	r0, r4, #0
 8003baa:	f7ff fee9 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_MEMPOOLS:                ");
 8003bae:	486e      	ldr	r0, [pc, #440]	; (8003d68 <rt_test_001_003_execute.lto_priv.75+0x378>)
 8003bb0:	f7ff ff06 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_MEMPOOLS);
 8003bb4:	2001      	movs	r0, #1
 8003bb6:	f7ff fe63 	bl	8003880 <test_printn>
    test_println("");
 8003bba:	1c20      	adds	r0, r4, #0
 8003bbc:	f7ff fee0 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_OBJ_FIFOS:               ");
 8003bc0:	486a      	ldr	r0, [pc, #424]	; (8003d6c <rt_test_001_003_execute.lto_priv.75+0x37c>)
 8003bc2:	f7ff fefd 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_OBJ_FIFOS);
 8003bc6:	2001      	movs	r0, #1
 8003bc8:	f7ff fe5a 	bl	8003880 <test_printn>
    test_println("");
 8003bcc:	1c20      	adds	r0, r4, #0
 8003bce:	f7ff fed7 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_DYNAMIC:                 ");
 8003bd2:	4867      	ldr	r0, [pc, #412]	; (8003d70 <rt_test_001_003_execute.lto_priv.75+0x380>)
 8003bd4:	f7ff fef4 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_DYNAMIC);
 8003bd8:	2001      	movs	r0, #1
 8003bda:	f7ff fe51 	bl	8003880 <test_printn>
    test_println("");
 8003bde:	1c20      	adds	r0, r4, #0
 8003be0:	f7ff fece 	bl	8003980 <test_println>
    test_print("--- CH_CFG_USE_FACTORY:                 ");
 8003be4:	4863      	ldr	r0, [pc, #396]	; (8003d74 <rt_test_001_003_execute.lto_priv.75+0x384>)
 8003be6:	f7ff feeb 	bl	80039c0 <test_print>
    test_printn(CH_CFG_USE_FACTORY);
 8003bea:	2001      	movs	r0, #1
 8003bec:	f7ff fe48 	bl	8003880 <test_printn>
    test_println("");
 8003bf0:	1c20      	adds	r0, r4, #0
 8003bf2:	f7ff fec5 	bl	8003980 <test_println>
    test_print("--- CH_CFG_FACTORY_MAX_NAMES_LENGTH:    ");
 8003bf6:	4860      	ldr	r0, [pc, #384]	; (8003d78 <rt_test_001_003_execute.lto_priv.75+0x388>)
 8003bf8:	f7ff fee2 	bl	80039c0 <test_print>
    test_printn(CH_CFG_FACTORY_MAX_NAMES_LENGTH);
 8003bfc:	2008      	movs	r0, #8
 8003bfe:	f7ff fe3f 	bl	8003880 <test_printn>
    test_println("");
 8003c02:	1c20      	adds	r0, r4, #0
 8003c04:	f7ff febc 	bl	8003980 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJECTS_REGISTRY:    ");
 8003c08:	485c      	ldr	r0, [pc, #368]	; (8003d7c <rt_test_001_003_execute.lto_priv.75+0x38c>)
 8003c0a:	f7ff fed9 	bl	80039c0 <test_print>
    test_printn(CH_CFG_FACTORY_OBJECTS_REGISTRY);
 8003c0e:	2001      	movs	r0, #1
 8003c10:	f7ff fe36 	bl	8003880 <test_printn>
    test_println("");
 8003c14:	1c20      	adds	r0, r4, #0
 8003c16:	f7ff feb3 	bl	8003980 <test_println>
    test_print("--- CH_CFG_FACTORY_GENERIC_BUFFERS:     ");
 8003c1a:	4859      	ldr	r0, [pc, #356]	; (8003d80 <rt_test_001_003_execute.lto_priv.75+0x390>)
 8003c1c:	f7ff fed0 	bl	80039c0 <test_print>
    test_printn(CH_CFG_FACTORY_GENERIC_BUFFERS);
 8003c20:	2001      	movs	r0, #1
 8003c22:	f7ff fe2d 	bl	8003880 <test_printn>
    test_println("");
 8003c26:	1c20      	adds	r0, r4, #0
 8003c28:	f7ff feaa 	bl	8003980 <test_println>
    test_print("--- CH_CFG_FACTORY_SEMAPHORES:          ");
 8003c2c:	4855      	ldr	r0, [pc, #340]	; (8003d84 <rt_test_001_003_execute.lto_priv.75+0x394>)
 8003c2e:	f7ff fec7 	bl	80039c0 <test_print>
    test_printn(CH_CFG_FACTORY_SEMAPHORES);
 8003c32:	2001      	movs	r0, #1
 8003c34:	f7ff fe24 	bl	8003880 <test_printn>
    test_println("");
 8003c38:	1c20      	adds	r0, r4, #0
 8003c3a:	f7ff fea1 	bl	8003980 <test_println>
    test_print("--- CH_CFG_FACTORY_MAILBOXES:           ");
 8003c3e:	4852      	ldr	r0, [pc, #328]	; (8003d88 <rt_test_001_003_execute.lto_priv.75+0x398>)
 8003c40:	f7ff febe 	bl	80039c0 <test_print>
    test_printn(CH_CFG_FACTORY_MAILBOXES);
 8003c44:	2001      	movs	r0, #1
 8003c46:	f7ff fe1b 	bl	8003880 <test_printn>
    test_println("");
 8003c4a:	1c20      	adds	r0, r4, #0
 8003c4c:	f7ff fe98 	bl	8003980 <test_println>
    test_print("--- CH_CFG_FACTORY_OBJ_FIFOS:           ");
 8003c50:	484e      	ldr	r0, [pc, #312]	; (8003d8c <rt_test_001_003_execute.lto_priv.75+0x39c>)
 8003c52:	f7ff feb5 	bl	80039c0 <test_print>
    test_printn(CH_CFG_FACTORY_OBJ_FIFOS);
 8003c56:	2001      	movs	r0, #1
 8003c58:	f7ff fe12 	bl	8003880 <test_printn>
    test_println("");
 8003c5c:	1c20      	adds	r0, r4, #0
 8003c5e:	f7ff fe8f 	bl	8003980 <test_println>
    test_print("--- CH_DBG_STATISTICS:                  ");
 8003c62:	484b      	ldr	r0, [pc, #300]	; (8003d90 <rt_test_001_003_execute.lto_priv.75+0x3a0>)
 8003c64:	f7ff feac 	bl	80039c0 <test_print>
 8003c68:	f7ff fdb2 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_DBG_STATISTICS);
    test_println("");
 8003c6c:	1c20      	adds	r0, r4, #0
 8003c6e:	f7ff fe87 	bl	8003980 <test_println>
    test_print("--- CH_DBG_SYSTEM_STATE_CHECK:          ");
 8003c72:	4848      	ldr	r0, [pc, #288]	; (8003d94 <rt_test_001_003_execute.lto_priv.75+0x3a4>)
 8003c74:	f7ff fea4 	bl	80039c0 <test_print>
 8003c78:	f7ff fdaa 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_DBG_SYSTEM_STATE_CHECK);
    test_println("");
 8003c7c:	1c20      	adds	r0, r4, #0
 8003c7e:	f7ff fe7f 	bl	8003980 <test_println>
    test_print("--- CH_DBG_ENABLE_CHECKS:               ");
 8003c82:	4845      	ldr	r0, [pc, #276]	; (8003d98 <rt_test_001_003_execute.lto_priv.75+0x3a8>)
 8003c84:	f7ff fe9c 	bl	80039c0 <test_print>
 8003c88:	f7ff fda2 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_DBG_ENABLE_CHECKS);
    test_println("");
 8003c8c:	1c20      	adds	r0, r4, #0
 8003c8e:	f7ff fe77 	bl	8003980 <test_println>
    test_print("--- CH_DBG_ENABLE_ASSERTS:              ");
 8003c92:	4842      	ldr	r0, [pc, #264]	; (8003d9c <rt_test_001_003_execute.lto_priv.75+0x3ac>)
 8003c94:	f7ff fe94 	bl	80039c0 <test_print>
 8003c98:	f7ff fd9a 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_DBG_ENABLE_ASSERTS);
    test_println("");
 8003c9c:	1c20      	adds	r0, r4, #0
 8003c9e:	f7ff fe6f 	bl	8003980 <test_println>
    test_print("--- CH_DBG_TRACE_MASK:                  ");
 8003ca2:	483f      	ldr	r0, [pc, #252]	; (8003da0 <rt_test_001_003_execute.lto_priv.75+0x3b0>)
 8003ca4:	f7ff fe8c 	bl	80039c0 <test_print>
    test_printn(CH_DBG_TRACE_MASK);
 8003ca8:	20ff      	movs	r0, #255	; 0xff
 8003caa:	f7ff fde9 	bl	8003880 <test_printn>
    test_println("");
 8003cae:	1c20      	adds	r0, r4, #0
 8003cb0:	f7ff fe66 	bl	8003980 <test_println>
    test_print("--- CH_DBG_TRACE_BUFFER_SIZE:           ");
 8003cb4:	483b      	ldr	r0, [pc, #236]	; (8003da4 <rt_test_001_003_execute.lto_priv.75+0x3b4>)
 8003cb6:	f7ff fe83 	bl	80039c0 <test_print>
    test_printn(CH_DBG_TRACE_BUFFER_SIZE);
 8003cba:	2080      	movs	r0, #128	; 0x80
 8003cbc:	f7ff fde0 	bl	8003880 <test_printn>
    test_println("");
 8003cc0:	1c20      	adds	r0, r4, #0
 8003cc2:	f7ff fe5d 	bl	8003980 <test_println>
    test_print("--- CH_DBG_ENABLE_STACK_CHECK:          ");
 8003cc6:	4838      	ldr	r0, [pc, #224]	; (8003da8 <rt_test_001_003_execute.lto_priv.75+0x3b8>)
 8003cc8:	f7ff fe7a 	bl	80039c0 <test_print>
 8003ccc:	f7ff fd80 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_DBG_ENABLE_STACK_CHECK);
    test_println("");
 8003cd0:	1c20      	adds	r0, r4, #0
 8003cd2:	f7ff fe55 	bl	8003980 <test_println>
    test_print("--- CH_DBG_FILL_THREADS:                ");
 8003cd6:	4835      	ldr	r0, [pc, #212]	; (8003dac <rt_test_001_003_execute.lto_priv.75+0x3bc>)
 8003cd8:	f7ff fe72 	bl	80039c0 <test_print>
 8003cdc:	f7ff fd78 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_DBG_FILL_THREADS);
    test_println("");
 8003ce0:	1c20      	adds	r0, r4, #0
 8003ce2:	f7ff fe4d 	bl	8003980 <test_println>
    test_print("--- CH_DBG_THREADS_PROFILING:           ");
 8003ce6:	4832      	ldr	r0, [pc, #200]	; (8003db0 <rt_test_001_003_execute.lto_priv.75+0x3c0>)
 8003ce8:	f7ff fe6a 	bl	80039c0 <test_print>
 8003cec:	f7ff fd70 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_DBG_THREADS_PROFILING);
    test_println("");
 8003cf0:	1c20      	adds	r0, r4, #0
 8003cf2:	f7ff fe45 	bl	8003980 <test_println>
  }
}
 8003cf6:	bd10      	pop	{r4, pc}
 8003cf8:	20000d64 	.word	0x20000d64
 8003cfc:	0800655c 	.word	0x0800655c
 8003d00:	08006e98 	.word	0x08006e98
 8003d04:	08006588 	.word	0x08006588
 8003d08:	00002710 	.word	0x00002710
 8003d0c:	080065b4 	.word	0x080065b4
 8003d10:	080065e0 	.word	0x080065e0
 8003d14:	0800660c 	.word	0x0800660c
 8003d18:	08006638 	.word	0x08006638
 8003d1c:	08006664 	.word	0x08006664
 8003d20:	08006690 	.word	0x08006690
 8003d24:	080066bc 	.word	0x080066bc
 8003d28:	080066e8 	.word	0x080066e8
 8003d2c:	08006714 	.word	0x08006714
 8003d30:	08006740 	.word	0x08006740
 8003d34:	0800676c 	.word	0x0800676c
 8003d38:	08006798 	.word	0x08006798
 8003d3c:	080067c4 	.word	0x080067c4
 8003d40:	080067f0 	.word	0x080067f0
 8003d44:	0800681c 	.word	0x0800681c
 8003d48:	08006848 	.word	0x08006848
 8003d4c:	08006874 	.word	0x08006874
 8003d50:	080068a0 	.word	0x080068a0
 8003d54:	080068cc 	.word	0x080068cc
 8003d58:	080068f8 	.word	0x080068f8
 8003d5c:	08006924 	.word	0x08006924
 8003d60:	08006950 	.word	0x08006950
 8003d64:	0800697c 	.word	0x0800697c
 8003d68:	080069a8 	.word	0x080069a8
 8003d6c:	080069d4 	.word	0x080069d4
 8003d70:	08006a00 	.word	0x08006a00
 8003d74:	08006a2c 	.word	0x08006a2c
 8003d78:	08006a58 	.word	0x08006a58
 8003d7c:	08006a84 	.word	0x08006a84
 8003d80:	08006ab0 	.word	0x08006ab0
 8003d84:	08006adc 	.word	0x08006adc
 8003d88:	08006b08 	.word	0x08006b08
 8003d8c:	08006b34 	.word	0x08006b34
 8003d90:	08006b60 	.word	0x08006b60
 8003d94:	08006b8c 	.word	0x08006b8c
 8003d98:	08006bb8 	.word	0x08006bb8
 8003d9c:	08006be4 	.word	0x08006be4
 8003da0:	08006c10 	.word	0x08006c10
 8003da4:	08006c3c 	.word	0x08006c3c
 8003da8:	08006c68 	.word	0x08006c68
 8003dac:	08006c94 	.word	0x08006c94
 8003db0:	08006cc0 	.word	0x08006cc0
 8003db4:	46c0      	nop			; (mov r8, r8)
 8003db6:	46c0      	nop			; (mov r8, r8)
 8003db8:	46c0      	nop			; (mov r8, r8)
 8003dba:	46c0      	nop			; (mov r8, r8)
 8003dbc:	46c0      	nop			; (mov r8, r8)
 8003dbe:	46c0      	nop			; (mov r8, r8)

08003dc0 <rt_test_001_002_execute.lto_priv.74>:
 */

static void rt_test_001_002_execute(void) {

  /* [1.2.1] Prints the version string.*/
  test_set_step(1);
 8003dc0:	2201      	movs	r2, #1
 8003dc2:	4b18      	ldr	r3, [pc, #96]	; (8003e24 <rt_test_001_002_execute.lto_priv.74+0x64>)
 * <h2>Test Steps</h2>
 * - [1.2.1] Prints the version string.
 * .
 */

static void rt_test_001_002_execute(void) {
 8003dc4:	b510      	push	{r4, lr}

  /* [1.2.1] Prints the version string.*/
  test_set_step(1);
  {
    test_println("--- Product:                            ChibiOS/RT");
 8003dc6:	4818      	ldr	r0, [pc, #96]	; (8003e28 <rt_test_001_002_execute.lto_priv.74+0x68>)
 */

static void rt_test_001_002_execute(void) {

  /* [1.2.1] Prints the version string.*/
  test_set_step(1);
 8003dc8:	601a      	str	r2, [r3, #0]
  {
    test_println("--- Product:                            ChibiOS/RT");
 8003dca:	f7ff fdd9 	bl	8003980 <test_println>
    test_print("--- Stable Flag:                        ");
 8003dce:	4817      	ldr	r0, [pc, #92]	; (8003e2c <rt_test_001_002_execute.lto_priv.74+0x6c>)
 8003dd0:	f7ff fdf6 	bl	80039c0 <test_print>
    test_printn(CH_KERNEL_STABLE);
 8003dd4:	2001      	movs	r0, #1
 8003dd6:	f7ff fd53 	bl	8003880 <test_printn>
    test_println("");
 8003dda:	4c15      	ldr	r4, [pc, #84]	; (8003e30 <rt_test_001_002_execute.lto_priv.74+0x70>)
 8003ddc:	1c20      	adds	r0, r4, #0
 8003dde:	f7ff fdcf 	bl	8003980 <test_println>
    test_print("--- Version String:                     ");
 8003de2:	4814      	ldr	r0, [pc, #80]	; (8003e34 <rt_test_001_002_execute.lto_priv.74+0x74>)
 8003de4:	f7ff fdec 	bl	80039c0 <test_print>
    test_println(CH_KERNEL_VERSION);
 8003de8:	4813      	ldr	r0, [pc, #76]	; (8003e38 <rt_test_001_002_execute.lto_priv.74+0x78>)
 8003dea:	f7ff fdc9 	bl	8003980 <test_println>
    test_print("--- Major Number:                       ");
 8003dee:	4813      	ldr	r0, [pc, #76]	; (8003e3c <rt_test_001_002_execute.lto_priv.74+0x7c>)
 8003df0:	f7ff fde6 	bl	80039c0 <test_print>
    test_printn(CH_KERNEL_MAJOR);
 8003df4:	2006      	movs	r0, #6
 8003df6:	f7ff fd43 	bl	8003880 <test_printn>
    test_println("");
 8003dfa:	1c20      	adds	r0, r4, #0
 8003dfc:	f7ff fdc0 	bl	8003980 <test_println>
    test_print("--- Minor Number:                       ");
 8003e00:	480f      	ldr	r0, [pc, #60]	; (8003e40 <rt_test_001_002_execute.lto_priv.74+0x80>)
 8003e02:	f7ff fddd 	bl	80039c0 <test_print>
 8003e06:	f7ff fce3 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_KERNEL_MINOR);
    test_println("");
 8003e0a:	1c20      	adds	r0, r4, #0
 8003e0c:	f7ff fdb8 	bl	8003980 <test_println>
    test_print("--- Patch Number:                       ");
 8003e10:	480c      	ldr	r0, [pc, #48]	; (8003e44 <rt_test_001_002_execute.lto_priv.74+0x84>)
 8003e12:	f7ff fdd5 	bl	80039c0 <test_print>
 8003e16:	f7ff fcdb 	bl	80037d0 <test_printn.part.0>
    test_printn(CH_KERNEL_PATCH);
    test_println("");
 8003e1a:	1c20      	adds	r0, r4, #0
 8003e1c:	f7ff fdb0 	bl	8003980 <test_println>
  }
}
 8003e20:	bd10      	pop	{r4, pc}
 8003e22:	46c0      	nop			; (mov r8, r8)
 8003e24:	20000d64 	.word	0x20000d64
 8003e28:	08006cec 	.word	0x08006cec
 8003e2c:	08006d20 	.word	0x08006d20
 8003e30:	08006e98 	.word	0x08006e98
 8003e34:	08006d4c 	.word	0x08006d4c
 8003e38:	08006d78 	.word	0x08006d78
 8003e3c:	08006d80 	.word	0x08006d80
 8003e40:	08006dac 	.word	0x08006dac
 8003e44:	08006dd8 	.word	0x08006dd8
 8003e48:	46c0      	nop			; (mov r8, r8)
 8003e4a:	46c0      	nop			; (mov r8, r8)
 8003e4c:	46c0      	nop			; (mov r8, r8)
 8003e4e:	46c0      	nop			; (mov r8, r8)

08003e50 <rt_test_001_001_execute.lto_priv.73>:
 */

static void rt_test_001_001_execute(void) {

  /* [1.1.1] Prints the version string.*/
  test_set_step(1);
 8003e50:	2201      	movs	r2, #1
 8003e52:	4b1c      	ldr	r3, [pc, #112]	; (8003ec4 <rt_test_001_001_execute.lto_priv.73+0x74>)
 * <h2>Test Steps</h2>
 * - [1.1.1] Prints the version string.
 * .
 */

static void rt_test_001_001_execute(void) {
 8003e54:	b510      	push	{r4, lr}

  /* [1.1.1] Prints the version string.*/
  test_set_step(1);
  {
#if defined(PORT_ARCHITECTURE_NAME)
    test_print("--- Architecture:                       ");
 8003e56:	481c      	ldr	r0, [pc, #112]	; (8003ec8 <rt_test_001_001_execute.lto_priv.73+0x78>)
 */

static void rt_test_001_001_execute(void) {

  /* [1.1.1] Prints the version string.*/
  test_set_step(1);
 8003e58:	601a      	str	r2, [r3, #0]
  {
#if defined(PORT_ARCHITECTURE_NAME)
    test_print("--- Architecture:                       ");
 8003e5a:	f7ff fdb1 	bl	80039c0 <test_print>
    test_println(PORT_ARCHITECTURE_NAME);
 8003e5e:	481b      	ldr	r0, [pc, #108]	; (8003ecc <rt_test_001_001_execute.lto_priv.73+0x7c>)
 8003e60:	f7ff fd8e 	bl	8003980 <test_println>
#endif
#if defined(PORT_CORE_VARIANT_NAME)
    test_print("--- Core Variant:                       ");
 8003e64:	481a      	ldr	r0, [pc, #104]	; (8003ed0 <rt_test_001_001_execute.lto_priv.73+0x80>)
 8003e66:	f7ff fdab 	bl	80039c0 <test_print>
    test_println(PORT_CORE_VARIANT_NAME);
 8003e6a:	481a      	ldr	r0, [pc, #104]	; (8003ed4 <rt_test_001_001_execute.lto_priv.73+0x84>)
 8003e6c:	f7ff fd88 	bl	8003980 <test_println>
#endif
#if defined(PORT_COMPILER_NAME)
    test_print("--- Compiler:                           ");
 8003e70:	4819      	ldr	r0, [pc, #100]	; (8003ed8 <rt_test_001_001_execute.lto_priv.73+0x88>)
 8003e72:	f7ff fda5 	bl	80039c0 <test_print>
    test_println(PORT_COMPILER_NAME);
 8003e76:	4819      	ldr	r0, [pc, #100]	; (8003edc <rt_test_001_001_execute.lto_priv.73+0x8c>)
 8003e78:	f7ff fd82 	bl	8003980 <test_println>
#endif
#if defined(PORT_INFO)
    test_print("--- Port Info:                          ");
 8003e7c:	4818      	ldr	r0, [pc, #96]	; (8003ee0 <rt_test_001_001_execute.lto_priv.73+0x90>)
 8003e7e:	f7ff fd9f 	bl	80039c0 <test_print>
    test_println(PORT_INFO);
 8003e82:	4818      	ldr	r0, [pc, #96]	; (8003ee4 <rt_test_001_001_execute.lto_priv.73+0x94>)
 8003e84:	f7ff fd7c 	bl	8003980 <test_println>
#endif
#if defined(PORT_NATURAL_ALIGN)
    test_print("--- Natural alignment:                  ");
 8003e88:	4817      	ldr	r0, [pc, #92]	; (8003ee8 <rt_test_001_001_execute.lto_priv.73+0x98>)
 8003e8a:	f7ff fd99 	bl	80039c0 <test_print>
    test_printn(PORT_NATURAL_ALIGN);
 8003e8e:	2004      	movs	r0, #4
 8003e90:	f7ff fcf6 	bl	8003880 <test_printn>
    test_println("");
 8003e94:	4c15      	ldr	r4, [pc, #84]	; (8003eec <rt_test_001_001_execute.lto_priv.73+0x9c>)
 8003e96:	1c20      	adds	r0, r4, #0
 8003e98:	f7ff fd72 	bl	8003980 <test_println>
#endif
#if defined(PORT_STACK_ALIGN)
    test_print("--- Stack alignment:                    ");
 8003e9c:	4814      	ldr	r0, [pc, #80]	; (8003ef0 <rt_test_001_001_execute.lto_priv.73+0xa0>)
 8003e9e:	f7ff fd8f 	bl	80039c0 <test_print>
    test_printn(PORT_STACK_ALIGN);
 8003ea2:	2008      	movs	r0, #8
 8003ea4:	f7ff fcec 	bl	8003880 <test_printn>
    test_println("");
 8003ea8:	1c20      	adds	r0, r4, #0
 8003eaa:	f7ff fd69 	bl	8003980 <test_println>
#endif
#if defined(PORT_WORKING_AREA_ALIGN)
    test_print("--- Working area alignment:             ");
 8003eae:	4811      	ldr	r0, [pc, #68]	; (8003ef4 <rt_test_001_001_execute.lto_priv.73+0xa4>)
 8003eb0:	f7ff fd86 	bl	80039c0 <test_print>
    test_printn(PORT_WORKING_AREA_ALIGN);
 8003eb4:	2008      	movs	r0, #8
 8003eb6:	f7ff fce3 	bl	8003880 <test_printn>
    test_println("");
 8003eba:	1c20      	adds	r0, r4, #0
 8003ebc:	f7ff fd60 	bl	8003980 <test_println>
#endif
  }
}
 8003ec0:	bd10      	pop	{r4, pc}
 8003ec2:	46c0      	nop			; (mov r8, r8)
 8003ec4:	20000d64 	.word	0x20000d64
 8003ec8:	08006e04 	.word	0x08006e04
 8003ecc:	08006e30 	.word	0x08006e30
 8003ed0:	08006e38 	.word	0x08006e38
 8003ed4:	08006e64 	.word	0x08006e64
 8003ed8:	08006e70 	.word	0x08006e70
 8003edc:	08006e9c 	.word	0x08006e9c
 8003ee0:	08006ee4 	.word	0x08006ee4
 8003ee4:	08006f10 	.word	0x08006f10
 8003ee8:	08006f28 	.word	0x08006f28
 8003eec:	08006e98 	.word	0x08006e98
 8003ef0:	08006f54 	.word	0x08006f54
 8003ef4:	08006f80 	.word	0x08006f80
 8003ef8:	46c0      	nop			; (mov r8, r8)
 8003efa:	46c0      	nop			; (mov r8, r8)
 8003efc:	46c0      	nop			; (mov r8, r8)
 8003efe:	46c0      	nop			; (mov r8, r8)

08003f00 <_test_assert>:

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
 8003f00:	2300      	movs	r3, #0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 8003f02:	2800      	cmp	r0, #0
 8003f04:	d107      	bne.n	8003f16 <_test_assert+0x16>
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8003f06:	4a05      	ldr	r2, [pc, #20]	; (8003f1c <_test_assert+0x1c>)
 8003f08:	3301      	adds	r3, #1
 8003f0a:	7013      	strb	r3, [r2, #0]
  test_global_fail     = true;
 8003f0c:	4a04      	ldr	r2, [pc, #16]	; (8003f20 <_test_assert+0x20>)
 8003f0e:	7013      	strb	r3, [r2, #0]
  test_failure_message = msg;
 8003f10:	4b04      	ldr	r3, [pc, #16]	; (8003f24 <_test_assert+0x24>)
 8003f12:	6019      	str	r1, [r3, #0]
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
 8003f14:	2301      	movs	r3, #1
  return false;
}
 8003f16:	1c18      	adds	r0, r3, #0
 8003f18:	4770      	bx	lr
 8003f1a:	46c0      	nop			; (mov r8, r8)
 8003f1c:	20000ef8 	.word	0x20000ef8
 8003f20:	20000f58 	.word	0x20000f58
 8003f24:	20000e80 	.word	0x20000e80
 8003f28:	46c0      	nop			; (mov r8, r8)
 8003f2a:	46c0      	nop			; (mov r8, r8)
 8003f2c:	46c0      	nop			; (mov r8, r8)
 8003f2e:	46c0      	nop			; (mov r8, r8)

08003f30 <rt_test_002_002_execute.lto_priv.77>:
 * - [2.2.4] Testing chSysUnconditionalUnlock().
 * - [2.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void rt_test_002_002_execute(void) {
 8003f30:	b530      	push	{r4, r5, lr}
  syssts_t sts;
  virtual_timer_t vt;

  /* [2.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 8003f32:	2501      	movs	r5, #1
 8003f34:	4c26      	ldr	r4, [pc, #152]	; (8003fd0 <rt_test_002_002_execute.lto_priv.77+0xa0>)
 * - [2.2.4] Testing chSysUnconditionalUnlock().
 * - [2.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void rt_test_002_002_execute(void) {
 8003f36:	b087      	sub	sp, #28
  syssts_t sts;
  virtual_timer_t vt;

  /* [2.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 8003f38:	6025      	str	r5, [r4, #0]
  {
    sts = chSysGetStatusAndLockX();
 8003f3a:	f7fd f851 	bl	8000fe0 <chSysGetStatusAndLockX>
 8003f3e:	4205      	tst	r5, r0
 8003f40:	d101      	bne.n	8003f46 <rt_test_002_002_execute.lto_priv.77+0x16>
 8003f42:	f7fd f83d 	bl	8000fc0 <chSysRestoreStatusX.part.2.lto_priv.154>
    chSysRestoreStatusX(sts);
  }

  /* [2.2.2] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), reentrant case.*/
  test_set_step(2);
 8003f46:	2302      	movs	r3, #2
 8003f48:	6023      	str	r3, [r4, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003f4a:	b672      	cpsid	i
  {
    chSysLock();
    sts = chSysGetStatusAndLockX();
 8003f4c:	f7fd f848 	bl	8000fe0 <chSysGetStatusAndLockX>
 8003f50:	07c3      	lsls	r3, r0, #31
 8003f52:	d401      	bmi.n	8003f58 <rt_test_002_002_execute.lto_priv.77+0x28>
 8003f54:	f7fd f834 	bl	8000fc0 <chSysRestoreStatusX.part.2.lto_priv.154>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003f58:	b662      	cpsie	i
    chSysRestoreStatusX(sts);
    chSysUnlock();
  }

  /* [2.2.3] Testing chSysUnconditionalLock().*/
  test_set_step(3);
 8003f5a:	2303      	movs	r3, #3
 8003f5c:	6023      	str	r3, [r4, #0]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003f5e:	f3ef 8310 	mrs	r3, PRIMASK
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8003f62:	07db      	lsls	r3, r3, #31
 8003f64:	d400      	bmi.n	8003f68 <rt_test_002_002_execute.lto_priv.77+0x38>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003f66:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003f68:	f3ef 8310 	mrs	r3, PRIMASK
 8003f6c:	07db      	lsls	r3, r3, #31
 8003f6e:	d400      	bmi.n	8003f72 <rt_test_002_002_execute.lto_priv.77+0x42>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003f70:	b672      	cpsid	i
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003f72:	b662      	cpsie	i
    chSysUnconditionalLock();
    chSysUnlock();
  }

  /* [2.2.4] Testing chSysUnconditionalUnlock().*/
  test_set_step(4);
 8003f74:	2304      	movs	r3, #4
 8003f76:	6023      	str	r3, [r4, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003f78:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003f7a:	f3ef 8310 	mrs	r3, PRIMASK
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 8003f7e:	07db      	lsls	r3, r3, #31
 8003f80:	d500      	bpl.n	8003f84 <rt_test_002_002_execute.lto_priv.77+0x54>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003f82:	b662      	cpsie	i
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 8003f84:	f3ef 8310 	mrs	r3, PRIMASK
 8003f88:	07db      	lsls	r3, r3, #31
 8003f8a:	d500      	bpl.n	8003f8e <rt_test_002_002_execute.lto_priv.77+0x5e>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003f8c:	b662      	cpsie	i
    chSysUnconditionalUnlock();
    chSysUnconditionalUnlock();
  }

  /* [2.2.5] Testing from ISR context using a virtual timer.*/
  test_set_step(5);
 8003f8e:	2305      	movs	r3, #5
 8003f90:	6023      	str	r3, [r4, #0]
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 8003f92:	2300      	movs	r3, #0
 8003f94:	9304      	str	r3, [sp, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003f96:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8003f98:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 8003f9a:	ac01      	add	r4, sp, #4
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8003f9c:	2b00      	cmp	r3, #0
 8003f9e:	d002      	beq.n	8003fa6 <rt_test_002_002_execute.lto_priv.77+0x76>
    chVTDoResetI(vtp);
 8003fa0:	1c20      	adds	r0, r4, #0
 8003fa2:	f7fc fdf5 	bl	8000b90 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, sysinterval_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8003fa6:	1c20      	adds	r0, r4, #0
 8003fa8:	2101      	movs	r1, #1
 8003faa:	4a0a      	ldr	r2, [pc, #40]	; (8003fd4 <rt_test_002_002_execute.lto_priv.77+0xa4>)
 8003fac:	2300      	movs	r3, #0
 8003fae:	f7fc fe2f 	bl	8000c10 <chVTDoSetI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003fb2:	b662      	cpsie	i
  {
    chVTObjectInit(&vt);
    chVTSet(&vt, 1, vtcb, NULL);
    chThdSleep(10);
 8003fb4:	200a      	movs	r0, #10
 8003fb6:	f7fc fffb 	bl	8000fb0 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003fba:	b672      	cpsid	i
 8003fbc:	9804      	ldr	r0, [sp, #16]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003fbe:	b662      	cpsie	i

    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 8003fc0:	4243      	negs	r3, r0
 8003fc2:	4158      	adcs	r0, r3
 8003fc4:	4904      	ldr	r1, [pc, #16]	; (8003fd8 <rt_test_002_002_execute.lto_priv.77+0xa8>)
 8003fc6:	b2c0      	uxtb	r0, r0
 8003fc8:	f7ff ff9a 	bl	8003f00 <_test_assert>
  }
}
 8003fcc:	b007      	add	sp, #28
 8003fce:	bd30      	pop	{r4, r5, pc}
 8003fd0:	20000d64 	.word	0x20000d64
 8003fd4:	08003861 	.word	0x08003861
 8003fd8:	08006fac 	.word	0x08006fac
 8003fdc:	46c0      	nop			; (mov r8, r8)
 8003fde:	46c0      	nop			; (mov r8, r8)

08003fe0 <rt_test_002_001_execute.lto_priv.76>:
 * - [2.1.3] Testing Registry List integrity.
 * - [2.1.4] Testing Port-defined integrity.
 * .
 */

static void rt_test_002_001_execute(void) {
 8003fe0:	b538      	push	{r3, r4, r5, lr}
  bool result;

  /* [2.1.1] Testing Ready List integrity.*/
  test_set_step(1);
 8003fe2:	2301      	movs	r3, #1
 8003fe4:	4d1c      	ldr	r5, [pc, #112]	; (8004058 <rt_test_002_001_execute.lto_priv.76+0x78>)
 8003fe6:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003fe8:	b672      	cpsid	i
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8003fea:	2001      	movs	r0, #1
 8003fec:	f7fd f800 	bl	8000ff0 <chSysIntegrityCheckI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003ff0:	b662      	cpsie	i
    chSysUnlock();
    test_assert(result == false, "ready list check failed");
 8003ff2:	2401      	movs	r4, #1
 8003ff4:	4060      	eors	r0, r4
 8003ff6:	b2c0      	uxtb	r0, r0
 8003ff8:	4918      	ldr	r1, [pc, #96]	; (800405c <rt_test_002_001_execute.lto_priv.76+0x7c>)
 8003ffa:	f7ff ff81 	bl	8003f00 <_test_assert>
 8003ffe:	2800      	cmp	r0, #0
 8004000:	d000      	beq.n	8004004 <rt_test_002_001_execute.lto_priv.76+0x24>
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
    chSysUnlock();
    test_assert(result == false, "port layer check failed");
  }
}
 8004002:	bd38      	pop	{r3, r4, r5, pc}
    chSysUnlock();
    test_assert(result == false, "ready list check failed");
  }

  /* [2.1.2] Testing Virtual Timers List integrity.*/
  test_set_step(2);
 8004004:	2302      	movs	r3, #2
 8004006:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004008:	b672      	cpsid	i
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 800400a:	3002      	adds	r0, #2
 800400c:	f7fc fff0 	bl	8000ff0 <chSysIntegrityCheckI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004010:	b662      	cpsie	i
    chSysUnlock();
    test_assert(result == false, "virtual timers list check failed");
 8004012:	4060      	eors	r0, r4
 8004014:	b2c0      	uxtb	r0, r0
 8004016:	4912      	ldr	r1, [pc, #72]	; (8004060 <rt_test_002_001_execute.lto_priv.76+0x80>)
 8004018:	f7ff ff72 	bl	8003f00 <_test_assert>
 800401c:	2800      	cmp	r0, #0
 800401e:	d1f0      	bne.n	8004002 <rt_test_002_001_execute.lto_priv.76+0x22>
  }

  /* [2.1.3] Testing Registry List integrity.*/
  test_set_step(3);
 8004020:	2303      	movs	r3, #3
 8004022:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004024:	b672      	cpsid	i
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8004026:	3004      	adds	r0, #4
 8004028:	f7fc ffe2 	bl	8000ff0 <chSysIntegrityCheckI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800402c:	b662      	cpsie	i
    chSysUnlock();
    test_assert(result == false, "registry list check failed");
 800402e:	4060      	eors	r0, r4
 8004030:	b2c0      	uxtb	r0, r0
 8004032:	490c      	ldr	r1, [pc, #48]	; (8004064 <rt_test_002_001_execute.lto_priv.76+0x84>)
 8004034:	f7ff ff64 	bl	8003f00 <_test_assert>
 8004038:	2800      	cmp	r0, #0
 800403a:	d1e2      	bne.n	8004002 <rt_test_002_001_execute.lto_priv.76+0x22>
  }

  /* [2.1.4] Testing Port-defined integrity.*/
  test_set_step(4);
 800403c:	2304      	movs	r3, #4
 800403e:	602b      	str	r3, [r5, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004040:	b672      	cpsid	i
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8004042:	3008      	adds	r0, #8
 8004044:	f7fc ffd4 	bl	8000ff0 <chSysIntegrityCheckI>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004048:	b662      	cpsie	i
    chSysUnlock();
    test_assert(result == false, "port layer check failed");
 800404a:	4044      	eors	r4, r0
 800404c:	b2e0      	uxtb	r0, r4
 800404e:	4906      	ldr	r1, [pc, #24]	; (8004068 <rt_test_002_001_execute.lto_priv.76+0x88>)
 8004050:	f7ff ff56 	bl	8003f00 <_test_assert>
 8004054:	e7d5      	b.n	8004002 <rt_test_002_001_execute.lto_priv.76+0x22>
 8004056:	46c0      	nop			; (mov r8, r8)
 8004058:	20000d64 	.word	0x20000d64
 800405c:	08006fc0 	.word	0x08006fc0
 8004060:	08006fd8 	.word	0x08006fd8
 8004064:	08006ffc 	.word	0x08006ffc
 8004068:	08007018 	.word	0x08007018
 800406c:	46c0      	nop			; (mov r8, r8)
 800406e:	46c0      	nop			; (mov r8, r8)

08004070 <print_line.lto_priv.139>:
  tcp->execute();
  if (tcp->teardown != NULL)
    tcp->teardown();
}

static void print_line(void) {
 8004070:	b538      	push	{r3, r4, r5, lr}
 8004072:	244c      	movs	r4, #76	; 0x4c
 8004074:	4d07      	ldr	r5, [pc, #28]	; (8004094 <print_line.lto_priv.139+0x24>)
  unsigned i;

  for (i = 0; i < 76; i++)
    streamPut(test_chp, '-');
 8004076:	6828      	ldr	r0, [r5, #0]
 8004078:	212d      	movs	r1, #45	; 0x2d
 800407a:	6803      	ldr	r3, [r0, #0]
 800407c:	3c01      	subs	r4, #1
 800407e:	68db      	ldr	r3, [r3, #12]
 8004080:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 8004082:	2c00      	cmp	r4, #0
 8004084:	d1f7      	bne.n	8004076 <print_line.lto_priv.139+0x6>
    streamPut(test_chp, '-');
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8004086:	6828      	ldr	r0, [r5, #0]
 8004088:	4903      	ldr	r1, [pc, #12]	; (8004098 <print_line.lto_priv.139+0x28>)
 800408a:	6803      	ldr	r3, [r0, #0]
 800408c:	2202      	movs	r2, #2
 800408e:	685b      	ldr	r3, [r3, #4]
 8004090:	4798      	blx	r3
}
 8004092:	bd38      	pop	{r3, r4, r5, pc}
 8004094:	200006e4 	.word	0x200006e4
 8004098:	08005ce4 	.word	0x08005ce4
 800409c:	46c0      	nop			; (mov r8, r8)
 800409e:	46c0      	nop			; (mov r8, r8)

080040a0 <_port_irq_epilogue>:
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 80040a0:	300f      	adds	r0, #15
 80040a2:	d011      	beq.n	80040c8 <_port_irq_epilogue+0x28>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80040a4:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80040a6:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80040aa:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80040ac:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80040b0:	2280      	movs	r2, #128	; 0x80
 80040b2:	0452      	lsls	r2, r2, #17
 80040b4:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80040b6:	4a06      	ldr	r2, [pc, #24]	; (80040d0 <_port_irq_epilogue+0x30>)
 80040b8:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 80040ba:	6992      	ldr	r2, [r2, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80040bc:	6889      	ldr	r1, [r1, #8]
 80040be:	6892      	ldr	r2, [r2, #8]
 80040c0:	4291      	cmp	r1, r2
 80040c2:	d802      	bhi.n	80040ca <_port_irq_epilogue+0x2a>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80040c4:	4a03      	ldr	r2, [pc, #12]	; (80040d4 <_port_irq_epilogue+0x34>)
 80040c6:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 80040c8:	4770      	bx	lr

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80040ca:	4a03      	ldr	r2, [pc, #12]	; (80040d8 <_port_irq_epilogue+0x38>)
 80040cc:	619a      	str	r2, [r3, #24]
 80040ce:	e7fb      	b.n	80040c8 <_port_irq_epilogue+0x28>
 80040d0:	20000e84 	.word	0x20000e84
 80040d4:	080001c8 	.word	0x080001c8
 80040d8:	080001c5 	.word	0x080001c5
 80040dc:	46c0      	nop			; (mov r8, r8)
 80040de:	46c0      	nop			; (mov r8, r8)

080040e0 <NMI_Handler>:
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80040e0:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80040e4:	3320      	adds	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80040e6:	f383 8809 	msr	PSP, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80040ea:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 80040ec:	4770      	bx	lr
 80040ee:	46c0      	nop			; (mov r8, r8)

080040f0 <chMsgWait>:
 *
 * @return              A pointer to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 80040f0:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80040f2:	b672      	cpsid	i
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 80040f4:	4c0b      	ldr	r4, [pc, #44]	; (8004124 <chMsgWait+0x34>)
 80040f6:	69a3      	ldr	r3, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
 80040f8:	1c1a      	adds	r2, r3, #0
 80040fa:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 80040fc:	322c      	adds	r2, #44	; 0x2c
 80040fe:	4290      	cmp	r0, r2
 8004100:	d007      	beq.n	8004112 <chMsgWait+0x22>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8004102:	6801      	ldr	r1, [r0, #0]
 8004104:	62d9      	str	r1, [r3, #44]	; 0x2c
  tqp->next->queue.prev = (thread_t *)tqp;
 8004106:	604a      	str	r2, [r1, #4]
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->msgqueue);
  tp->state = CH_STATE_SNDMSG;
 8004108:	2320      	movs	r3, #32
 800410a:	220d      	movs	r2, #13
 800410c:	54c2      	strb	r2, [r0, r3]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800410e:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8004110:	bd10      	pop	{r4, pc}
thread_t *chMsgWait(void) {
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    chSchGoSleepS(CH_STATE_WTMSG);
 8004112:	200e      	movs	r0, #14
 8004114:	f7fc fa84 	bl	8000620 <chSchGoSleepS>
 8004118:	69a3      	ldr	r3, [r4, #24]
 800411a:	1c1a      	adds	r2, r3, #0
 800411c:	6ad8      	ldr	r0, [r3, #44]	; 0x2c
 800411e:	322c      	adds	r2, #44	; 0x2c
 8004120:	e7ef      	b.n	8004102 <chMsgWait+0x12>
 8004122:	46c0      	nop			; (mov r8, r8)
 8004124:	20000e84 	.word	0x20000e84
 8004128:	46c0      	nop			; (mov r8, r8)
 800412a:	46c0      	nop			; (mov r8, r8)
 800412c:	46c0      	nop			; (mov r8, r8)
 800412e:	46c0      	nop			; (mov r8, r8)

08004130 <chMsgSend>:
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
  thread_t *ctp = currp;
 8004130:	4b0c      	ldr	r3, [pc, #48]	; (8004164 <chMsgSend+0x34>)
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8004132:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8004134:	699c      	ldr	r4, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004136:	b672      	cpsid	i

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->u.sentmsg = msg;
  msg_insert(ctp, &tp->msgqueue);
 8004138:	1c03      	adds	r3, r0, #0
  thread_t *ctp = currp;

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->u.sentmsg = msg;
 800413a:	6261      	str	r1, [r4, #36]	; 0x24
  msg_insert(ctp, &tp->msgqueue);
 800413c:	332c      	adds	r3, #44	; 0x2c
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 800413e:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = tqp->prev;
 8004140:	6b03      	ldr	r3, [r0, #48]	; 0x30
 8004142:	6063      	str	r3, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8004144:	601c      	str	r4, [r3, #0]
  if (tp->state == CH_STATE_WTMSG) {
 8004146:	2320      	movs	r3, #32
  tqp->prev                  = tp;
 8004148:	6304      	str	r4, [r0, #48]	; 0x30
 800414a:	5cc3      	ldrb	r3, [r0, r3]
 800414c:	2b0e      	cmp	r3, #14
 800414e:	d005      	beq.n	800415c <chMsgSend+0x2c>
    (void) chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8004150:	200c      	movs	r0, #12
 8004152:	f7fc fa65 	bl	8000620 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 8004156:	6a60      	ldr	r0, [r4, #36]	; 0x24
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004158:	b662      	cpsie	i
  chSysUnlock();

  return msg;
}
 800415a:	bd10      	pop	{r4, pc}

  chSysLock();
  ctp->u.sentmsg = msg;
  msg_insert(ctp, &tp->msgqueue);
  if (tp->state == CH_STATE_WTMSG) {
    (void) chSchReadyI(tp);
 800415c:	f7fc fa98 	bl	8000690 <chSchReadyI>
 8004160:	e7f6      	b.n	8004150 <chMsgSend+0x20>
 8004162:	46c0      	nop			; (mov r8, r8)
 8004164:	20000e84 	.word	0x20000e84
 8004168:	46c0      	nop			; (mov r8, r8)
 800416a:	46c0      	nop			; (mov r8, r8)
 800416c:	46c0      	nop			; (mov r8, r8)
 800416e:	46c0      	nop			; (mov r8, r8)

08004170 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8004170:	b508      	push	{r3, lr}

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8004172:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8004174:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004176:	2320      	movs	r3, #32
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8004178:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 800417a:	5cc3      	ldrb	r3, [r0, r3]
 800417c:	2b0a      	cmp	r3, #10
 800417e:	d00b      	beq.n	8004198 <chEvtSignalI+0x28>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8004180:	2b0b      	cmp	r3, #11
 8004182:	d000      	beq.n	8004186 <chEvtSignalI+0x16>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 8004184:	bd08      	pop	{r3, pc}
  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8004186:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8004188:	4019      	ands	r1, r3

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 800418a:	428b      	cmp	r3, r1
 800418c:	d1fa      	bne.n	8004184 <chEvtSignalI+0x14>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 800418e:	2300      	movs	r3, #0
 8004190:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8004192:	f7fc fa7d 	bl	8000690 <chSchReadyI>
 8004196:	e7f5      	b.n	8004184 <chEvtSignalI+0x14>
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004198:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800419a:	420b      	tst	r3, r1
 800419c:	d0f2      	beq.n	8004184 <chEvtSignalI+0x14>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 800419e:	2300      	movs	r3, #0
 80041a0:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 80041a2:	f7fc fa75 	bl	8000690 <chSchReadyI>
 80041a6:	e7ed      	b.n	8004184 <chEvtSignalI+0x14>
 80041a8:	46c0      	nop			; (mov r8, r8)
 80041aa:	46c0      	nop			; (mov r8, r8)
 80041ac:	46c0      	nop			; (mov r8, r8)
 80041ae:	46c0      	nop			; (mov r8, r8)

080041b0 <rt_test_006_009_setup.lto_priv.111>:
 80041b0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80041b2:	4b06      	ldr	r3, [pc, #24]	; (80041cc <rt_test_006_009_setup.lto_priv.111+0x1c>)
 80041b4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80041b6:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80041b8:	4b05      	ldr	r3, [pc, #20]	; (80041d0 <rt_test_006_009_setup.lto_priv.111+0x20>)
 80041ba:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80041bc:	605b      	str	r3, [r3, #4]
 80041be:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80041c0:	4b04      	ldr	r3, [pc, #16]	; (80041d4 <rt_test_006_009_setup.lto_priv.111+0x24>)
 80041c2:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80041c4:	605b      	str	r3, [r3, #4]
 80041c6:	609a      	str	r2, [r3, #8]

static void rt_test_006_009_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 80041c8:	4770      	bx	lr
 80041ca:	46c0      	nop			; (mov r8, r8)
 80041cc:	20000428 	.word	0x20000428
 80041d0:	20000418 	.word	0x20000418
 80041d4:	20000408 	.word	0x20000408
 80041d8:	46c0      	nop			; (mov r8, r8)
 80041da:	46c0      	nop			; (mov r8, r8)
 80041dc:	46c0      	nop			; (mov r8, r8)
 80041de:	46c0      	nop			; (mov r8, r8)

080041e0 <rt_test_006_008_setup.lto_priv.109>:
 80041e0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80041e2:	4b04      	ldr	r3, [pc, #16]	; (80041f4 <rt_test_006_008_setup.lto_priv.109+0x14>)
 80041e4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80041e6:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80041e8:	4b03      	ldr	r3, [pc, #12]	; (80041f8 <rt_test_006_008_setup.lto_priv.109+0x18>)
 80041ea:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80041ec:	605b      	str	r3, [r3, #4]
 80041ee:	609a      	str	r2, [r3, #8]
 */

static void rt_test_006_008_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}
 80041f0:	4770      	bx	lr
 80041f2:	46c0      	nop			; (mov r8, r8)
 80041f4:	20000428 	.word	0x20000428
 80041f8:	20000418 	.word	0x20000418
 80041fc:	46c0      	nop			; (mov r8, r8)
 80041fe:	46c0      	nop			; (mov r8, r8)

08004200 <rt_test_006_007_setup.lto_priv.107>:
 8004200:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004202:	4b04      	ldr	r3, [pc, #16]	; (8004214 <rt_test_006_007_setup.lto_priv.107+0x14>)
 8004204:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004206:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004208:	4b03      	ldr	r3, [pc, #12]	; (8004218 <rt_test_006_007_setup.lto_priv.107+0x18>)
 800420a:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800420c:	605b      	str	r3, [r3, #4]
 800420e:	609a      	str	r2, [r3, #8]
 */

static void rt_test_006_007_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}
 8004210:	4770      	bx	lr
 8004212:	46c0      	nop			; (mov r8, r8)
 8004214:	20000428 	.word	0x20000428
 8004218:	20000418 	.word	0x20000418
 800421c:	46c0      	nop			; (mov r8, r8)
 800421e:	46c0      	nop			; (mov r8, r8)

08004220 <rt_test_006_005_setup.lto_priv.105>:
 8004220:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004222:	4b02      	ldr	r3, [pc, #8]	; (800422c <rt_test_006_005_setup.lto_priv.105+0xc>)
 8004224:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004226:	605b      	str	r3, [r3, #4]
 8004228:	609a      	str	r2, [r3, #8]
 * .
 */

static void rt_test_006_005_setup(void) {
  chMtxObjectInit(&m1);
}
 800422a:	4770      	bx	lr
 800422c:	20000418 	.word	0x20000418

08004230 <rt_test_006_004_setup.lto_priv.102>:
 8004230:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004232:	4b04      	ldr	r3, [pc, #16]	; (8004244 <rt_test_006_004_setup.lto_priv.102+0x14>)
 8004234:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004236:	605b      	str	r3, [r3, #4]
 8004238:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800423a:	4b03      	ldr	r3, [pc, #12]	; (8004248 <rt_test_006_004_setup.lto_priv.102+0x18>)
 800423c:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 800423e:	605b      	str	r3, [r3, #4]
 8004240:	609a      	str	r2, [r3, #8]
 */

static void rt_test_006_004_setup(void) {
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 8004242:	4770      	bx	lr
 8004244:	20000418 	.word	0x20000418
 8004248:	20000408 	.word	0x20000408
 800424c:	46c0      	nop			; (mov r8, r8)
 800424e:	46c0      	nop			; (mov r8, r8)

08004250 <rt_test_006_001_setup.lto_priv.100>:
 8004250:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004252:	4b02      	ldr	r3, [pc, #8]	; (800425c <rt_test_006_001_setup.lto_priv.100+0xc>)
 8004254:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004256:	605b      	str	r3, [r3, #4]
 8004258:	609a      	str	r2, [r3, #8]
 * .
 */

static void rt_test_006_001_setup(void) {
  chMtxObjectInit(&m1);
}
 800425a:	4770      	bx	lr
 800425c:	20000418 	.word	0x20000418

08004260 <rt_test_008_004_setup.lto_priv.119>:
 *   been received after 50mS and that the event flags mask has been
 *   emptied.
 * .
 */

static void rt_test_008_004_setup(void) {
 8004260:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8004262:	f000 ff25 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
}
 8004266:	bd08      	pop	{r3, pc}
 8004268:	46c0      	nop			; (mov r8, r8)
 800426a:	46c0      	nop			; (mov r8, r8)
 800426c:	46c0      	nop			; (mov r8, r8)
 800426e:	46c0      	nop			; (mov r8, r8)

08004270 <rt_test_008_003_setup.lto_priv.117>:
 *   been received after 50mS and that the event flags mask has been
 *   emptied.
 * .
 */

static void rt_test_008_003_setup(void) {
 8004270:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8004272:	f000 ff1d 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
}
 8004276:	bd08      	pop	{r3, pc}
 8004278:	46c0      	nop			; (mov r8, r8)
 800427a:	46c0      	nop			; (mov r8, r8)
 800427c:	46c0      	nop			; (mov r8, r8)
 800427e:	46c0      	nop			; (mov r8, r8)

08004280 <rt_test_008_002_setup.lto_priv.115>:
 * - [8.2.1] Three evenf flag bits are raised then chEvtDispatch() is
 *   invoked, the sequence of handlers calls is tested.
 * .
 */

static void rt_test_008_002_setup(void) {
 8004280:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8004282:	f000 ff15 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
}
 8004286:	bd08      	pop	{r3, pc}
 8004288:	46c0      	nop			; (mov r8, r8)
 800428a:	46c0      	nop			; (mov r8, r8)
 800428c:	46c0      	nop			; (mov r8, r8)
 800428e:	46c0      	nop			; (mov r8, r8)

08004290 <rt_test_008_004_execute.lto_priv.120>:
static void rt_test_008_004_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [8.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8004290:	2301      	movs	r3, #1

static void rt_test_008_004_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void rt_test_008_004_execute(void) {
 8004292:	b570      	push	{r4, r5, r6, lr}
  eventmask_t m;
  systime_t target_time;

  /* [8.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8004294:	4c29      	ldr	r4, [pc, #164]	; (800433c <rt_test_008_004_execute.lto_priv.120+0xac>)
  {
    chEvtAddEvents(5);
 8004296:	2005      	movs	r0, #5
static void rt_test_008_004_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [8.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8004298:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(5);
 800429a:	f7fc f899 	bl	80003d0 <chEvtAddEvents>
  }

  /* [8.4.2] Calling chEvtWaitAny() one time, the two flags must be
     returned.*/
  test_set_step(2);
 800429e:	2302      	movs	r3, #2
 80042a0:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
 80042a2:	f000 ff2d 	bl	8005100 <chEvtWaitAny.constprop.15>
    test_assert(m == 5, "unexpected pending bit");
 80042a6:	3805      	subs	r0, #5
 80042a8:	4242      	negs	r2, r0
 80042aa:	4142      	adcs	r2, r0
 80042ac:	4924      	ldr	r1, [pc, #144]	; (8004340 <rt_test_008_004_execute.lto_priv.120+0xb0>)
 80042ae:	b2d0      	uxtb	r0, r2
 80042b0:	f7ff fe26 	bl	8003f00 <_test_assert>
 80042b4:	2800      	cmp	r0, #0
 80042b6:	d000      	beq.n	80042ba <rt_test_008_004_execute.lto_priv.120+0x2a>
    test_assert(m == 1, "event flag error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }
}
 80042b8:	bd70      	pop	{r4, r5, r6, pc}
     returned.*/
  test_set_step(2);
  {
    m = chEvtWaitAny(ALL_EVENTS);
    test_assert(m == 5, "unexpected pending bit");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 80042ba:	f000 fef9 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
 80042be:	1c03      	adds	r3, r0, #0
    test_assert(m == 0, "stuck event");
 80042c0:	4258      	negs	r0, r3
 80042c2:	4158      	adcs	r0, r3
 80042c4:	4d1f      	ldr	r5, [pc, #124]	; (8004344 <rt_test_008_004_execute.lto_priv.120+0xb4>)
 80042c6:	b2c0      	uxtb	r0, r0
 80042c8:	1c29      	adds	r1, r5, #0
 80042ca:	f7ff fe19 	bl	8003f00 <_test_assert>
 80042ce:	2800      	cmp	r0, #0
 80042d0:	d1f2      	bne.n	80042b8 <rt_test_008_004_execute.lto_priv.120+0x28>
  }

  /* [8.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 80042d2:	2303      	movs	r3, #3
 80042d4:	6023      	str	r3, [r4, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 80042d6:	f7ff fb03 	bl	80038e0 <test_wait_tick>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80042da:	4b1b      	ldr	r3, [pc, #108]	; (8004348 <rt_test_008_004_execute.lto_priv.120+0xb8>)
 80042dc:	1c06      	adds	r6, r0, #0
 80042de:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80042e0:	481a      	ldr	r0, [pc, #104]	; (800434c <rt_test_008_004_execute.lto_priv.120+0xbc>)
 80042e2:	689a      	ldr	r2, [r3, #8]
 80042e4:	1e51      	subs	r1, r2, #1
 80042e6:	4a1a      	ldr	r2, [pc, #104]	; (8004350 <rt_test_008_004_execute.lto_priv.120+0xc0>)
 80042e8:	f000 fe0a 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80042ec:	4b19      	ldr	r3, [pc, #100]	; (8004354 <rt_test_008_004_execute.lto_priv.120+0xc4>)
 80042ee:	6018      	str	r0, [r3, #0]
  }

  /* [8.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 80042f0:	2304      	movs	r3, #4
 80042f2:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
 80042f4:	f000 ff04 	bl	8005100 <chEvtWaitAny.constprop.15>

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)((systime_t)-1));
#endif

  return systime + (systime_t)interval;
 80042f8:	2382      	movs	r3, #130	; 0x82
 80042fa:	1c04      	adds	r4, r0, #0
 80042fc:	1c30      	adds	r0, r6, #0
 80042fe:	009b      	lsls	r3, r3, #2
 8004300:	30f5      	adds	r0, #245	; 0xf5
 8004302:	30ff      	adds	r0, #255	; 0xff
 8004304:	18f1      	adds	r1, r6, r3
    test_assert_time_window(target_time,
 8004306:	f001 f843 	bl	8005390 <_test_assert_time_window.constprop.2>
 800430a:	2800      	cmp	r0, #0
 800430c:	d1d4      	bne.n	80042b8 <rt_test_008_004_execute.lto_priv.120+0x28>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    test_assert(m == 1, "event flag error");
 800430e:	1e60      	subs	r0, r4, #1
 8004310:	4243      	negs	r3, r0
 8004312:	4143      	adcs	r3, r0
 8004314:	4910      	ldr	r1, [pc, #64]	; (8004358 <rt_test_008_004_execute.lto_priv.120+0xc8>)
 8004316:	b2d8      	uxtb	r0, r3
 8004318:	f7ff fdf2 	bl	8003f00 <_test_assert>
 800431c:	2800      	cmp	r0, #0
 800431e:	d1cb      	bne.n	80042b8 <rt_test_008_004_execute.lto_priv.120+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004320:	f000 fec6 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
 8004324:	1c03      	adds	r3, r0, #0
    test_assert(m == 0, "stuck event");
 8004326:	4258      	negs	r0, r3
 8004328:	4158      	adcs	r0, r3
 800432a:	1c29      	adds	r1, r5, #0
 800432c:	b2c0      	uxtb	r0, r0
 800432e:	f7ff fde7 	bl	8003f00 <_test_assert>
 8004332:	2800      	cmp	r0, #0
 8004334:	d1c0      	bne.n	80042b8 <rt_test_008_004_execute.lto_priv.120+0x28>
    test_wait_threads();
 8004336:	f7ff fae3 	bl	8003900 <test_wait_threads>
 800433a:	e7bd      	b.n	80042b8 <rt_test_008_004_execute.lto_priv.120+0x28>
 800433c:	20000d64 	.word	0x20000d64
 8004340:	080057b4 	.word	0x080057b4
 8004344:	08005788 	.word	0x08005788
 8004348:	20000e84 	.word	0x20000e84
 800434c:	200006e8 	.word	0x200006e8
 8004350:	080045c1 	.word	0x080045c1
 8004354:	20000d68 	.word	0x20000d68
 8004358:	08007030 	.word	0x08007030
 800435c:	46c0      	nop			; (mov r8, r8)
 800435e:	46c0      	nop			; (mov r8, r8)

08004360 <rt_test_006_004_teardown.lto_priv.103>:
static void rt_test_006_004_setup(void) {
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void rt_test_006_004_teardown(void) {
 8004360:	b508      	push	{r3, lr}
  test_wait_threads();
 8004362:	f7ff facd 	bl	8003900 <test_wait_threads>
}
 8004366:	bd08      	pop	{r3, pc}
 8004368:	46c0      	nop			; (mov r8, r8)
 800436a:	46c0      	nop			; (mov r8, r8)
 800436c:	46c0      	nop			; (mov r8, r8)
 800436e:	46c0      	nop			; (mov r8, r8)

08004370 <rt_test_008_003_execute.lto_priv.118>:
static void rt_test_008_003_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [8.3.1] Setting three event flags.*/
  test_set_step(1);
 8004370:	2301      	movs	r3, #1

static void rt_test_008_003_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void rt_test_008_003_execute(void) {
 8004372:	b570      	push	{r4, r5, r6, lr}
  eventmask_t m;
  systime_t target_time;

  /* [8.3.1] Setting three event flags.*/
  test_set_step(1);
 8004374:	4c35      	ldr	r4, [pc, #212]	; (800444c <rt_test_008_003_execute.lto_priv.118+0xdc>)
  {
    chEvtAddEvents(7);
 8004376:	2007      	movs	r0, #7
static void rt_test_008_003_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [8.3.1] Setting three event flags.*/
  test_set_step(1);
 8004378:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(7);
 800437a:	f7fc f829 	bl	80003d0 <chEvtAddEvents>
  }

  /* [8.3.2] Calling chEvtWaitOne() three times, each time a single
     flag must be returned in order of priority.*/
  test_set_step(2);
 800437e:	2302      	movs	r3, #2
 8004380:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8004382:	f000 fea5 	bl	80050d0 <chEvtWaitOne.constprop.16>
    test_assert(m == 1, "single event error");
 8004386:	3801      	subs	r0, #1
 8004388:	4242      	negs	r2, r0
 800438a:	4142      	adcs	r2, r0
 800438c:	4d30      	ldr	r5, [pc, #192]	; (8004450 <rt_test_008_003_execute.lto_priv.118+0xe0>)
 800438e:	b2d0      	uxtb	r0, r2
 8004390:	1c29      	adds	r1, r5, #0
 8004392:	f7ff fdb5 	bl	8003f00 <_test_assert>
 8004396:	2800      	cmp	r0, #0
 8004398:	d000      	beq.n	800439c <rt_test_008_003_execute.lto_priv.118+0x2c>
    test_assert(m == 1, "event flag error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }
}
 800439a:	bd70      	pop	{r4, r5, r6, pc}
     flag must be returned in order of priority.*/
  test_set_step(2);
  {
    m = chEvtWaitOne(ALL_EVENTS);
    test_assert(m == 1, "single event error");
    m = chEvtWaitOne(ALL_EVENTS);
 800439c:	f000 fe98 	bl	80050d0 <chEvtWaitOne.constprop.16>
    test_assert(m == 2, "single event error");
 80043a0:	3802      	subs	r0, #2
 80043a2:	4242      	negs	r2, r0
 80043a4:	4142      	adcs	r2, r0
 80043a6:	1c29      	adds	r1, r5, #0
 80043a8:	b2d0      	uxtb	r0, r2
 80043aa:	f7ff fda9 	bl	8003f00 <_test_assert>
 80043ae:	2800      	cmp	r0, #0
 80043b0:	d1f3      	bne.n	800439a <rt_test_008_003_execute.lto_priv.118+0x2a>
    m = chEvtWaitOne(ALL_EVENTS);
 80043b2:	f000 fe8d 	bl	80050d0 <chEvtWaitOne.constprop.16>
    test_assert(m == 4, "single event error");
 80043b6:	3804      	subs	r0, #4
 80043b8:	4242      	negs	r2, r0
 80043ba:	4142      	adcs	r2, r0
 80043bc:	1c29      	adds	r1, r5, #0
 80043be:	b2d0      	uxtb	r0, r2
 80043c0:	f7ff fd9e 	bl	8003f00 <_test_assert>
 80043c4:	2800      	cmp	r0, #0
 80043c6:	d1e8      	bne.n	800439a <rt_test_008_003_execute.lto_priv.118+0x2a>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 80043c8:	f000 fe72 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
 80043cc:	1c03      	adds	r3, r0, #0
    test_assert(m == 0, "stuck event");
 80043ce:	4258      	negs	r0, r3
 80043d0:	4158      	adcs	r0, r3
 80043d2:	4d20      	ldr	r5, [pc, #128]	; (8004454 <rt_test_008_003_execute.lto_priv.118+0xe4>)
 80043d4:	b2c0      	uxtb	r0, r0
 80043d6:	1c29      	adds	r1, r5, #0
 80043d8:	f7ff fd92 	bl	8003f00 <_test_assert>
 80043dc:	2800      	cmp	r0, #0
 80043de:	d1dc      	bne.n	800439a <rt_test_008_003_execute.lto_priv.118+0x2a>
  }

  /* [8.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 80043e0:	2303      	movs	r3, #3
 80043e2:	6023      	str	r3, [r4, #0]
  {
    target_time = chTimeAddX(test_wait_tick(), TIME_MS2I(50));
 80043e4:	f7ff fa7c 	bl	80038e0 <test_wait_tick>
 80043e8:	4b1b      	ldr	r3, [pc, #108]	; (8004458 <rt_test_008_003_execute.lto_priv.118+0xe8>)
 80043ea:	1c06      	adds	r6, r0, #0
 80043ec:	699b      	ldr	r3, [r3, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80043ee:	481b      	ldr	r0, [pc, #108]	; (800445c <rt_test_008_003_execute.lto_priv.118+0xec>)
 80043f0:	689a      	ldr	r2, [r3, #8]
 80043f2:	1e51      	subs	r1, r2, #1
 80043f4:	4a1a      	ldr	r2, [pc, #104]	; (8004460 <rt_test_008_003_execute.lto_priv.118+0xf0>)
 80043f6:	f000 fd83 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80043fa:	4b1a      	ldr	r3, [pc, #104]	; (8004464 <rt_test_008_003_execute.lto_priv.118+0xf4>)
 80043fc:	6018      	str	r0, [r3, #0]
  }

  /* [8.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 80043fe:	2304      	movs	r3, #4
 8004400:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8004402:	f000 fe65 	bl	80050d0 <chEvtWaitOne.constprop.16>
 8004406:	2382      	movs	r3, #130	; 0x82
 8004408:	1c04      	adds	r4, r0, #0
 800440a:	1c30      	adds	r0, r6, #0
 800440c:	009b      	lsls	r3, r3, #2
 800440e:	30f5      	adds	r0, #245	; 0xf5
 8004410:	30ff      	adds	r0, #255	; 0xff
 8004412:	18f1      	adds	r1, r6, r3
    test_assert_time_window(target_time,
 8004414:	f000 ffbc 	bl	8005390 <_test_assert_time_window.constprop.2>
 8004418:	2800      	cmp	r0, #0
 800441a:	d1be      	bne.n	800439a <rt_test_008_003_execute.lto_priv.118+0x2a>
                            chTimeAddX(target_time, ALLOWED_DELAY),
                            "out of time window");
    test_assert(m == 1, "event flag error");
 800441c:	1e60      	subs	r0, r4, #1
 800441e:	4243      	negs	r3, r0
 8004420:	4143      	adcs	r3, r0
 8004422:	4911      	ldr	r1, [pc, #68]	; (8004468 <rt_test_008_003_execute.lto_priv.118+0xf8>)
 8004424:	b2d8      	uxtb	r0, r3
 8004426:	f7ff fd6b 	bl	8003f00 <_test_assert>
 800442a:	2800      	cmp	r0, #0
 800442c:	d1b5      	bne.n	800439a <rt_test_008_003_execute.lto_priv.118+0x2a>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800442e:	f000 fe3f 	bl	80050b0 <chEvtGetAndClearEvents.constprop.20>
 8004432:	1c03      	adds	r3, r0, #0
    test_assert(m == 0, "stuck event");
 8004434:	4258      	negs	r0, r3
 8004436:	4158      	adcs	r0, r3
 8004438:	1c29      	adds	r1, r5, #0
 800443a:	b2c0      	uxtb	r0, r0
 800443c:	f7ff fd60 	bl	8003f00 <_test_assert>
 8004440:	2800      	cmp	r0, #0
 8004442:	d1aa      	bne.n	800439a <rt_test_008_003_execute.lto_priv.118+0x2a>
    test_wait_threads();
 8004444:	f7ff fa5c 	bl	8003900 <test_wait_threads>
 8004448:	e7a7      	b.n	800439a <rt_test_008_003_execute.lto_priv.118+0x2a>
 800444a:	46c0      	nop			; (mov r8, r8)
 800444c:	20000d64 	.word	0x20000d64
 8004450:	08007044 	.word	0x08007044
 8004454:	08005788 	.word	0x08005788
 8004458:	20000e84 	.word	0x20000e84
 800445c:	200006e8 	.word	0x200006e8
 8004460:	080045c1 	.word	0x080045c1
 8004464:	20000d68 	.word	0x20000d68
 8004468:	08007030 	.word	0x08007030
 800446c:	46c0      	nop			; (mov r8, r8)
 800446e:	46c0      	nop			; (mov r8, r8)

08004470 <rt_test_008_002_execute.lto_priv.116>:

static void rt_test_008_002_execute(void) {

  /* [8.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
 8004470:	2201      	movs	r2, #1

static void rt_test_008_002_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void rt_test_008_002_execute(void) {
 8004472:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [8.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
 8004474:	4b0d      	ldr	r3, [pc, #52]	; (80044ac <rt_test_008_002_execute.lto_priv.116+0x3c>)
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
 8004476:	2400      	movs	r4, #0
 8004478:	601a      	str	r2, [r3, #0]
 800447a:	2507      	movs	r5, #7
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 800447c:	2601      	movs	r6, #1
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 800447e:	4f0c      	ldr	r7, [pc, #48]	; (80044b0 <rt_test_008_002_execute.lto_priv.116+0x40>)
 8004480:	e002      	b.n	8004488 <rt_test_008_002_execute.lto_priv.116+0x18>
    }
    eid++;
 8004482:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8004484:	2d00      	cmp	r5, #0
 8004486:	d00d      	beq.n	80044a4 <rt_test_008_002_execute.lto_priv.116+0x34>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8004488:	1c2b      	adds	r3, r5, #0
 800448a:	40e3      	lsrs	r3, r4
 800448c:	421e      	tst	r6, r3
 800448e:	d0f8      	beq.n	8004482 <rt_test_008_002_execute.lto_priv.116+0x12>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8004490:	1c33      	adds	r3, r6, #0
 8004492:	40a3      	lsls	r3, r4
 8004494:	439d      	bics	r5, r3
 8004496:	00a3      	lsls	r3, r4, #2
      handlers[eid](eid);
 8004498:	1c20      	adds	r0, r4, #0
 800449a:	59db      	ldr	r3, [r3, r7]
 800449c:	4798      	blx	r3
    }
    eid++;
 800449e:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 80044a0:	2d00      	cmp	r5, #0
 80044a2:	d1f1      	bne.n	8004488 <rt_test_008_002_execute.lto_priv.116+0x18>
  {
    chEvtDispatch(evhndl, 7);
    test_assert_sequence("ABC", "invalid sequence");
 80044a4:	4803      	ldr	r0, [pc, #12]	; (80044b4 <rt_test_008_002_execute.lto_priv.116+0x44>)
 80044a6:	f000 ff43 	bl	8005330 <_test_assert_sequence.constprop.3>
  }
}
 80044aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80044ac:	20000d64 	.word	0x20000d64
 80044b0:	080070a8 	.word	0x080070a8
 80044b4:	08007058 	.word	0x08007058
 80044b8:	46c0      	nop			; (mov r8, r8)
 80044ba:	46c0      	nop			; (mov r8, r8)
 80044bc:	46c0      	nop			; (mov r8, r8)
 80044be:	46c0      	nop			; (mov r8, r8)

080044c0 <rt_test_008_001_execute.lto_priv.114>:
    chEvtObjectInit(&es1);
  }

  /* [8.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 80044c0:	2102      	movs	r1, #2
 * - [8.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void rt_test_008_001_execute(void) {
 80044c2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80044c4:	4c28      	ldr	r4, [pc, #160]	; (8004568 <rt_test_008_001_execute.lto_priv.114+0xa8>)
    chEvtObjectInit(&es1);
  }

  /* [8.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 80044c6:	4e29      	ldr	r6, [pc, #164]	; (800456c <rt_test_008_001_execute.lto_priv.114+0xac>)
 * - [8.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void rt_test_008_001_execute(void) {
 80044c8:	b08b      	sub	sp, #44	; 0x2c
 80044ca:	6024      	str	r4, [r4, #0]
    chEvtObjectInit(&es1);
  }

  /* [8.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 80044cc:	6031      	str	r1, [r6, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80044ce:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 80044d0:	6823      	ldr	r3, [r4, #0]
  esp->next     = elp;
  elp->listener = currp;
 80044d2:	4827      	ldr	r0, [pc, #156]	; (8004570 <rt_test_008_001_execute.lto_priv.114+0xb0>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 80044d4:	9300      	str	r3, [sp, #0]
  esp->next     = elp;
 80044d6:	466b      	mov	r3, sp
 80044d8:	6023      	str	r3, [r4, #0]
  elp->listener = currp;
 80044da:	6983      	ldr	r3, [r0, #24]
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 80044dc:	2200      	movs	r2, #0
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 80044de:	9301      	str	r3, [sp, #4]
  elp->events   = events;
 80044e0:	2301      	movs	r3, #1
 80044e2:	9302      	str	r3, [sp, #8]
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 80044e4:	3b02      	subs	r3, #2
  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 80044e6:	9203      	str	r2, [sp, #12]
  elp->wflags   = wflags;
 80044e8:	9304      	str	r3, [sp, #16]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80044ea:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80044ec:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 80044ee:	6827      	ldr	r7, [r4, #0]
  esp->next     = elp;
  elp->listener = currp;
 80044f0:	6980      	ldr	r0, [r0, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 80044f2:	ad05      	add	r5, sp, #20
 80044f4:	9705      	str	r7, [sp, #20]
  esp->next     = elp;
 80044f6:	6025      	str	r5, [r4, #0]
  elp->listener = currp;
 80044f8:	6068      	str	r0, [r5, #4]
  elp->events   = events;
 80044fa:	60a9      	str	r1, [r5, #8]
  elp->flags    = (eventflags_t)0;
 80044fc:	60ea      	str	r2, [r5, #12]
  elp->wflags   = wflags;
 80044fe:	612b      	str	r3, [r5, #16]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004500:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004502:	b672      	cpsid	i
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->next);
 8004504:	6823      	ldr	r3, [r4, #0]
  {
    chEvtRegisterMask(&es1, &el1, 1);
    chEvtRegisterMask(&es1, &el2, 2);
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8004506:	4f1b      	ldr	r7, [pc, #108]	; (8004574 <rt_test_008_001_execute.lto_priv.114+0xb4>)
 8004508:	1b18      	subs	r0, r3, r4
 800450a:	1e43      	subs	r3, r0, #1
 800450c:	4198      	sbcs	r0, r3
 800450e:	1c39      	adds	r1, r7, #0
 8004510:	b2c0      	uxtb	r0, r0
 8004512:	f7ff fcf5 	bl	8003f00 <_test_assert>
 8004516:	2800      	cmp	r0, #0
 8004518:	d002      	beq.n	8004520 <rt_test_008_001_execute.lto_priv.114+0x60>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800451a:	b662      	cpsie	i
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el2);
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
  }
}
 800451c:	b00b      	add	sp, #44	; 0x2c
 800451e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004520:	b662      	cpsie	i
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [8.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 8004522:	2303      	movs	r3, #3
  {
    chEvtUnregister(&es1, &el1);
 8004524:	1c20      	adds	r0, r4, #0
 8004526:	4669      	mov	r1, sp
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [8.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 8004528:	6033      	str	r3, [r6, #0]
  {
    chEvtUnregister(&es1, &el1);
 800452a:	f7fb ff61 	bl	80003f0 <chEvtUnregister>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800452e:	b672      	cpsid	i
 8004530:	6823      	ldr	r3, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8004532:	1c39      	adds	r1, r7, #0
 8004534:	1b18      	subs	r0, r3, r4
 8004536:	1e43      	subs	r3, r0, #1
 8004538:	4198      	sbcs	r0, r3
 800453a:	b2c0      	uxtb	r0, r0
 800453c:	f7ff fce0 	bl	8003f00 <_test_assert>
 8004540:	2800      	cmp	r0, #0
 8004542:	d1ea      	bne.n	800451a <rt_test_008_001_execute.lto_priv.114+0x5a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004544:	b662      	cpsie	i
  }

  /* [8.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 8004546:	2304      	movs	r3, #4
  {
    chEvtUnregister(&es1, &el2);
 8004548:	1c20      	adds	r0, r4, #0
 800454a:	1c29      	adds	r1, r5, #0
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [8.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 800454c:	6033      	str	r3, [r6, #0]
  {
    chEvtUnregister(&es1, &el2);
 800454e:	f7fb ff4f 	bl	80003f0 <chEvtUnregister>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004552:	b672      	cpsid	i
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 8004554:	6823      	ldr	r3, [r4, #0]
 8004556:	4908      	ldr	r1, [pc, #32]	; (8004578 <rt_test_008_001_execute.lto_priv.114+0xb8>)
 8004558:	1b18      	subs	r0, r3, r4
 800455a:	4243      	negs	r3, r0
 800455c:	4143      	adcs	r3, r0
 800455e:	b2d8      	uxtb	r0, r3
 8004560:	f7ff fcce 	bl	8003f00 <_test_assert>
 8004564:	e7d9      	b.n	800451a <rt_test_008_001_execute.lto_priv.114+0x5a>
 8004566:	46c0      	nop			; (mov r8, r8)
 8004568:	20000404 	.word	0x20000404
 800456c:	20000d64 	.word	0x20000d64
 8004570:	20000e84 	.word	0x20000e84
 8004574:	0800705c 	.word	0x0800705c
 8004578:	08005794 	.word	0x08005794
 800457c:	46c0      	nop			; (mov r8, r8)
 800457e:	46c0      	nop			; (mov r8, r8)

08004580 <evt_thread7.lto_priv.143>:

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
}

static THD_FUNCTION(evt_thread7, p) {
 8004580:	b508      	push	{r3, lr}
 8004582:	b672      	cpsid	i
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 8004584:	4809      	ldr	r0, [pc, #36]	; (80045ac <evt_thread7.lto_priv.143+0x2c>)
 8004586:	2100      	movs	r1, #0
 8004588:	f7fb ff0a 	bl	80003a0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 800458c:	f7fb ffc0 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004590:	b662      	cpsie	i

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 8004592:	20fa      	movs	r0, #250	; 0xfa
 8004594:	0040      	lsls	r0, r0, #1
 8004596:	f7fc fd0b 	bl	8000fb0 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800459a:	b672      	cpsid	i
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 800459c:	4804      	ldr	r0, [pc, #16]	; (80045b0 <evt_thread7.lto_priv.143+0x30>)
 800459e:	2100      	movs	r1, #0
 80045a0:	f7fb fefe 	bl	80003a0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80045a4:	f7fb ffb4 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80045a8:	b662      	cpsie	i
  chEvtBroadcast(&es2);
}
 80045aa:	bd08      	pop	{r3, pc}
 80045ac:	20000404 	.word	0x20000404
 80045b0:	20000400 	.word	0x20000400
 80045b4:	46c0      	nop			; (mov r8, r8)
 80045b6:	46c0      	nop			; (mov r8, r8)
 80045b8:	46c0      	nop			; (mov r8, r8)
 80045ba:	46c0      	nop			; (mov r8, r8)
 80045bc:	46c0      	nop			; (mov r8, r8)
 80045be:	46c0      	nop			; (mov r8, r8)

080045c0 <evt_thread3.lto_priv.144>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static THD_FUNCTION(evt_thread3, p) {
 80045c0:	b510      	push	{r4, lr}
 80045c2:	1c04      	adds	r4, r0, #0

  chThdSleepMilliseconds(50);
 80045c4:	20fa      	movs	r0, #250	; 0xfa
 80045c6:	0040      	lsls	r0, r0, #1
 80045c8:	f7fc fcf2 	bl	8000fb0 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80045cc:	b672      	cpsid	i
void chEvtSignal(thread_t *tp, eventmask_t events) {

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 80045ce:	2101      	movs	r1, #1
 80045d0:	1c20      	adds	r0, r4, #0
 80045d2:	f7ff fdcd 	bl	8004170 <chEvtSignalI>
  chSchRescheduleS();
 80045d6:	f7fb ff9b 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80045da:	b662      	cpsie	i
  chEvtSignal((thread_t *)p, 1);
}
 80045dc:	bd10      	pop	{r4, pc}
 80045de:	46c0      	nop			; (mov r8, r8)

080045e0 <h3>:
static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 80045e0:	b508      	push	{r3, lr}
 80045e2:	2043      	movs	r0, #67	; 0x43
 80045e4:	f7ff f9bc 	bl	8003960 <test_emit_token>
 80045e8:	bd08      	pop	{r3, pc}
 80045ea:	46c0      	nop			; (mov r8, r8)
 80045ec:	46c0      	nop			; (mov r8, r8)
 80045ee:	46c0      	nop			; (mov r8, r8)

080045f0 <h2>:

static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 80045f0:	b508      	push	{r3, lr}
 80045f2:	2042      	movs	r0, #66	; 0x42
 80045f4:	f7ff f9b4 	bl	8003960 <test_emit_token>
 80045f8:	bd08      	pop	{r3, pc}
 80045fa:	46c0      	nop			; (mov r8, r8)
 80045fc:	46c0      	nop			; (mov r8, r8)
 80045fe:	46c0      	nop			; (mov r8, r8)

08004600 <h1>:
 ****************************************************************************/

static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8004600:	b508      	push	{r3, lr}
 8004602:	2041      	movs	r0, #65	; 0x41
 8004604:	f7ff f9ac 	bl	8003960 <test_emit_token>
 8004608:	bd08      	pop	{r3, pc}
 800460a:	46c0      	nop			; (mov r8, r8)
 800460c:	46c0      	nop			; (mov r8, r8)
 800460e:	46c0      	nop			; (mov r8, r8)

08004610 <msg_thread1>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 8004610:	b510      	push	{r4, lr}
 8004612:	1c04      	adds	r4, r0, #0

  chMsgSend(p, 'A');
 8004614:	2141      	movs	r1, #65	; 0x41
 8004616:	f7ff fd8b 	bl	8004130 <chMsgSend>
  chMsgSend(p, 'B');
 800461a:	1c20      	adds	r0, r4, #0
 800461c:	2142      	movs	r1, #66	; 0x42
 800461e:	f7ff fd87 	bl	8004130 <chMsgSend>
  chMsgSend(p, 'C');
 8004622:	1c20      	adds	r0, r4, #0
 8004624:	2143      	movs	r1, #67	; 0x43
 8004626:	f7ff fd83 	bl	8004130 <chMsgSend>
  chMsgSend(p, 'D');
 800462a:	1c20      	adds	r0, r4, #0
 800462c:	2144      	movs	r1, #68	; 0x44
 800462e:	f7ff fd7f 	bl	8004130 <chMsgSend>
}
 8004632:	bd10      	pop	{r4, pc}
 8004634:	46c0      	nop			; (mov r8, r8)
 8004636:	46c0      	nop			; (mov r8, r8)
 8004638:	46c0      	nop			; (mov r8, r8)
 800463a:	46c0      	nop			; (mov r8, r8)
 800463c:	46c0      	nop			; (mov r8, r8)
 800463e:	46c0      	nop			; (mov r8, r8)

08004640 <rt_test_007_001_execute.lto_priv.113>:
 * - [7.1.1] Starting the messenger thread.
 * - [7.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void rt_test_007_001_execute(void) {
 8004640:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp;
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8004642:	2301      	movs	r3, #1
 8004644:	4c11      	ldr	r4, [pc, #68]	; (800468c <rt_test_007_001_execute.lto_priv.113+0x4c>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004646:	4812      	ldr	r0, [pc, #72]	; (8004690 <rt_test_007_001_execute.lto_priv.113+0x50>)
static void rt_test_007_001_execute(void) {
  thread_t *tp;
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8004648:	6023      	str	r3, [r4, #0]
 800464a:	4b12      	ldr	r3, [pc, #72]	; (8004694 <rt_test_007_001_execute.lto_priv.113+0x54>)
                                   msg_thread1, chThdGetSelfX());
  }

  /* [7.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 800464c:	2504      	movs	r5, #4
 800464e:	699b      	ldr	r3, [r3, #24]
  msg_t msg;

  /* [7.1.1] Starting the messenger thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004650:	689a      	ldr	r2, [r3, #8]
 8004652:	1c51      	adds	r1, r2, #1
 8004654:	4a10      	ldr	r2, [pc, #64]	; (8004698 <rt_test_007_001_execute.lto_priv.113+0x58>)
 8004656:	f000 fc53 	bl	8004f00 <chThdCreateStatic.constprop.40>
 800465a:	4b10      	ldr	r3, [pc, #64]	; (800469c <rt_test_007_001_execute.lto_priv.113+0x5c>)
 800465c:	6018      	str	r0, [r3, #0]
                                   msg_thread1, chThdGetSelfX());
  }

  /* [7.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 800465e:	2302      	movs	r3, #2
 8004660:	6023      	str	r3, [r4, #0]
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
 8004662:	f7ff fd45 	bl	80040f0 <chMsgWait>
 8004666:	6a44      	ldr	r4, [r0, #36]	; 0x24
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004668:	b672      	cpsid	i
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 800466a:	1c21      	adds	r1, r4, #0
 800466c:	f7fb ff90 	bl	8000590 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004670:	b662      	cpsie	i
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
 8004672:	b2e0      	uxtb	r0, r4
 8004674:	3d01      	subs	r5, #1
 8004676:	f7ff f973 	bl	8003960 <test_emit_token>
     order.*/
  test_set_step(2);
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
 800467a:	2d00      	cmp	r5, #0
 800467c:	d1f1      	bne.n	8004662 <rt_test_007_001_execute.lto_priv.113+0x22>
      tp = chMsgWait();
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
    }
    test_wait_threads();
 800467e:	f7ff f93f 	bl	8003900 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 8004682:	4807      	ldr	r0, [pc, #28]	; (80046a0 <rt_test_007_001_execute.lto_priv.113+0x60>)
 8004684:	f000 fe54 	bl	8005330 <_test_assert_sequence.constprop.3>
  }
}
 8004688:	bd38      	pop	{r3, r4, r5, pc}
 800468a:	46c0      	nop			; (mov r8, r8)
 800468c:	20000d64 	.word	0x20000d64
 8004690:	200006e8 	.word	0x200006e8
 8004694:	20000e84 	.word	0x20000e84
 8004698:	08004611 	.word	0x08004611
 800469c:	20000d68 	.word	0x20000d68
 80046a0:	080056f4 	.word	0x080056f4
 80046a4:	46c0      	nop			; (mov r8, r8)
 80046a6:	46c0      	nop			; (mov r8, r8)
 80046a8:	46c0      	nop			; (mov r8, r8)
 80046aa:	46c0      	nop			; (mov r8, r8)
 80046ac:	46c0      	nop			; (mov r8, r8)
 80046ae:	46c0      	nop			; (mov r8, r8)

080046b0 <rt_test_006_009_execute.lto_priv.112>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void rt_test_006_009_execute(void) {
 80046b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80046b2:	4b1a      	ldr	r3, [pc, #104]	; (800471c <rt_test_006_009_execute.lto_priv.112+0x6c>)
    prio = chThdGetPriorityX();
  }

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 80046b4:	4c1a      	ldr	r4, [pc, #104]	; (8004720 <rt_test_006_009_execute.lto_priv.112+0x70>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80046b6:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 80046b8:	4e1a      	ldr	r6, [pc, #104]	; (8004724 <rt_test_006_009_execute.lto_priv.112+0x74>)
 80046ba:	689d      	ldr	r5, [r3, #8]
    prio = chThdGetPriorityX();
  }

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 80046bc:	2302      	movs	r3, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 80046be:	1c69      	adds	r1, r5, #1
    prio = chThdGetPriorityX();
  }

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 80046c0:	6023      	str	r3, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 80046c2:	1c30      	adds	r0, r6, #0
 80046c4:	4a18      	ldr	r2, [pc, #96]	; (8004728 <rt_test_006_009_execute.lto_priv.112+0x78>)
 80046c6:	4b19      	ldr	r3, [pc, #100]	; (800472c <rt_test_006_009_execute.lto_priv.112+0x7c>)
 80046c8:	f000 fc1a 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80046cc:	4f18      	ldr	r7, [pc, #96]	; (8004730 <rt_test_006_009_execute.lto_priv.112+0x80>)
  }

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 80046ce:	2303      	movs	r3, #3

  /* [6.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 80046d0:	6038      	str	r0, [r7, #0]

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 80046d2:	1c30      	adds	r0, r6, #0
 80046d4:	3049      	adds	r0, #73	; 0x49
 80046d6:	1ca9      	adds	r1, r5, #2
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
  }

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 80046d8:	6023      	str	r3, [r4, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 80046da:	4a16      	ldr	r2, [pc, #88]	; (8004734 <rt_test_006_009_execute.lto_priv.112+0x84>)
 80046dc:	4b16      	ldr	r3, [pc, #88]	; (8004738 <rt_test_006_009_execute.lto_priv.112+0x88>)
 80046de:	30ff      	adds	r0, #255	; 0xff
 80046e0:	f000 fc0e 	bl	8004f00 <chThdCreateStatic.constprop.40>
  }

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 80046e4:	2304      	movs	r3, #4
 80046e6:	6023      	str	r3, [r4, #0]
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 80046e8:	23a4      	movs	r3, #164	; 0xa4
 80046ea:	009b      	lsls	r3, r3, #2
 80046ec:	1ce9      	adds	r1, r5, #3
 80046ee:	4a13      	ldr	r2, [pc, #76]	; (800473c <rt_test_006_009_execute.lto_priv.112+0x8c>)

  /* [6.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 80046f0:	6078      	str	r0, [r7, #4]

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 80046f2:	18f0      	adds	r0, r6, r3
 80046f4:	4b12      	ldr	r3, [pc, #72]	; (8004740 <rt_test_006_009_execute.lto_priv.112+0x90>)
 80046f6:	f000 fc03 	bl	8004f00 <chThdCreateStatic.constprop.40>
  }

  /* [6.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 80046fa:	2305      	movs	r3, #5

  /* [6.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 80046fc:	60b8      	str	r0, [r7, #8]
  }

  /* [6.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 80046fe:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8004700:	f000 fcb6 	bl	8005070 <chCondSignal.constprop.29>
  }

  /* [6.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
 8004704:	2306      	movs	r3, #6
 8004706:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8004708:	f000 fcb2 	bl	8005070 <chCondSignal.constprop.29>
  }

  /* [6.9.7] Checking the order of operations.*/
  test_set_step(7);
 800470c:	2307      	movs	r3, #7
 800470e:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 8004710:	f7ff f8f6 	bl	8003900 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
 8004714:	480b      	ldr	r0, [pc, #44]	; (8004744 <rt_test_006_009_execute.lto_priv.112+0x94>)
 8004716:	f000 fe0b 	bl	8005330 <_test_assert_sequence.constprop.3>
  }
}
 800471a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800471c:	20000e84 	.word	0x20000e84
 8004720:	20000d64 	.word	0x20000d64
 8004724:	200006e8 	.word	0x200006e8
 8004728:	08004d61 	.word	0x08004d61
 800472c:	0800557c 	.word	0x0800557c
 8004730:	20000d68 	.word	0x20000d68
 8004734:	08004df1 	.word	0x08004df1
 8004738:	08005584 	.word	0x08005584
 800473c:	08004751 	.word	0x08004751
 8004740:	08005580 	.word	0x08005580
 8004744:	08007058 	.word	0x08007058
 8004748:	46c0      	nop			; (mov r8, r8)
 800474a:	46c0      	nop			; (mov r8, r8)
 800474c:	46c0      	nop			; (mov r8, r8)
 800474e:	46c0      	nop			; (mov r8, r8)

08004750 <thread9>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread9, p) {
 8004750:	b538      	push	{r3, r4, r5, lr}
 8004752:	1c05      	adds	r5, r0, #0

  chMtxLock(&m2);
 8004754:	4c05      	ldr	r4, [pc, #20]	; (800476c <thread9+0x1c>)
 8004756:	1c20      	adds	r0, r4, #0
 8004758:	f7fc f872 	bl	8000840 <chMtxLock>
  test_emit_token(*(char *)p);
 800475c:	7828      	ldrb	r0, [r5, #0]
 800475e:	f7ff f8ff 	bl	8003960 <test_emit_token>
  chMtxUnlock(&m2);
 8004762:	1c20      	adds	r0, r4, #0
 8004764:	f7fb ffd4 	bl	8000710 <chMtxUnlock>
}
 8004768:	bd38      	pop	{r3, r4, r5, pc}
 800476a:	46c0      	nop			; (mov r8, r8)
 800476c:	20000408 	.word	0x20000408

08004770 <rt_test_006_004_execute.lto_priv.104>:

static void rt_test_006_004_teardown(void) {
  test_wait_threads();
}

static void rt_test_006_004_execute(void) {
 8004770:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004772:	4656      	mov	r6, sl
 8004774:	464d      	mov	r5, r9
 8004776:	4644      	mov	r4, r8
 8004778:	465f      	mov	r7, fp
 800477a:	b4f0      	push	{r4, r5, r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800477c:	4d45      	ldr	r5, [pc, #276]	; (8004894 <rt_test_006_004_execute.lto_priv.104+0x124>)
    pa = p + 1;
    pb = p + 2;
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 800477e:	4e46      	ldr	r6, [pc, #280]	; (8004898 <rt_test_006_004_execute.lto_priv.104+0x128>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004780:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8004782:	4a46      	ldr	r2, [pc, #280]	; (800489c <rt_test_006_004_execute.lto_priv.104+0x12c>)
 8004784:	689c      	ldr	r4, [r3, #8]
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
  {
    p = chThdGetPriorityX();
    pa = p + 1;
    pb = p + 2;
 8004786:	1ca3      	adds	r3, r4, #2
 8004788:	4698      	mov	r8, r3
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 800478a:	2302      	movs	r3, #2
 800478c:	6033      	str	r3, [r6, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800478e:	4b44      	ldr	r3, [pc, #272]	; (80048a0 <rt_test_006_004_execute.lto_priv.104+0x130>)
  /* [6.4.1] Getting current thread priority P(0) and assigning to the
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
  {
    p = chThdGetPriorityX();
    pa = p + 1;
 8004790:	1c67      	adds	r7, r4, #1
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8004792:	4699      	mov	r9, r3
 8004794:	1c18      	adds	r0, r3, #0
 8004796:	1c39      	adds	r1, r7, #0
 8004798:	4b42      	ldr	r3, [pc, #264]	; (80048a4 <rt_test_006_004_execute.lto_priv.104+0x134>)
 800479a:	f000 fbb1 	bl	8004f00 <chThdCreateStatic.constprop.40>
 800479e:	4b42      	ldr	r3, [pc, #264]	; (80048a8 <rt_test_006_004_execute.lto_priv.104+0x138>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 80047a0:	4641      	mov	r1, r8
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 80047a2:	6018      	str	r0, [r3, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 80047a4:	4648      	mov	r0, r9
  }

  /* [6.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 80047a6:	469a      	mov	sl, r3
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 80047a8:	3049      	adds	r0, #73	; 0x49
 80047aa:	4a40      	ldr	r2, [pc, #256]	; (80048ac <rt_test_006_004_execute.lto_priv.104+0x13c>)
 80047ac:	4b40      	ldr	r3, [pc, #256]	; (80048b0 <rt_test_006_004_execute.lto_priv.104+0x140>)
 80047ae:	30ff      	adds	r0, #255	; 0xff
 80047b0:	f000 fba6 	bl	8004f00 <chThdCreateStatic.constprop.40>
 80047b4:	4653      	mov	r3, sl
 80047b6:	6058      	str	r0, [r3, #4]
  }

  /* [6.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
 80047b8:	2303      	movs	r3, #3
 80047ba:	6033      	str	r3, [r6, #0]
  {
    chMtxLock(&m1);
 80047bc:	4b3d      	ldr	r3, [pc, #244]	; (80048b4 <rt_test_006_004_execute.lto_priv.104+0x144>)
 80047be:	1c18      	adds	r0, r3, #0
 80047c0:	4699      	mov	r9, r3
 80047c2:	f7fc f83d 	bl	8000840 <chMtxLock>
 80047c6:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 80047c8:	6898      	ldr	r0, [r3, #8]
 80047ca:	1a20      	subs	r0, r4, r0
 80047cc:	4243      	negs	r3, r0
 80047ce:	4158      	adcs	r0, r3
 80047d0:	4b39      	ldr	r3, [pc, #228]	; (80048b8 <rt_test_006_004_execute.lto_priv.104+0x148>)
 80047d2:	b2c0      	uxtb	r0, r0
 80047d4:	1c19      	adds	r1, r3, #0
 80047d6:	469a      	mov	sl, r3
 80047d8:	f7ff fb92 	bl	8003f00 <_test_assert>
 80047dc:	2800      	cmp	r0, #0
 80047de:	d005      	beq.n	80047ec <rt_test_006_004_execute.lto_priv.104+0x7c>
  test_set_step(8);
  {
    chMtxUnlock(&m1);
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
  }
}
 80047e0:	bc3c      	pop	{r2, r3, r4, r5}
 80047e2:	4690      	mov	r8, r2
 80047e4:	4699      	mov	r9, r3
 80047e6:	46a2      	mov	sl, r4
 80047e8:	46ab      	mov	fp, r5
 80047ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  /* [6.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
  {
    chThdSleepMilliseconds(100);
 80047ec:	20fa      	movs	r0, #250	; 0xfa
  }

  /* [6.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 80047ee:	2304      	movs	r3, #4
  {
    chThdSleepMilliseconds(100);
 80047f0:	0080      	lsls	r0, r0, #2
  }

  /* [6.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 80047f2:	6033      	str	r3, [r6, #0]
  {
    chThdSleepMilliseconds(100);
 80047f4:	f7fc fbdc 	bl	8000fb0 <chThdSleep>
 80047f8:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 80047fa:	4651      	mov	r1, sl
 80047fc:	6898      	ldr	r0, [r3, #8]
 80047fe:	1a38      	subs	r0, r7, r0
 8004800:	4243      	negs	r3, r0
 8004802:	4158      	adcs	r0, r3
 8004804:	b2c0      	uxtb	r0, r0
 8004806:	f7ff fb7b 	bl	8003f00 <_test_assert>
 800480a:	2800      	cmp	r0, #0
 800480c:	d1e8      	bne.n	80047e0 <rt_test_006_004_execute.lto_priv.104+0x70>
  }

  /* [6.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
 800480e:	2305      	movs	r3, #5
 8004810:	6033      	str	r3, [r6, #0]
  {
    chMtxLock(&m2);
 8004812:	4b2a      	ldr	r3, [pc, #168]	; (80048bc <rt_test_006_004_execute.lto_priv.104+0x14c>)
 8004814:	1c18      	adds	r0, r3, #0
 8004816:	469b      	mov	fp, r3
 8004818:	f7fc f812 	bl	8000840 <chMtxLock>
 800481c:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 800481e:	4651      	mov	r1, sl
 8004820:	6898      	ldr	r0, [r3, #8]
 8004822:	1a38      	subs	r0, r7, r0
 8004824:	4243      	negs	r3, r0
 8004826:	4158      	adcs	r0, r3
 8004828:	b2c0      	uxtb	r0, r0
 800482a:	f7ff fb69 	bl	8003f00 <_test_assert>
 800482e:	2800      	cmp	r0, #0
 8004830:	d1d6      	bne.n	80047e0 <rt_test_006_004_execute.lto_priv.104+0x70>
  /* [6.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
  {
    chThdSleepMilliseconds(100);
 8004832:	20fa      	movs	r0, #250	; 0xfa
  }

  /* [6.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 8004834:	2306      	movs	r3, #6
  {
    chThdSleepMilliseconds(100);
 8004836:	0080      	lsls	r0, r0, #2
  }

  /* [6.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 8004838:	6033      	str	r3, [r6, #0]
  {
    chThdSleepMilliseconds(100);
 800483a:	f7fc fbb9 	bl	8000fb0 <chThdSleep>
 800483e:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 8004840:	4651      	mov	r1, sl
 8004842:	6898      	ldr	r0, [r3, #8]
 8004844:	4643      	mov	r3, r8
 8004846:	1a18      	subs	r0, r3, r0
 8004848:	4243      	negs	r3, r0
 800484a:	4158      	adcs	r0, r3
 800484c:	b2c0      	uxtb	r0, r0
 800484e:	f7ff fb57 	bl	8003f00 <_test_assert>
 8004852:	2800      	cmp	r0, #0
 8004854:	d1c4      	bne.n	80047e0 <rt_test_006_004_execute.lto_priv.104+0x70>
  }

  /* [6.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 8004856:	2307      	movs	r3, #7
  {
    chMtxUnlock(&m2);
 8004858:	4658      	mov	r0, fp
    chThdSleepMilliseconds(100);
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
  }

  /* [6.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 800485a:	6033      	str	r3, [r6, #0]
  {
    chMtxUnlock(&m2);
 800485c:	f7fb ff58 	bl	8000710 <chMtxUnlock>
 8004860:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8004862:	4651      	mov	r1, sl
 8004864:	6898      	ldr	r0, [r3, #8]
 8004866:	1a38      	subs	r0, r7, r0
 8004868:	4247      	negs	r7, r0
 800486a:	4178      	adcs	r0, r7
 800486c:	b2c0      	uxtb	r0, r0
 800486e:	f7ff fb47 	bl	8003f00 <_test_assert>
 8004872:	2800      	cmp	r0, #0
 8004874:	d1b4      	bne.n	80047e0 <rt_test_006_004_execute.lto_priv.104+0x70>
  }

  /* [6.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 8004876:	2308      	movs	r3, #8
  {
    chMtxUnlock(&m1);
 8004878:	4648      	mov	r0, r9
    chMtxUnlock(&m2);
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  }

  /* [6.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 800487a:	6033      	str	r3, [r6, #0]
  {
    chMtxUnlock(&m1);
 800487c:	f7fb ff48 	bl	8000710 <chMtxUnlock>
 8004880:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8004882:	4651      	mov	r1, sl
 8004884:	6898      	ldr	r0, [r3, #8]
 8004886:	1a20      	subs	r0, r4, r0
 8004888:	4244      	negs	r4, r0
 800488a:	4160      	adcs	r0, r4
 800488c:	b2c0      	uxtb	r0, r0
 800488e:	f7ff fb37 	bl	8003f00 <_test_assert>
 8004892:	e7a5      	b.n	80047e0 <rt_test_006_004_execute.lto_priv.104+0x70>
 8004894:	20000e84 	.word	0x20000e84
 8004898:	20000d64 	.word	0x20000d64
 800489c:	080048c1 	.word	0x080048c1
 80048a0:	200006e8 	.word	0x200006e8
 80048a4:	0800557c 	.word	0x0800557c
 80048a8:	20000d68 	.word	0x20000d68
 80048ac:	08004d31 	.word	0x08004d31
 80048b0:	08005580 	.word	0x08005580
 80048b4:	20000418 	.word	0x20000418
 80048b8:	08007068 	.word	0x08007068
 80048bc:	20000408 	.word	0x20000408

080048c0 <thread4A>:
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 80048c0:	20fa      	movs	r0, #250	; 0xfa
  chMtxUnlock(&m2);
  test_emit_token('A');
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {
 80048c2:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 80048c4:	0040      	lsls	r0, r0, #1
 80048c6:	f7fc fb73 	bl	8000fb0 <chThdSleep>
  chMtxLock(&m1);
 80048ca:	4c04      	ldr	r4, [pc, #16]	; (80048dc <thread4A+0x1c>)
 80048cc:	1c20      	adds	r0, r4, #0
 80048ce:	f7fb ffb7 	bl	8000840 <chMtxLock>
  chMtxUnlock(&m1);
 80048d2:	1c20      	adds	r0, r4, #0
 80048d4:	f7fb ff1c 	bl	8000710 <chMtxUnlock>
}
 80048d8:	bd10      	pop	{r4, pc}
 80048da:	46c0      	nop			; (mov r8, r8)
 80048dc:	20000418 	.word	0x20000418

080048e0 <rt_test_006_001_execute.lto_priv.101>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80048e0:	4b2f      	ldr	r3, [pc, #188]	; (80049a0 <rt_test_006_001_execute.lto_priv.101+0xc0>)

static void rt_test_006_001_setup(void) {
  chMtxObjectInit(&m1);
}

static void rt_test_006_001_execute(void) {
 80048e2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80048e4:	464e      	mov	r6, r9
 80048e6:	4699      	mov	r9, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80048e8:	699b      	ldr	r3, [r3, #24]
 80048ea:	4645      	mov	r5, r8
 80048ec:	689c      	ldr	r4, [r3, #8]
  {
    prio = chThdGetPriorityX();
  }

  /* [6.1.2] Locking the mutex.*/
  test_set_step(2);
 80048ee:	4b2d      	ldr	r3, [pc, #180]	; (80049a4 <rt_test_006_001_execute.lto_priv.101+0xc4>)

static void rt_test_006_001_setup(void) {
  chMtxObjectInit(&m1);
}

static void rt_test_006_001_execute(void) {
 80048f0:	4657      	mov	r7, sl
  {
    prio = chThdGetPriorityX();
  }

  /* [6.1.2] Locking the mutex.*/
  test_set_step(2);
 80048f2:	4698      	mov	r8, r3
 80048f4:	2302      	movs	r3, #2
 80048f6:	4642      	mov	r2, r8

static void rt_test_006_001_setup(void) {
  chMtxObjectInit(&m1);
}

static void rt_test_006_001_execute(void) {
 80048f8:	b4e0      	push	{r5, r6, r7}
  {
    prio = chThdGetPriorityX();
  }

  /* [6.1.2] Locking the mutex.*/
  test_set_step(2);
 80048fa:	6013      	str	r3, [r2, #0]
  {
    chMtxLock(&m1);
 80048fc:	4b2a      	ldr	r3, [pc, #168]	; (80049a8 <rt_test_006_001_execute.lto_priv.101+0xc8>)
 80048fe:	1c18      	adds	r0, r3, #0
 8004900:	469a      	mov	sl, r3
 8004902:	f7fb ff9d 	bl	8000840 <chMtxLock>
  }

  /* [6.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
 8004906:	2303      	movs	r3, #3
 8004908:	4642      	mov	r2, r8
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800490a:	4d28      	ldr	r5, [pc, #160]	; (80049ac <rt_test_006_001_execute.lto_priv.101+0xcc>)
 800490c:	4f28      	ldr	r7, [pc, #160]	; (80049b0 <rt_test_006_001_execute.lto_priv.101+0xd0>)
  }

  /* [6.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
 800490e:	6013      	str	r3, [r2, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8004910:	1c61      	adds	r1, r4, #1
 8004912:	1c3a      	adds	r2, r7, #0
 8004914:	4b27      	ldr	r3, [pc, #156]	; (80049b4 <rt_test_006_001_execute.lto_priv.101+0xd4>)
 8004916:	1c28      	adds	r0, r5, #0
 8004918:	f000 faf2 	bl	8004f00 <chThdCreateStatic.constprop.40>
 800491c:	4e26      	ldr	r6, [pc, #152]	; (80049b8 <rt_test_006_001_execute.lto_priv.101+0xd8>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800491e:	1ca1      	adds	r1, r4, #2
  /* [6.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 8004920:	6030      	str	r0, [r6, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8004922:	1c28      	adds	r0, r5, #0
 8004924:	3049      	adds	r0, #73	; 0x49
 8004926:	1c3a      	adds	r2, r7, #0
 8004928:	4b24      	ldr	r3, [pc, #144]	; (80049bc <rt_test_006_001_execute.lto_priv.101+0xdc>)
 800492a:	30ff      	adds	r0, #255	; 0xff
 800492c:	f000 fae8 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8004930:	23a4      	movs	r3, #164	; 0xa4
 8004932:	009b      	lsls	r3, r3, #2
 8004934:	1ce1      	adds	r1, r4, #3
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8004936:	6070      	str	r0, [r6, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8004938:	1c3a      	adds	r2, r7, #0
 800493a:	18e8      	adds	r0, r5, r3
 800493c:	4b20      	ldr	r3, [pc, #128]	; (80049c0 <rt_test_006_001_execute.lto_priv.101+0xe0>)
 800493e:	f000 fadf 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8004942:	23f6      	movs	r3, #246	; 0xf6
 8004944:	009b      	lsls	r3, r3, #2
 8004946:	1d21      	adds	r1, r4, #4
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8004948:	60b0      	str	r0, [r6, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800494a:	1c3a      	adds	r2, r7, #0
 800494c:	18e8      	adds	r0, r5, r3
 800494e:	4b1d      	ldr	r3, [pc, #116]	; (80049c4 <rt_test_006_001_execute.lto_priv.101+0xe4>)
 8004950:	f000 fad6 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8004954:	23a4      	movs	r3, #164	; 0xa4
 8004956:	00db      	lsls	r3, r3, #3
 8004958:	1d61      	adds	r1, r4, #5
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800495a:	60f0      	str	r0, [r6, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800495c:	1c3a      	adds	r2, r7, #0
 800495e:	18e8      	adds	r0, r5, r3
 8004960:	4b19      	ldr	r3, [pc, #100]	; (80049c8 <rt_test_006_001_execute.lto_priv.101+0xe8>)
 8004962:	f000 facd 	bl	8004f00 <chThdCreateStatic.constprop.40>
  }

  /* [6.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 8004966:	2304      	movs	r3, #4
 8004968:	4642      	mov	r2, r8
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800496a:	6130      	str	r0, [r6, #16]

  /* [6.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
  {
    chMtxUnlock(&m1);
 800496c:	4650      	mov	r0, sl
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  }

  /* [6.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 800496e:	6013      	str	r3, [r2, #0]
  {
    chMtxUnlock(&m1);
 8004970:	f7fb fece 	bl	8000710 <chMtxUnlock>
    test_wait_threads();
 8004974:	f7fe ffc4 	bl	8003900 <test_wait_threads>
 8004978:	464b      	mov	r3, r9
 800497a:	699b      	ldr	r3, [r3, #24]
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 800497c:	4913      	ldr	r1, [pc, #76]	; (80049cc <rt_test_006_001_execute.lto_priv.101+0xec>)
 800497e:	6898      	ldr	r0, [r3, #8]
 8004980:	1a20      	subs	r0, r4, r0
 8004982:	4244      	negs	r4, r0
 8004984:	4160      	adcs	r0, r4
 8004986:	b2c0      	uxtb	r0, r0
 8004988:	f7ff faba 	bl	8003f00 <_test_assert>
 800498c:	2800      	cmp	r0, #0
 800498e:	d102      	bne.n	8004996 <rt_test_006_001_execute.lto_priv.101+0xb6>
    test_assert_sequence("ABCDE", "invalid sequence");
 8004990:	480f      	ldr	r0, [pc, #60]	; (80049d0 <rt_test_006_001_execute.lto_priv.101+0xf0>)
 8004992:	f000 fccd 	bl	8005330 <_test_assert_sequence.constprop.3>
  }
}
 8004996:	bc1c      	pop	{r2, r3, r4}
 8004998:	4690      	mov	r8, r2
 800499a:	4699      	mov	r9, r3
 800499c:	46a2      	mov	sl, r4
 800499e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80049a0:	20000e84 	.word	0x20000e84
 80049a4:	20000d64 	.word	0x20000d64
 80049a8:	20000418 	.word	0x20000418
 80049ac:	200006e8 	.word	0x200006e8
 80049b0:	080049e1 	.word	0x080049e1
 80049b4:	08005590 	.word	0x08005590
 80049b8:	20000d68 	.word	0x20000d68
 80049bc:	08005588 	.word	0x08005588
 80049c0:	08005584 	.word	0x08005584
 80049c4:	08005580 	.word	0x08005580
 80049c8:	0800557c 	.word	0x0800557c
 80049cc:	08007068 	.word	0x08007068
 80049d0:	0800558c 	.word	0x0800558c
 80049d4:	46c0      	nop			; (mov r8, r8)
 80049d6:	46c0      	nop			; (mov r8, r8)
 80049d8:	46c0      	nop			; (mov r8, r8)
 80049da:	46c0      	nop			; (mov r8, r8)
 80049dc:	46c0      	nop			; (mov r8, r8)
 80049de:	46c0      	nop			; (mov r8, r8)

080049e0 <thread1>:
  }
  while (chTimeIsInRangeX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 80049e0:	b538      	push	{r3, r4, r5, lr}
 80049e2:	1c05      	adds	r5, r0, #0

  chMtxLock(&m1);
 80049e4:	4c05      	ldr	r4, [pc, #20]	; (80049fc <thread1+0x1c>)
 80049e6:	1c20      	adds	r0, r4, #0
 80049e8:	f7fb ff2a 	bl	8000840 <chMtxLock>
  test_emit_token(*(char *)p);
 80049ec:	7828      	ldrb	r0, [r5, #0]
 80049ee:	f7fe ffb7 	bl	8003960 <test_emit_token>
  chMtxUnlock(&m1);
 80049f2:	1c20      	adds	r0, r4, #0
 80049f4:	f7fb fe8c 	bl	8000710 <chMtxUnlock>
}
 80049f8:	bd38      	pop	{r3, r4, r5, pc}
 80049fa:	46c0      	nop			; (mov r8, r8)
 80049fc:	20000418 	.word	0x20000418

08004a00 <rt_test_006_008_execute.lto_priv.110>:

static void rt_test_006_008_execute(void) {

  /* [6.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8004a00:	4b2b      	ldr	r3, [pc, #172]	; (8004ab0 <rt_test_006_008_execute.lto_priv.110+0xb0>)
static void rt_test_006_008_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void rt_test_006_008_execute(void) {
 8004a02:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004a04:	4647      	mov	r7, r8

  /* [6.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8004a06:	4698      	mov	r8, r3
 8004a08:	2301      	movs	r3, #1
 8004a0a:	4642      	mov	r2, r8
static void rt_test_006_008_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void rt_test_006_008_execute(void) {
 8004a0c:	b480      	push	{r7}

  /* [6.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8004a0e:	6013      	str	r3, [r2, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004a10:	4b28      	ldr	r3, [pc, #160]	; (8004ab4 <rt_test_006_008_execute.lto_priv.110+0xb4>)
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004a12:	4d29      	ldr	r5, [pc, #164]	; (8004ab8 <rt_test_006_008_execute.lto_priv.110+0xb8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004a14:	699b      	ldr	r3, [r3, #24]
 8004a16:	4f29      	ldr	r7, [pc, #164]	; (8004abc <rt_test_006_008_execute.lto_priv.110+0xbc>)
 8004a18:	689c      	ldr	r4, [r3, #8]
 8004a1a:	1c3a      	adds	r2, r7, #0
 8004a1c:	1c61      	adds	r1, r4, #1
 8004a1e:	1c28      	adds	r0, r5, #0
 8004a20:	4b27      	ldr	r3, [pc, #156]	; (8004ac0 <rt_test_006_008_execute.lto_priv.110+0xc0>)
 8004a22:	f000 fa6d 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8004a26:	4e27      	ldr	r6, [pc, #156]	; (8004ac4 <rt_test_006_008_execute.lto_priv.110+0xc4>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004a28:	1ca1      	adds	r1, r4, #2
  /* [6.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004a2a:	6030      	str	r0, [r6, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004a2c:	1c28      	adds	r0, r5, #0
 8004a2e:	3049      	adds	r0, #73	; 0x49
 8004a30:	1c3a      	adds	r2, r7, #0
 8004a32:	4b25      	ldr	r3, [pc, #148]	; (8004ac8 <rt_test_006_008_execute.lto_priv.110+0xc8>)
 8004a34:	30ff      	adds	r0, #255	; 0xff
 8004a36:	f000 fa63 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004a3a:	23a4      	movs	r3, #164	; 0xa4
 8004a3c:	009b      	lsls	r3, r3, #2
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004a3e:	6070      	str	r0, [r6, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004a40:	1ce1      	adds	r1, r4, #3
 8004a42:	18e8      	adds	r0, r5, r3
 8004a44:	1c3a      	adds	r2, r7, #0
 8004a46:	4b21      	ldr	r3, [pc, #132]	; (8004acc <rt_test_006_008_execute.lto_priv.110+0xcc>)
 8004a48:	f000 fa5a 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004a4c:	23f6      	movs	r3, #246	; 0xf6
 8004a4e:	009b      	lsls	r3, r3, #2
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004a50:	60b0      	str	r0, [r6, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004a52:	1d21      	adds	r1, r4, #4
 8004a54:	18e8      	adds	r0, r5, r3
 8004a56:	1c3a      	adds	r2, r7, #0
 8004a58:	4b1d      	ldr	r3, [pc, #116]	; (8004ad0 <rt_test_006_008_execute.lto_priv.110+0xd0>)
 8004a5a:	f000 fa51 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004a5e:	23a4      	movs	r3, #164	; 0xa4
 8004a60:	00db      	lsls	r3, r3, #3
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004a62:	60f0      	str	r0, [r6, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004a64:	1c3a      	adds	r2, r7, #0
 8004a66:	18e8      	adds	r0, r5, r3
 8004a68:	1d61      	adds	r1, r4, #5
 8004a6a:	4b1a      	ldr	r3, [pc, #104]	; (8004ad4 <rt_test_006_008_execute.lto_priv.110+0xd4>)
 8004a6c:	f000 fa48 	bl	8004f00 <chThdCreateStatic.constprop.40>
  }

  /* [6.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
 8004a70:	2302      	movs	r3, #2
 8004a72:	4642      	mov	r2, r8
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004a74:	6130      	str	r0, [r6, #16]
  }

  /* [6.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
 8004a76:	6013      	str	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004a78:	b672      	cpsid	i

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8004a7a:	2502      	movs	r5, #2
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8004a7c:	4c16      	ldr	r4, [pc, #88]	; (8004ad8 <rt_test_006_008_execute.lto_priv.110+0xd8>)
 8004a7e:	426d      	negs	r5, r5
 8004a80:	6820      	ldr	r0, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 8004a82:	42a0      	cmp	r0, r4
 8004a84:	d008      	beq.n	8004a98 <rt_test_006_008_execute.lto_priv.110+0x98>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8004a86:	6803      	ldr	r3, [r0, #0]
 8004a88:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8004a8a:	605c      	str	r4, [r3, #4]
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8004a8c:	f7fb fe00 	bl	8000690 <chSchReadyI>
 8004a90:	6245      	str	r5, [r0, #36]	; 0x24
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8004a92:	6820      	ldr	r0, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 8004a94:	42a0      	cmp	r0, r4
 8004a96:	d1f6      	bne.n	8004a86 <rt_test_006_008_execute.lto_priv.110+0x86>
 */
void chCondBroadcast(condition_variable_t *cp) {

  chSysLock();
  chCondBroadcastI(cp);
  chSchRescheduleS();
 8004a98:	f7fb fd3a 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004a9c:	b662      	cpsie	i
  {
    chCondBroadcast(&c1);
    test_wait_threads();
 8004a9e:	f7fe ff2f 	bl	8003900 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8004aa2:	480e      	ldr	r0, [pc, #56]	; (8004adc <rt_test_006_008_execute.lto_priv.110+0xdc>)
 8004aa4:	f000 fc44 	bl	8005330 <_test_assert_sequence.constprop.3>
  }
}
 8004aa8:	bc04      	pop	{r2}
 8004aaa:	4690      	mov	r8, r2
 8004aac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004aae:	46c0      	nop			; (mov r8, r8)
 8004ab0:	20000d64 	.word	0x20000d64
 8004ab4:	20000e84 	.word	0x20000e84
 8004ab8:	200006e8 	.word	0x200006e8
 8004abc:	08004df1 	.word	0x08004df1
 8004ac0:	08005590 	.word	0x08005590
 8004ac4:	20000d68 	.word	0x20000d68
 8004ac8:	08005588 	.word	0x08005588
 8004acc:	08005584 	.word	0x08005584
 8004ad0:	08005580 	.word	0x08005580
 8004ad4:	0800557c 	.word	0x0800557c
 8004ad8:	20000428 	.word	0x20000428
 8004adc:	0800558c 	.word	0x0800558c

08004ae0 <rt_test_006_007_execute.lto_priv.108>:

static void rt_test_006_007_execute(void) {

  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8004ae0:	4b28      	ldr	r3, [pc, #160]	; (8004b84 <rt_test_006_007_execute.lto_priv.108+0xa4>)
static void rt_test_006_007_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void rt_test_006_007_execute(void) {
 8004ae2:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004ae4:	4647      	mov	r7, r8

  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8004ae6:	4698      	mov	r8, r3
 8004ae8:	2301      	movs	r3, #1
 8004aea:	4642      	mov	r2, r8
static void rt_test_006_007_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void rt_test_006_007_execute(void) {
 8004aec:	b480      	push	{r7}

  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8004aee:	6013      	str	r3, [r2, #0]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004af0:	4b25      	ldr	r3, [pc, #148]	; (8004b88 <rt_test_006_007_execute.lto_priv.108+0xa8>)
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004af2:	4d26      	ldr	r5, [pc, #152]	; (8004b8c <rt_test_006_007_execute.lto_priv.108+0xac>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004af4:	699b      	ldr	r3, [r3, #24]
 8004af6:	4f26      	ldr	r7, [pc, #152]	; (8004b90 <rt_test_006_007_execute.lto_priv.108+0xb0>)
 8004af8:	689c      	ldr	r4, [r3, #8]
 8004afa:	1c3a      	adds	r2, r7, #0
 8004afc:	1c61      	adds	r1, r4, #1
 8004afe:	1c28      	adds	r0, r5, #0
 8004b00:	4b24      	ldr	r3, [pc, #144]	; (8004b94 <rt_test_006_007_execute.lto_priv.108+0xb4>)
 8004b02:	f000 f9fd 	bl	8004f00 <chThdCreateStatic.constprop.40>
 8004b06:	4e24      	ldr	r6, [pc, #144]	; (8004b98 <rt_test_006_007_execute.lto_priv.108+0xb8>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004b08:	1ca1      	adds	r1, r4, #2
  /* [6.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004b0a:	6030      	str	r0, [r6, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004b0c:	1c28      	adds	r0, r5, #0
 8004b0e:	3049      	adds	r0, #73	; 0x49
 8004b10:	1c3a      	adds	r2, r7, #0
 8004b12:	4b22      	ldr	r3, [pc, #136]	; (8004b9c <rt_test_006_007_execute.lto_priv.108+0xbc>)
 8004b14:	30ff      	adds	r0, #255	; 0xff
 8004b16:	f000 f9f3 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004b1a:	23a4      	movs	r3, #164	; 0xa4
 8004b1c:	009b      	lsls	r3, r3, #2
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004b1e:	6070      	str	r0, [r6, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004b20:	1ce1      	adds	r1, r4, #3
 8004b22:	18e8      	adds	r0, r5, r3
 8004b24:	1c3a      	adds	r2, r7, #0
 8004b26:	4b1e      	ldr	r3, [pc, #120]	; (8004ba0 <rt_test_006_007_execute.lto_priv.108+0xc0>)
 8004b28:	f000 f9ea 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004b2c:	23f6      	movs	r3, #246	; 0xf6
 8004b2e:	009b      	lsls	r3, r3, #2
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004b30:	60b0      	str	r0, [r6, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004b32:	1d21      	adds	r1, r4, #4
 8004b34:	18e8      	adds	r0, r5, r3
 8004b36:	1c3a      	adds	r2, r7, #0
 8004b38:	4b1a      	ldr	r3, [pc, #104]	; (8004ba4 <rt_test_006_007_execute.lto_priv.108+0xc4>)
 8004b3a:	f000 f9e1 	bl	8004f00 <chThdCreateStatic.constprop.40>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004b3e:	23a4      	movs	r3, #164	; 0xa4
 8004b40:	00db      	lsls	r3, r3, #3
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004b42:	60f0      	str	r0, [r6, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004b44:	1c3a      	adds	r2, r7, #0
 8004b46:	18e8      	adds	r0, r5, r3
 8004b48:	1d61      	adds	r1, r4, #5
 8004b4a:	4b17      	ldr	r3, [pc, #92]	; (8004ba8 <rt_test_006_007_execute.lto_priv.108+0xc8>)
 8004b4c:	f000 f9d8 	bl	8004f00 <chThdCreateStatic.constprop.40>
  }

  /* [6.7.2] Atomically signaling the condition variable five times
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
 8004b50:	2302      	movs	r3, #2
 8004b52:	4642      	mov	r2, r8
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004b54:	6130      	str	r0, [r6, #16]
  }

  /* [6.7.2] Atomically signaling the condition variable five times
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
 8004b56:	6013      	str	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004b58:	b672      	cpsid	i
  {
    chSysLock();
    chCondSignalI(&c1);
 8004b5a:	f000 fa99 	bl	8005090 <chCondSignalI.constprop.28>
    chCondSignalI(&c1);
 8004b5e:	f000 fa97 	bl	8005090 <chCondSignalI.constprop.28>
    chCondSignalI(&c1);
 8004b62:	f000 fa95 	bl	8005090 <chCondSignalI.constprop.28>
    chCondSignalI(&c1);
 8004b66:	f000 fa93 	bl	8005090 <chCondSignalI.constprop.28>
    chCondSignalI(&c1);
 8004b6a:	f000 fa91 	bl	8005090 <chCondSignalI.constprop.28>
    chSchRescheduleS();
 8004b6e:	f7fb fccf 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004b72:	b662      	cpsie	i
    chSysUnlock();
    test_wait_threads();
 8004b74:	f7fe fec4 	bl	8003900 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8004b78:	480c      	ldr	r0, [pc, #48]	; (8004bac <rt_test_006_007_execute.lto_priv.108+0xcc>)
 8004b7a:	f000 fbd9 	bl	8005330 <_test_assert_sequence.constprop.3>
  }
}
 8004b7e:	bc04      	pop	{r2}
 8004b80:	4690      	mov	r8, r2
 8004b82:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004b84:	20000d64 	.word	0x20000d64
 8004b88:	20000e84 	.word	0x20000e84
 8004b8c:	200006e8 	.word	0x200006e8
 8004b90:	08004df1 	.word	0x08004df1
 8004b94:	08005590 	.word	0x08005590
 8004b98:	20000d68 	.word	0x20000d68
 8004b9c:	08005588 	.word	0x08005588
 8004ba0:	08005584 	.word	0x08005584
 8004ba4:	08005580 	.word	0x08005580
 8004ba8:	0800557c 	.word	0x0800557c
 8004bac:	0800558c 	.word	0x0800558c

08004bb0 <rt_test_006_005_execute.lto_priv.106>:

static void rt_test_006_005_setup(void) {
  chMtxObjectInit(&m1);
}

static void rt_test_006_005_execute(void) {
 8004bb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004bb2:	465f      	mov	r7, fp
 8004bb4:	4656      	mov	r6, sl
 8004bb6:	464d      	mov	r5, r9
 8004bb8:	4644      	mov	r4, r8
 8004bba:	b4f0      	push	{r4, r5, r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004bbc:	4d52      	ldr	r5, [pc, #328]	; (8004d08 <rt_test_006_005_execute.lto_priv.106+0x158>)
    prio = chThdGetPriorityX();
  }

  /* [6.5.2] Locking the mutex first time, it must be possible because
     it is not owned.*/
  test_set_step(2);
 8004bbe:	4c53      	ldr	r4, [pc, #332]	; (8004d0c <rt_test_006_005_execute.lto_priv.106+0x15c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004bc0:	69ab      	ldr	r3, [r5, #24]
 8004bc2:	689f      	ldr	r7, [r3, #8]
 8004bc4:	2302      	movs	r3, #2
 8004bc6:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8004bc8:	f000 fa3a 	bl	8005040 <chMtxTryLock.constprop.31>
    test_assert(b, "already locked");
 8004bcc:	4e50      	ldr	r6, [pc, #320]	; (8004d10 <rt_test_006_005_execute.lto_priv.106+0x160>)
 8004bce:	1c31      	adds	r1, r6, #0
 8004bd0:	f7ff f996 	bl	8003f00 <_test_assert>
 8004bd4:	2800      	cmp	r0, #0
 8004bd6:	d005      	beq.n	8004be4 <rt_test_006_005_execute.lto_priv.106+0x34>
  /* [6.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
  }
}
 8004bd8:	bc3c      	pop	{r2, r3, r4, r5}
 8004bda:	4690      	mov	r8, r2
 8004bdc:	4699      	mov	r9, r3
 8004bde:	46a2      	mov	sl, r4
 8004be0:	46ab      	mov	fp, r5
 8004be2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert(b, "already locked");
  }

  /* [6.5.3] Locking the mutex second time, it must fail because it is
     already owned.*/
  test_set_step(3);
 8004be4:	2303      	movs	r3, #3
 8004be6:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8004be8:	f000 fa2a 	bl	8005040 <chMtxTryLock.constprop.31>
    test_assert(!b, "not locked");
 8004bec:	2301      	movs	r3, #1
 8004bee:	4698      	mov	r8, r3
 8004bf0:	4643      	mov	r3, r8
 8004bf2:	4058      	eors	r0, r3
 8004bf4:	4b47      	ldr	r3, [pc, #284]	; (8004d14 <rt_test_006_005_execute.lto_priv.106+0x164>)
 8004bf6:	b2c0      	uxtb	r0, r0
 8004bf8:	1c19      	adds	r1, r3, #0
 8004bfa:	4699      	mov	r9, r3
 8004bfc:	f7ff f980 	bl	8003f00 <_test_assert>
 8004c00:	2800      	cmp	r0, #0
 8004c02:	d1e9      	bne.n	8004bd8 <rt_test_006_005_execute.lto_priv.106+0x28>
  }

  /* [6.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
 8004c04:	2304      	movs	r3, #4
 8004c06:	6023      	str	r3, [r4, #0]
  {
    chMtxUnlock(&m1);
 8004c08:	4b43      	ldr	r3, [pc, #268]	; (8004d18 <rt_test_006_005_execute.lto_priv.106+0x168>)
 8004c0a:	469a      	mov	sl, r3
 8004c0c:	1c18      	adds	r0, r3, #0
 8004c0e:	f7fb fd7f 	bl	8000710 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 8004c12:	4653      	mov	r3, sl
 8004c14:	6898      	ldr	r0, [r3, #8]
 8004c16:	4243      	negs	r3, r0
 8004c18:	4158      	adcs	r0, r3
 8004c1a:	4b40      	ldr	r3, [pc, #256]	; (8004d1c <rt_test_006_005_execute.lto_priv.106+0x16c>)
 8004c1c:	b2c0      	uxtb	r0, r0
 8004c1e:	1c19      	adds	r1, r3, #0
 8004c20:	469b      	mov	fp, r3
 8004c22:	f7ff f96d 	bl	8003f00 <_test_assert>
 8004c26:	2800      	cmp	r0, #0
 8004c28:	d1d6      	bne.n	8004bd8 <rt_test_006_005_execute.lto_priv.106+0x28>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 8004c2a:	4653      	mov	r3, sl
 8004c2c:	681a      	ldr	r2, [r3, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 8004c2e:	493c      	ldr	r1, [pc, #240]	; (8004d20 <rt_test_006_005_execute.lto_priv.106+0x170>)
 8004c30:	1ad0      	subs	r0, r2, r3
 8004c32:	4242      	negs	r2, r0
 8004c34:	4142      	adcs	r2, r0
 8004c36:	b2d0      	uxtb	r0, r2
 8004c38:	f7ff f962 	bl	8003f00 <_test_assert>
 8004c3c:	2800      	cmp	r0, #0
 8004c3e:	d1cb      	bne.n	8004bd8 <rt_test_006_005_execute.lto_priv.106+0x28>
  }

  /* [6.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
 8004c40:	2305      	movs	r3, #5
 8004c42:	6023      	str	r3, [r4, #0]
 8004c44:	69ab      	ldr	r3, [r5, #24]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8004c46:	4937      	ldr	r1, [pc, #220]	; (8004d24 <rt_test_006_005_execute.lto_priv.106+0x174>)
 8004c48:	6898      	ldr	r0, [r3, #8]
 8004c4a:	1a38      	subs	r0, r7, r0
 8004c4c:	4242      	negs	r2, r0
 8004c4e:	4142      	adcs	r2, r0
 8004c50:	b2d0      	uxtb	r0, r2
 8004c52:	f7ff f955 	bl	8003f00 <_test_assert>
 8004c56:	2800      	cmp	r0, #0
 8004c58:	d1be      	bne.n	8004bd8 <rt_test_006_005_execute.lto_priv.106+0x28>
  }

  /* [6.5.6] Testing chMtxUnlockAll() behavior.*/
  test_set_step(6);
 8004c5a:	2306      	movs	r3, #6
 8004c5c:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8004c5e:	f000 f9ef 	bl	8005040 <chMtxTryLock.constprop.31>
    test_assert(b, "already locked");
 8004c62:	1c31      	adds	r1, r6, #0
 8004c64:	f7ff f94c 	bl	8003f00 <_test_assert>
 8004c68:	2800      	cmp	r0, #0
 8004c6a:	d1b5      	bne.n	8004bd8 <rt_test_006_005_execute.lto_priv.106+0x28>
    b = chMtxTryLock(&m1);
 8004c6c:	f000 f9e8 	bl	8005040 <chMtxTryLock.constprop.31>
    test_assert(!b, "not locked");
 8004c70:	4643      	mov	r3, r8
 8004c72:	4058      	eors	r0, r3
 8004c74:	b2c0      	uxtb	r0, r0
 8004c76:	4649      	mov	r1, r9
 8004c78:	f7ff f942 	bl	8003f00 <_test_assert>
 8004c7c:	2800      	cmp	r0, #0
 8004c7e:	d1ab      	bne.n	8004bd8 <rt_test_006_005_execute.lto_priv.106+0x28>
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 8004c80:	69ae      	ldr	r6, [r5, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004c82:	b672      	cpsid	i

  chSysLock();
  if (ctp->mtxlist != NULL) {
 8004c84:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8004c86:	2b00      	cmp	r3, #0
 8004c88:	d01a      	beq.n	8004cc0 <rt_test_006_005_execute.lto_priv.106+0x110>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 8004c8a:	2200      	movs	r2, #0
 8004c8c:	4690      	mov	r8, r2
 8004c8e:	e00b      	b.n	8004ca8 <rt_test_006_005_execute.lto_priv.106+0xf8>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8004c90:	6802      	ldr	r2, [r0, #0]
 8004c92:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8004c94:	6053      	str	r3, [r2, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
        mp->next = tp->mtxlist;
 8004c96:	6b82      	ldr	r2, [r0, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
 8004c98:	6098      	str	r0, [r3, #8]
        mp->next = tp->mtxlist;
 8004c9a:	60da      	str	r2, [r3, #12]
        tp->mtxlist = mp;
 8004c9c:	6383      	str	r3, [r0, #56]	; 0x38
        (void) chSchReadyI(tp);
 8004c9e:	f7fb fcf7 	bl	8000690 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
      }
    } while (ctp->mtxlist != NULL);
 8004ca2:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8004ca4:	2b00      	cmp	r3, #0
 8004ca6:	d007      	beq.n	8004cb8 <rt_test_006_005_execute.lto_priv.106+0x108>

  chSysLock();
  if (ctp->mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->mtxlist;
      ctp->mtxlist = mp->next;
 8004ca8:	68da      	ldr	r2, [r3, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8004caa:	6818      	ldr	r0, [r3, #0]
 8004cac:	63b2      	str	r2, [r6, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 8004cae:	4283      	cmp	r3, r0
 8004cb0:	d1ee      	bne.n	8004c90 <rt_test_006_005_execute.lto_priv.106+0xe0>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 8004cb2:	4642      	mov	r2, r8
 8004cb4:	609a      	str	r2, [r3, #8]
 8004cb6:	e7f4      	b.n	8004ca2 <rt_test_006_005_execute.lto_priv.106+0xf2>
      }
    } while (ctp->mtxlist != NULL);
    ctp->prio = ctp->realprio;
 8004cb8:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 8004cba:	60b3      	str	r3, [r6, #8]
    chSchRescheduleS();
 8004cbc:	f7fb fc28 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004cc0:	b662      	cpsie	i

    chMtxUnlockAll();
    test_assert(m1.owner == NULL, "still owned");
 8004cc2:	4653      	mov	r3, sl
 8004cc4:	6898      	ldr	r0, [r3, #8]
 8004cc6:	4659      	mov	r1, fp
 8004cc8:	4243      	negs	r3, r0
 8004cca:	4158      	adcs	r0, r3
 8004ccc:	b2c0      	uxtb	r0, r0
 8004cce:	f7ff f917 	bl	8003f00 <_test_assert>
 8004cd2:	2800      	cmp	r0, #0
 8004cd4:	d000      	beq.n	8004cd8 <rt_test_006_005_execute.lto_priv.106+0x128>
 8004cd6:	e77f      	b.n	8004bd8 <rt_test_006_005_execute.lto_priv.106+0x28>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 8004cd8:	4653      	mov	r3, sl
 8004cda:	681a      	ldr	r2, [r3, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 8004cdc:	4910      	ldr	r1, [pc, #64]	; (8004d20 <rt_test_006_005_execute.lto_priv.106+0x170>)
 8004cde:	1ad0      	subs	r0, r2, r3
 8004ce0:	4242      	negs	r2, r0
 8004ce2:	4142      	adcs	r2, r0
 8004ce4:	b2d0      	uxtb	r0, r2
 8004ce6:	f7ff f90b 	bl	8003f00 <_test_assert>
 8004cea:	2800      	cmp	r0, #0
 8004cec:	d000      	beq.n	8004cf0 <rt_test_006_005_execute.lto_priv.106+0x140>
 8004cee:	e773      	b.n	8004bd8 <rt_test_006_005_execute.lto_priv.106+0x28>
  }

  /* [6.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
 8004cf0:	2307      	movs	r3, #7
 8004cf2:	6023      	str	r3, [r4, #0]
 8004cf4:	69ab      	ldr	r3, [r5, #24]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8004cf6:	490b      	ldr	r1, [pc, #44]	; (8004d24 <rt_test_006_005_execute.lto_priv.106+0x174>)
 8004cf8:	6898      	ldr	r0, [r3, #8]
 8004cfa:	1a38      	subs	r0, r7, r0
 8004cfc:	4243      	negs	r3, r0
 8004cfe:	4143      	adcs	r3, r0
 8004d00:	b2d8      	uxtb	r0, r3
 8004d02:	f7ff f8fd 	bl	8003f00 <_test_assert>
 8004d06:	e767      	b.n	8004bd8 <rt_test_006_005_execute.lto_priv.106+0x28>
 8004d08:	20000e84 	.word	0x20000e84
 8004d0c:	20000d64 	.word	0x20000d64
 8004d10:	08007080 	.word	0x08007080
 8004d14:	08007090 	.word	0x08007090
 8004d18:	20000418 	.word	0x20000418
 8004d1c:	0800709c 	.word	0x0800709c
 8004d20:	0800552c 	.word	0x0800552c
 8004d24:	08007068 	.word	0x08007068
 8004d28:	46c0      	nop			; (mov r8, r8)
 8004d2a:	46c0      	nop			; (mov r8, r8)
 8004d2c:	46c0      	nop			; (mov r8, r8)
 8004d2e:	46c0      	nop			; (mov r8, r8)

08004d30 <thread4B>:
  chThdSleepMilliseconds(50);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static THD_FUNCTION(thread4B, p) {
 8004d30:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
 8004d32:	4807      	ldr	r0, [pc, #28]	; (8004d50 <thread4B+0x20>)
 8004d34:	f7fc f93c 	bl	8000fb0 <chThdSleep>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004d38:	b672      	cpsid	i
  chSysLock();
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 8004d3a:	4c06      	ldr	r4, [pc, #24]	; (8004d54 <thread4B+0x24>)
 8004d3c:	1c20      	adds	r0, r4, #0
 8004d3e:	f7fb fd17 	bl	8000770 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 8004d42:	1c20      	adds	r0, r4, #0
 8004d44:	f7fb fcbc 	bl	80006c0 <chMtxUnlockS>
  chSchRescheduleS();
 8004d48:	f7fb fbe2 	bl	8000510 <chSchRescheduleS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004d4c:	b662      	cpsie	i
  chSysUnlock();
}
 8004d4e:	bd10      	pop	{r4, pc}
 8004d50:	000005dc 	.word	0x000005dc
 8004d54:	20000408 	.word	0x20000408
 8004d58:	46c0      	nop			; (mov r8, r8)
 8004d5a:	46c0      	nop			; (mov r8, r8)
 8004d5c:	46c0      	nop			; (mov r8, r8)
 8004d5e:	46c0      	nop			; (mov r8, r8)

08004d60 <thread8>:
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static THD_FUNCTION(thread8, p) {
 8004d60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004d62:	4647      	mov	r7, r8

  chMtxLock(&m2);
 8004d64:	4d1d      	ldr	r5, [pc, #116]	; (8004ddc <thread8+0x7c>)
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static THD_FUNCTION(thread8, p) {
 8004d66:	b480      	push	{r7}
 8004d68:	4680      	mov	r8, r0

  chMtxLock(&m2);
 8004d6a:	1c28      	adds	r0, r5, #0
 8004d6c:	f7fb fd68 	bl	8000840 <chMtxLock>
  chMtxLock(&m1);
 8004d70:	4e1b      	ldr	r6, [pc, #108]	; (8004de0 <thread8+0x80>)
 8004d72:	1c30      	adds	r0, r6, #0
 8004d74:	f7fb fd64 	bl	8000840 <chMtxLock>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004d78:	b672      	cpsid	i
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004d7a:	4c1a      	ldr	r4, [pc, #104]	; (8004de4 <thread8+0x84>)
 *
 * @xclass
 */
static inline mutex_t *chMtxGetNextMutexX(void) {

  return chThdGetSelfX()->mtxlist;
 8004d7c:	69a3      	ldr	r3, [r4, #24]
 8004d7e:	6b9f      	ldr	r7, [r3, #56]	; 0x38
  chDbgCheckClassS();
  chDbgCheck((cp != NULL) && (timeout != TIME_IMMEDIATE));
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
 8004d80:	1c38      	adds	r0, r7, #0
 8004d82:	f7fb fc9d 	bl	80006c0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
 8004d86:	4918      	ldr	r1, [pc, #96]	; (8004de8 <thread8+0x88>)
 8004d88:	69a2      	ldr	r2, [r4, #24]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8004d8a:	1c0b      	adds	r3, r1, #0
 8004d8c:	6251      	str	r1, [r2, #36]	; 0x24
 8004d8e:	e004      	b.n	8004d9a <thread8+0x3a>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004d90:	6898      	ldr	r0, [r3, #8]
 8004d92:	4684      	mov	ip, r0
 8004d94:	6890      	ldr	r0, [r2, #8]
 8004d96:	4584      	cmp	ip, r0
 8004d98:	d302      	bcc.n	8004da0 <thread8+0x40>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8004d9a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004d9c:	428b      	cmp	r3, r1
 8004d9e:	d1f7      	bne.n	8004d90 <thread8+0x30>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8004da0:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8004da2:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8004da4:	6051      	str	r1, [r2, #4]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8004da6:	2007      	movs	r0, #7
  tp->queue.prev->queue.next = tp;
 8004da8:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8004daa:	605a      	str	r2, [r3, #4]
 8004dac:	f7fb fc38 	bl	8000620 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8004db0:	69a3      	ldr	r3, [r4, #24]
  queue_prio_insert(currp, &cp->queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, timeout);
  if (msg != MSG_TIMEOUT) {
 8004db2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004db4:	3301      	adds	r3, #1
 8004db6:	d002      	beq.n	8004dbe <thread8+0x5e>
    chMtxLockS(mp);
 8004db8:	1c38      	adds	r0, r7, #0
 8004dba:	f7fb fcd9 	bl	8000770 <chMtxLockS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004dbe:	b662      	cpsie	i
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 8004dc0:	4643      	mov	r3, r8
 8004dc2:	7818      	ldrb	r0, [r3, #0]
 8004dc4:	f7fe fdcc 	bl	8003960 <test_emit_token>
  chMtxUnlock(&m1);
 8004dc8:	1c30      	adds	r0, r6, #0
 8004dca:	f7fb fca1 	bl	8000710 <chMtxUnlock>
  chMtxUnlock(&m2);
 8004dce:	1c28      	adds	r0, r5, #0
 8004dd0:	f7fb fc9e 	bl	8000710 <chMtxUnlock>
}
 8004dd4:	bc04      	pop	{r2}
 8004dd6:	4690      	mov	r8, r2
 8004dd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004dda:	46c0      	nop			; (mov r8, r8)
 8004ddc:	20000408 	.word	0x20000408
 8004de0:	20000418 	.word	0x20000418
 8004de4:	20000e84 	.word	0x20000e84
 8004de8:	20000428 	.word	0x20000428
 8004dec:	46c0      	nop			; (mov r8, r8)
 8004dee:	46c0      	nop			; (mov r8, r8)

08004df0 <thread6>:
  chSchRescheduleS();
  chSysUnlock();
}

#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
static THD_FUNCTION(thread6, p) {
 8004df0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chMtxLock(&m1);
 8004df2:	4d15      	ldr	r5, [pc, #84]	; (8004e48 <thread6+0x58>)
  chSchRescheduleS();
  chSysUnlock();
}

#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
static THD_FUNCTION(thread6, p) {
 8004df4:	1c07      	adds	r7, r0, #0

  chMtxLock(&m1);
 8004df6:	1c28      	adds	r0, r5, #0
 8004df8:	f7fb fd22 	bl	8000840 <chMtxLock>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004dfc:	b672      	cpsid	i
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 8004dfe:	4b13      	ldr	r3, [pc, #76]	; (8004e4c <thread6+0x5c>)
 8004e00:	699c      	ldr	r4, [r3, #24]
 8004e02:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(mp != NULL, "not owning a mutex");

  /* Releasing "current" mutex.*/
  chMtxUnlockS(mp);
 8004e04:	1c30      	adds	r0, r6, #0
 8004e06:	f7fb fc5b 	bl	80006c0 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->u.wtobjp = cp;
 8004e0a:	4a11      	ldr	r2, [pc, #68]	; (8004e50 <thread6+0x60>)
 8004e0c:	6262      	str	r2, [r4, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8004e0e:	1c13      	adds	r3, r2, #0
 8004e10:	e003      	b.n	8004e1a <thread6+0x2a>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004e12:	6899      	ldr	r1, [r3, #8]
 8004e14:	68a0      	ldr	r0, [r4, #8]
 8004e16:	4281      	cmp	r1, r0
 8004e18:	d302      	bcc.n	8004e20 <thread6+0x30>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8004e1a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004e1c:	4293      	cmp	r3, r2
 8004e1e:	d1f8      	bne.n	8004e12 <thread6+0x22>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8004e20:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8004e22:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8004e24:	6062      	str	r2, [r4, #4]
  queue_prio_insert(ctp, &cp->queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 8004e26:	2007      	movs	r0, #7
  tp->queue.prev->queue.next = tp;
 8004e28:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8004e2a:	605c      	str	r4, [r3, #4]
 8004e2c:	f7fb fbf8 	bl	8000620 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
  chMtxLockS(mp);
 8004e30:	1c30      	adds	r0, r6, #0
 8004e32:	f7fb fc9d 	bl	8000770 <chMtxLockS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004e36:	b662      	cpsie	i
  chCondWait(&c1);
  test_emit_token(*(char *)p);
 8004e38:	7838      	ldrb	r0, [r7, #0]
 8004e3a:	f7fe fd91 	bl	8003960 <test_emit_token>
  chMtxUnlock(&m1);
 8004e3e:	1c28      	adds	r0, r5, #0
 8004e40:	f7fb fc66 	bl	8000710 <chMtxUnlock>
}
 8004e44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004e46:	46c0      	nop			; (mov r8, r8)
 8004e48:	20000418 	.word	0x20000418
 8004e4c:	20000e84 	.word	0x20000e84
 8004e50:	20000428 	.word	0x20000428
 8004e54:	46c0      	nop			; (mov r8, r8)
 8004e56:	46c0      	nop			; (mov r8, r8)
 8004e58:	46c0      	nop			; (mov r8, r8)
 8004e5a:	46c0      	nop			; (mov r8, r8)
 8004e5c:	46c0      	nop			; (mov r8, r8)
 8004e5e:	46c0      	nop			; (mov r8, r8)

08004e60 <_pal_lld_setgroupmode.constprop.45>:
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8004e60:	2307      	movs	r3, #7
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8004e62:	b5f0      	push	{r4, r5, r6, r7, lr}

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8004e64:	2190      	movs	r1, #144	; 0x90
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8004e66:	465f      	mov	r7, fp
 8004e68:	464d      	mov	r5, r9
 8004e6a:	4644      	mov	r4, r8
 8004e6c:	4656      	mov	r6, sl
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8004e6e:	469c      	mov	ip, r3
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8004e70:	3308      	adds	r3, #8
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8004e72:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8004e74:	2200      	movs	r2, #0
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8004e76:	2502      	movs	r5, #2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8004e78:	2401      	movs	r4, #1
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8004e7a:	469b      	mov	fp, r3
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8004e7c:	05c9      	lsls	r1, r1, #23
 8004e7e:	e00f      	b.n	8004ea0 <_pal_lld_setgroupmode.constprop.45+0x40>
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8004e80:	4647      	mov	r7, r8
 8004e82:	6a0e      	ldr	r6, [r1, #32]
 8004e84:	43be      	bics	r6, r7
 8004e86:	46b0      	mov	r8, r6
 8004e88:	4656      	mov	r6, sl
 8004e8a:	4647      	mov	r7, r8
 8004e8c:	433e      	orrs	r6, r7
 8004e8e:	620e      	str	r6, [r1, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8004e90:	680e      	ldr	r6, [r1, #0]
 8004e92:	4033      	ands	r3, r6
 8004e94:	432b      	orrs	r3, r5
 8004e96:	600b      	str	r3, [r1, #0]
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
 8004e98:	0840      	lsrs	r0, r0, #1
    if (!mask)
 8004e9a:	d028      	beq.n	8004eee <_pal_lld_setgroupmode.constprop.45+0x8e>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8004e9c:	00ad      	lsls	r5, r5, #2
    bit++;
 8004e9e:	3201      	adds	r2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8004ea0:	4204      	tst	r4, r0
 8004ea2:	d0f9      	beq.n	8004e98 <_pal_lld_setgroupmode.constprop.45+0x38>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8004ea4:	4663      	mov	r3, ip
 8004ea6:	1c26      	adds	r6, r4, #0
 8004ea8:	4013      	ands	r3, r2
 8004eaa:	009b      	lsls	r3, r3, #2
 8004eac:	409e      	lsls	r6, r3
 8004eae:	46b2      	mov	sl, r6
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8004eb0:	465e      	mov	r6, fp
 8004eb2:	409e      	lsls	r6, r3
 8004eb4:	46b0      	mov	r8, r6
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 8004eb6:	1c26      	adds	r6, r4, #0
 8004eb8:	4096      	lsls	r6, r2
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8004eba:	684b      	ldr	r3, [r1, #4]
 8004ebc:	43b3      	bics	r3, r6
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8004ebe:	2603      	movs	r6, #3
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8004ec0:	604b      	str	r3, [r1, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8004ec2:	688b      	ldr	r3, [r1, #8]
 8004ec4:	4699      	mov	r9, r3
 8004ec6:	0053      	lsls	r3, r2, #1
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8004ec8:	409e      	lsls	r6, r3
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8004eca:	43f3      	mvns	r3, r6
 8004ecc:	464e      	mov	r6, r9
 8004ece:	401e      	ands	r6, r3
 8004ed0:	608e      	str	r6, [r1, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8004ed2:	68ce      	ldr	r6, [r1, #12]
 8004ed4:	401e      	ands	r6, r3
 8004ed6:	60ce      	str	r6, [r1, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8004ed8:	2a07      	cmp	r2, #7
 8004eda:	d9d1      	bls.n	8004e80 <_pal_lld_setgroupmode.constprop.45+0x20>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8004edc:	4647      	mov	r7, r8
 8004ede:	6a4e      	ldr	r6, [r1, #36]	; 0x24
 8004ee0:	43be      	bics	r6, r7
 8004ee2:	46b0      	mov	r8, r6
 8004ee4:	4656      	mov	r6, sl
 8004ee6:	4647      	mov	r7, r8
 8004ee8:	433e      	orrs	r6, r7
 8004eea:	624e      	str	r6, [r1, #36]	; 0x24
 8004eec:	e7d0      	b.n	8004e90 <_pal_lld_setgroupmode.constprop.45+0x30>
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  }
}
 8004eee:	bc3c      	pop	{r2, r3, r4, r5}
 8004ef0:	4690      	mov	r8, r2
 8004ef2:	4699      	mov	r9, r3
 8004ef4:	46a2      	mov	sl, r4
 8004ef6:	46ab      	mov	fp, r5
 8004ef8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004efa:	46c0      	nop			; (mov r8, r8)
 8004efc:	46c0      	nop			; (mov r8, r8)
 8004efe:	46c0      	nop			; (mov r8, r8)

08004f00 <chThdCreateStatic.constprop.40>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8004f00:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004f02:	b672      	cpsid	i
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8004f04:	1c05      	adds	r5, r0, #0
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8004f06:	1c44      	adds	r4, r0, #1
 8004f08:	34ff      	adds	r4, #255	; 0xff
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8004f0a:	35dc      	adds	r5, #220	; 0xdc
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8004f0c:	61e0      	str	r0, [r4, #28]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8004f0e:	60e5      	str	r5, [r4, #12]
 8004f10:	616b      	str	r3, [r5, #20]
 8004f12:	4b19      	ldr	r3, [pc, #100]	; (8004f78 <chThdCreateStatic.constprop.40+0x78>)
 8004f14:	612a      	str	r2, [r5, #16]
 8004f16:	622b      	str	r3, [r5, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8004f18:	1c03      	adds	r3, r0, #0
 8004f1a:	2202      	movs	r2, #2
 8004f1c:	3321      	adds	r3, #33	; 0x21
 8004f1e:	33ff      	adds	r3, #255	; 0xff
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8004f20:	60a1      	str	r1, [r4, #8]
  tp->state     = CH_STATE_WTSTART;
 8004f22:	701a      	strb	r2, [r3, #0]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8004f24:	1c02      	adds	r2, r0, #0
 8004f26:	2300      	movs	r3, #0
 8004f28:	3222      	adds	r2, #34	; 0x22
 8004f2a:	32ff      	adds	r2, #255	; 0xff
 8004f2c:	7013      	strb	r3, [r2, #0]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8004f2e:	63a3      	str	r3, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8004f30:	6363      	str	r3, [r4, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8004f32:	1c03      	adds	r3, r0, #0
 8004f34:	2201      	movs	r2, #1
 8004f36:	3323      	adds	r3, #35	; 0x23
 8004f38:	33ff      	adds	r3, #255	; 0xff
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8004f3a:	63e1      	str	r1, [r4, #60]	; 0x3c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8004f3c:	701a      	strb	r2, [r3, #0]
  tp->name      = name;
 8004f3e:	4b0f      	ldr	r3, [pc, #60]	; (8004f7c <chThdCreateStatic.constprop.40+0x7c>)
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8004f40:	2100      	movs	r1, #0
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8004f42:	61a3      	str	r3, [r4, #24]
  REG_INSERT(tp);
 8004f44:	4b0e      	ldr	r3, [pc, #56]	; (8004f80 <chThdCreateStatic.constprop.40+0x80>)
 8004f46:	695a      	ldr	r2, [r3, #20]
 8004f48:	6123      	str	r3, [r4, #16]
 8004f4a:	6162      	str	r2, [r4, #20]
 8004f4c:	6114      	str	r4, [r2, #16]
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8004f4e:	1c02      	adds	r2, r0, #0
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8004f50:	615c      	str	r4, [r3, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8004f52:	2394      	movs	r3, #148	; 0x94
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8004f54:	3229      	adds	r2, #41	; 0x29
 8004f56:	32ff      	adds	r2, #255	; 0xff
 8004f58:	005b      	lsls	r3, r3, #1
 8004f5a:	50c2      	str	r2, [r0, r3]
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8004f5c:	1c03      	adds	r3, r0, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004f5e:	2296      	movs	r2, #150	; 0x96
 8004f60:	332d      	adds	r3, #45	; 0x2d
 8004f62:	33ff      	adds	r3, #255	; 0xff
 8004f64:	0052      	lsls	r2, r2, #1
 8004f66:	5083      	str	r3, [r0, r2]
  tqp->prev = (thread_t *)tqp;
 8004f68:	605b      	str	r3, [r3, #4]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8004f6a:	1c20      	adds	r0, r4, #0
 8004f6c:	f7fb fb10 	bl	8000590 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004f70:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 8004f72:	1c20      	adds	r0, r4, #0
 8004f74:	bd38      	pop	{r3, r4, r5, pc}
 8004f76:	46c0      	nop			; (mov r8, r8)
 8004f78:	080001b9 	.word	0x080001b9
 8004f7c:	080070b4 	.word	0x080070b4
 8004f80:	20000e84 	.word	0x20000e84
 8004f84:	46c0      	nop			; (mov r8, r8)
 8004f86:	46c0      	nop			; (mov r8, r8)
 8004f88:	46c0      	nop			; (mov r8, r8)
 8004f8a:	46c0      	nop			; (mov r8, r8)
 8004f8c:	46c0      	nop			; (mov r8, r8)
 8004f8e:	46c0      	nop			; (mov r8, r8)

08004f90 <chSemWaitTimeout.constprop.35>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, sysinterval_t timeout) {
 8004f90:	b510      	push	{r4, lr}
 8004f92:	1c01      	adds	r1, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004f94:	b672      	cpsid	i
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8004f96:	4b0d      	ldr	r3, [pc, #52]	; (8004fcc <chSemWaitTimeout.constprop.35+0x3c>)
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
  }

  return MSG_OK;
 8004f98:	2000      	movs	r0, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8004f9a:	689c      	ldr	r4, [r3, #8]
 8004f9c:	1e62      	subs	r2, r4, #1
 8004f9e:	609a      	str	r2, [r3, #8]
 8004fa0:	2a00      	cmp	r2, #0
 8004fa2:	db01      	blt.n	8004fa8 <chSemWaitTimeout.constprop.35+0x18>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004fa4:	b662      	cpsie	i
  chSysLock();
  msg = chSemWaitTimeoutS(sp, timeout);
  chSysUnlock();

  return msg;
}
 8004fa6:	bd10      	pop	{r4, pc}
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == timeout) {
 8004fa8:	2900      	cmp	r1, #0
 8004faa:	d00b      	beq.n	8004fc4 <chSemWaitTimeout.constprop.35+0x34>
      sp->cnt++;

      return MSG_TIMEOUT;
    }
    currp->u.wtsemp = sp;
 8004fac:	4a08      	ldr	r2, [pc, #32]	; (8004fd0 <chSemWaitTimeout.constprop.35+0x40>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8004fae:	6858      	ldr	r0, [r3, #4]
 8004fb0:	6992      	ldr	r2, [r2, #24]
 8004fb2:	6050      	str	r0, [r2, #4]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 8004fb4:	6013      	str	r3, [r2, #0]
 8004fb6:	6253      	str	r3, [r2, #36]	; 0x24
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
 8004fb8:	6002      	str	r2, [r0, #0]
  tqp->prev                  = tp;
 8004fba:	605a      	str	r2, [r3, #4]
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8004fbc:	2005      	movs	r0, #5
 8004fbe:	f7fb fe6f 	bl	8000ca0 <chSchGoSleepTimeoutS>
 8004fc2:	e7ef      	b.n	8004fa4 <chSemWaitTimeout.constprop.35+0x14>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == timeout) {
      sp->cnt++;
 8004fc4:	609c      	str	r4, [r3, #8]

      return MSG_TIMEOUT;
 8004fc6:	3801      	subs	r0, #1
 8004fc8:	e7ec      	b.n	8004fa4 <chSemWaitTimeout.constprop.35+0x14>
 8004fca:	46c0      	nop			; (mov r8, r8)
 8004fcc:	20000e74 	.word	0x20000e74
 8004fd0:	20000e84 	.word	0x20000e84
 8004fd4:	46c0      	nop			; (mov r8, r8)
 8004fd6:	46c0      	nop			; (mov r8, r8)
 8004fd8:	46c0      	nop			; (mov r8, r8)
 8004fda:	46c0      	nop			; (mov r8, r8)
 8004fdc:	46c0      	nop			; (mov r8, r8)
 8004fde:	46c0      	nop			; (mov r8, r8)

08004fe0 <chSemSignalWait.constprop.33>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8004fe0:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004fe2:	b672      	cpsid	i
              ((sps->cnt < (cnt_t)0) && queue_notempty(&sps->queue)),
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
 8004fe4:	4c12      	ldr	r4, [pc, #72]	; (8005030 <chSemSignalWait.constprop.33+0x50>)
 8004fe6:	68a3      	ldr	r3, [r4, #8]
 8004fe8:	3301      	adds	r3, #1
 8004fea:	60a3      	str	r3, [r4, #8]
 8004fec:	2b00      	cmp	r3, #0
 8004fee:	dd15      	ble.n	800501c <chSemSignalWait.constprop.33+0x3c>
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
 8004ff0:	3b01      	subs	r3, #1
 8004ff2:	60a3      	str	r3, [r4, #8]
 8004ff4:	2b00      	cmp	r3, #0
 8004ff6:	db04      	blt.n	8005002 <chSemSignalWait.constprop.33+0x22>
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->u.rdymsg;
  }
  else {
    chSchRescheduleS();
 8004ff8:	f7fb fa8a 	bl	8000510 <chSchRescheduleS>
    msg = MSG_OK;
 8004ffc:	2000      	movs	r0, #0
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004ffe:	b662      	cpsie	i
  }
  chSysUnlock();

  return msg;
}
 8005000:	bd38      	pop	{r3, r4, r5, pc}
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8005002:	4b0c      	ldr	r3, [pc, #48]	; (8005034 <chSemSignalWait.constprop.33+0x54>)
    sem_insert(ctp, &spw->queue);
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 8005004:	2005      	movs	r0, #5
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8005006:	699d      	ldr	r5, [r3, #24]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8005008:	6863      	ldr	r3, [r4, #4]
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 800500a:	602c      	str	r4, [r5, #0]
  tp->queue.prev             = tqp->prev;
 800500c:	606b      	str	r3, [r5, #4]
  tp->queue.prev->queue.next = tp;
 800500e:	601d      	str	r5, [r3, #0]
  tqp->prev                  = tp;
 8005010:	6065      	str	r5, [r4, #4]
    sem_insert(ctp, &spw->queue);
    ctp->u.wtsemp = spw;
 8005012:	626c      	str	r4, [r5, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTSEM);
 8005014:	f7fb fb04 	bl	8000620 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
 8005018:	6a68      	ldr	r0, [r5, #36]	; 0x24
 800501a:	e7f0      	b.n	8004ffe <chSemSignalWait.constprop.33+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800501c:	6820      	ldr	r0, [r4, #0]

  tqp->next             = tp->queue.next;
 800501e:	6803      	ldr	r3, [r0, #0]
 8005020:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005022:	605c      	str	r4, [r3, #4]
              "inconsistent semaphore");
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
 8005024:	f7fb fb34 	bl	8000690 <chSchReadyI>
 8005028:	2300      	movs	r3, #0
 800502a:	6243      	str	r3, [r0, #36]	; 0x24
 800502c:	68a3      	ldr	r3, [r4, #8]
 800502e:	e7df      	b.n	8004ff0 <chSemSignalWait.constprop.33+0x10>
 8005030:	20000e74 	.word	0x20000e74
 8005034:	20000e84 	.word	0x20000e84
 8005038:	46c0      	nop			; (mov r8, r8)
 800503a:	46c0      	nop			; (mov r8, r8)
 800503c:	46c0      	nop			; (mov r8, r8)
 800503e:	46c0      	nop			; (mov r8, r8)

08005040 <chMtxTryLock.constprop.31>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005040:	b672      	cpsid	i
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 8005042:	4b07      	ldr	r3, [pc, #28]	; (8005060 <chMtxTryLock.constprop.31+0x20>)
    if (mp->owner == currp) {
      mp->cnt++;
      return true;
    }
#endif
    return false;
 8005044:	2000      	movs	r0, #0
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 8005046:	689a      	ldr	r2, [r3, #8]
 8005048:	2a00      	cmp	r2, #0
 800504a:	d001      	beq.n	8005050 <chMtxTryLock.constprop.31+0x10>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800504c:	b662      	cpsie	i
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 800504e:	4770      	bx	lr

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 8005050:	4a04      	ldr	r2, [pc, #16]	; (8005064 <chMtxTryLock.constprop.31+0x24>)
  mp->next = currp->mtxlist;
  currp->mtxlist = mp;
 8005052:	3001      	adds	r0, #1

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 8005054:	6992      	ldr	r2, [r2, #24]
  mp->next = currp->mtxlist;
 8005056:	6b91      	ldr	r1, [r2, #56]	; 0x38

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 8005058:	609a      	str	r2, [r3, #8]
  mp->next = currp->mtxlist;
 800505a:	60d9      	str	r1, [r3, #12]
  currp->mtxlist = mp;
 800505c:	6393      	str	r3, [r2, #56]	; 0x38
 800505e:	e7f5      	b.n	800504c <chMtxTryLock.constprop.31+0xc>
 8005060:	20000418 	.word	0x20000418
 8005064:	20000e84 	.word	0x20000e84
 8005068:	46c0      	nop			; (mov r8, r8)
 800506a:	46c0      	nop			; (mov r8, r8)
 800506c:	46c0      	nop			; (mov r8, r8)
 800506e:	46c0      	nop			; (mov r8, r8)

08005070 <chCondSignal.constprop.29>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8005070:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005072:	b672      	cpsid	i
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8005074:	4b05      	ldr	r3, [pc, #20]	; (800508c <chCondSignal.constprop.29+0x1c>)
 8005076:	6818      	ldr	r0, [r3, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->queue)) {
 8005078:	4298      	cmp	r0, r3
 800507a:	d005      	beq.n	8005088 <chCondSignal.constprop.29+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800507c:	6802      	ldr	r2, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
 800507e:	2100      	movs	r1, #0
 8005080:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005082:	6053      	str	r3, [r2, #4]
 8005084:	f7fb fa84 	bl	8000590 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005088:	b662      	cpsie	i
  }
  chSysUnlock();
}
 800508a:	bd08      	pop	{r3, pc}
 800508c:	20000428 	.word	0x20000428

08005090 <chCondSignalI.constprop.28>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 8005090:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8005092:	4b06      	ldr	r3, [pc, #24]	; (80050ac <chCondSignalI.constprop.28+0x1c>)
 8005094:	6818      	ldr	r0, [r3, #0]

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
 8005096:	4298      	cmp	r0, r3
 8005098:	d006      	beq.n	80050a8 <chCondSignalI.constprop.28+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800509a:	6802      	ldr	r2, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800509c:	6053      	str	r3, [r2, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800509e:	601a      	str	r2, [r3, #0]
    thread_t *tp = queue_fifo_remove(&cp->queue);
    tp->u.rdymsg = MSG_OK;
 80050a0:	2300      	movs	r3, #0
 80050a2:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 80050a4:	f7fb faf4 	bl	8000690 <chSchReadyI>
  }
}
 80050a8:	bd08      	pop	{r3, pc}
 80050aa:	46c0      	nop			; (mov r8, r8)
 80050ac:	20000428 	.word	0x20000428

080050b0 <chEvtGetAndClearEvents.constprop.20>:
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80050b0:	b672      	cpsid	i
 */
eventmask_t chEvtGetAndClearEventsI(eventmask_t events) {
  eventmask_t m;

  m = currp->epending & events;
  currp->epending &= ~events;
 80050b2:	2200      	movs	r2, #0
 * @iclass
 */
eventmask_t chEvtGetAndClearEventsI(eventmask_t events) {
  eventmask_t m;

  m = currp->epending & events;
 80050b4:	4b02      	ldr	r3, [pc, #8]	; (80050c0 <chEvtGetAndClearEvents.constprop.20+0x10>)
 80050b6:	699b      	ldr	r3, [r3, #24]
 80050b8:	6b58      	ldr	r0, [r3, #52]	; 0x34
  currp->epending &= ~events;
 80050ba:	635a      	str	r2, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80050bc:	b662      	cpsie	i
  chSysLock();
  m = chEvtGetAndClearEventsI(events);
  chSysUnlock();

  return m;
}
 80050be:	4770      	bx	lr
 80050c0:	20000e84 	.word	0x20000e84
 80050c4:	46c0      	nop			; (mov r8, r8)
 80050c6:	46c0      	nop			; (mov r8, r8)
 80050c8:	46c0      	nop			; (mov r8, r8)
 80050ca:	46c0      	nop			; (mov r8, r8)
 80050cc:	46c0      	nop			; (mov r8, r8)
 80050ce:	46c0      	nop			; (mov r8, r8)

080050d0 <chEvtWaitOne.constprop.16>:
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  thread_t *ctp = currp;
 80050d0:	4b09      	ldr	r3, [pc, #36]	; (80050f8 <chEvtWaitOne.constprop.16+0x28>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 80050d2:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 80050d4:	699c      	ldr	r4, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80050d6:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 80050d8:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80050da:	2b00      	cmp	r3, #0
 80050dc:	d105      	bne.n	80050ea <chEvtWaitOne.constprop.16+0x1a>
    ctp->u.ewmask = events;
 80050de:	3b01      	subs	r3, #1
 80050e0:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 80050e2:	200a      	movs	r0, #10
 80050e4:	f7fb fa9c 	bl	8000620 <chSchGoSleepS>
    m = ctp->epending & events;
 80050e8:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 80050ea:	4258      	negs	r0, r3
 80050ec:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 80050ee:	4383      	bics	r3, r0
 80050f0:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80050f2:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 80050f4:	bd10      	pop	{r4, pc}
 80050f6:	46c0      	nop			; (mov r8, r8)
 80050f8:	20000e84 	.word	0x20000e84
 80050fc:	46c0      	nop			; (mov r8, r8)
 80050fe:	46c0      	nop			; (mov r8, r8)

08005100 <chEvtWaitAny.constprop.15>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  thread_t *ctp = currp;
 8005100:	4b08      	ldr	r3, [pc, #32]	; (8005124 <chEvtWaitAny.constprop.15+0x24>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8005102:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8005104:	699c      	ldr	r4, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005106:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8005108:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800510a:	2800      	cmp	r0, #0
 800510c:	d106      	bne.n	800511c <chEvtWaitAny.constprop.15+0x1c>
    ctp->u.ewmask = events;
 800510e:	2301      	movs	r3, #1
 8005110:	425b      	negs	r3, r3
    chSchGoSleepS(CH_STATE_WTOREVT);
 8005112:	300a      	adds	r0, #10
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
    ctp->u.ewmask = events;
 8005114:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8005116:	f7fb fa83 	bl	8000620 <chSchGoSleepS>
    m = ctp->epending & events;
 800511a:	6b60      	ldr	r0, [r4, #52]	; 0x34
  }
  ctp->epending &= ~m;
 800511c:	2300      	movs	r3, #0
 800511e:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005120:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 8005122:	bd10      	pop	{r4, pc}
 8005124:	20000e84 	.word	0x20000e84
 8005128:	46c0      	nop			; (mov r8, r8)
 800512a:	46c0      	nop			; (mov r8, r8)
 800512c:	46c0      	nop			; (mov r8, r8)
 800512e:	46c0      	nop			; (mov r8, r8)

08005130 <chEvtWaitAll.constprop.14>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  thread_t *ctp = currp;
 8005130:	4b0a      	ldr	r3, [pc, #40]	; (800515c <chEvtWaitAll.constprop.14+0x2c>)
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8005132:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8005134:	699c      	ldr	r4, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005136:	b672      	cpsid	i

  chSysLock();
  if ((ctp->epending & events) != events) {
 8005138:	2205      	movs	r2, #5
 800513a:	1c11      	adds	r1, r2, #0
 800513c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800513e:	4019      	ands	r1, r3
 8005140:	2905      	cmp	r1, #5
 8005142:	d004      	beq.n	800514e <chEvtWaitAll.constprop.14+0x1e>
    ctp->u.ewmask = events;
 8005144:	6262      	str	r2, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8005146:	200b      	movs	r0, #11
 8005148:	f7fb fa6a 	bl	8000620 <chSchGoSleepS>
 800514c:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  ctp->epending &= ~events;
 800514e:	2205      	movs	r2, #5
 8005150:	4393      	bics	r3, r2
 8005152:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005154:	b662      	cpsie	i
  chSysUnlock();

  return events;
}
 8005156:	2005      	movs	r0, #5
 8005158:	bd10      	pop	{r4, pc}
 800515a:	46c0      	nop			; (mov r8, r8)
 800515c:	20000e84 	.word	0x20000e84

08005160 <chThdCreateFromHeap.constprop.9>:
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 8005160:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005162:	464d      	mov	r5, r9
 8005164:	4644      	mov	r4, r8
 8005166:	465f      	mov	r7, fp
 8005168:	4656      	mov	r6, sl
 800516a:	b4f0      	push	{r4, r5, r6, r7}
 800516c:	4681      	mov	r9, r0
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 800516e:	1dc4      	adds	r4, r0, #7

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8005170:	4848      	ldr	r0, [pc, #288]	; (8005294 <chThdCreateFromHeap.constprop.9+0x134>)
 8005172:	b089      	sub	sp, #36	; 0x24
 8005174:	300c      	adds	r0, #12
 8005176:	9301      	str	r3, [sp, #4]
 8005178:	4688      	mov	r8, r1
 800517a:	9200      	str	r2, [sp, #0]
 800517c:	f7fb fb60 	bl	8000840 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 8005180:	4b44      	ldr	r3, [pc, #272]	; (8005294 <chThdCreateFromHeap.constprop.9+0x134>)
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8005182:	08e4      	lsrs	r4, r4, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 8005184:	1d1f      	adds	r7, r3, #4
  while (H_NEXT(qp) != NULL) {
 8005186:	683b      	ldr	r3, [r7, #0]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8005188:	2507      	movs	r5, #7
 800518a:	46a4      	mov	ip, r4
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 800518c:	2b00      	cmp	r3, #0
 800518e:	d015      	beq.n	80051bc <chThdCreateFromHeap.constprop.9+0x5c>

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8005190:	1c1a      	adds	r2, r3, #0
 8005192:	1c1e      	adds	r6, r3, #0

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005194:	685c      	ldr	r4, [r3, #4]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8005196:	320f      	adds	r2, #15

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005198:	1c61      	adds	r1, r4, #1

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800519a:	43aa      	bics	r2, r5

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800519c:	00c9      	lsls	r1, r1, #3

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800519e:	3a08      	subs	r2, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 80051a0:	1858      	adds	r0, r3, r1

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 80051a2:	3608      	adds	r6, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 80051a4:	4282      	cmp	r2, r0
 80051a6:	d205      	bcs.n	80051b4 <chThdCreateFromHeap.constprop.9+0x54>
 80051a8:	3908      	subs	r1, #8
 80051aa:	1a98      	subs	r0, r3, r2
 80051ac:	1840      	adds	r0, r0, r1
 80051ae:	10c0      	asrs	r0, r0, #3
 80051b0:	4584      	cmp	ip, r0
 80051b2:	d938      	bls.n	8005226 <chThdCreateFromHeap.constprop.9+0xc6>
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80051b4:	1c1f      	adds	r7, r3, #0
 80051b6:	683b      	ldr	r3, [r7, #0]
 80051b8:	2b00      	cmp	r3, #0
 80051ba:	d1e9      	bne.n	8005190 <chThdCreateFromHeap.constprop.9+0x30>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80051bc:	4835      	ldr	r0, [pc, #212]	; (8005294 <chThdCreateFromHeap.constprop.9+0x134>)
 80051be:	4664      	mov	r4, ip
 80051c0:	300c      	adds	r0, #12
 80051c2:	f7fb faa5 	bl	8000710 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 80051c6:	4b33      	ldr	r3, [pc, #204]	; (8005294 <chThdCreateFromHeap.constprop.9+0x134>)
 80051c8:	681b      	ldr	r3, [r3, #0]
 80051ca:	2b00      	cmp	r3, #0
 80051cc:	d05b      	beq.n	8005286 <chThdCreateFromHeap.constprop.9+0x126>
    ahp = heapp->provider(pages * CH_HEAP_ALIGNMENT,
 80051ce:	00e0      	lsls	r0, r4, #3
 80051d0:	2108      	movs	r1, #8
 80051d2:	2208      	movs	r2, #8
 80051d4:	4798      	blx	r3
                          align,
                          sizeof (heap_header_t));
    if (ahp != NULL) {
 80051d6:	2800      	cmp	r0, #0
 80051d8:	d055      	beq.n	8005286 <chThdCreateFromHeap.constprop.9+0x126>
      hp = ahp - 1U;
      H_HEAP(hp) = heapp;
 80051da:	1c03      	adds	r3, r0, #0
 80051dc:	4a2d      	ldr	r2, [pc, #180]	; (8005294 <chThdCreateFromHeap.constprop.9+0x134>)
 80051de:	3b08      	subs	r3, #8
 80051e0:	601a      	str	r2, [r3, #0]
      H_SIZE(hp) = size;
 80051e2:	464a      	mov	r2, r9
 80051e4:	1c05      	adds	r5, r0, #0
 80051e6:	605a      	str	r2, [r3, #4]
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 80051e8:	4643      	mov	r3, r8
 80051ea:	9302      	str	r3, [sp, #8]
 80051ec:	9b00      	ldr	r3, [sp, #0]
 80051ee:	9503      	str	r5, [sp, #12]
 80051f0:	9305      	str	r3, [sp, #20]
 80051f2:	4b29      	ldr	r3, [pc, #164]	; (8005298 <chThdCreateFromHeap.constprop.9+0x138>)
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + size),
 80051f4:	444d      	add	r5, r9
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 80051f6:	9306      	str	r3, [sp, #24]
 80051f8:	9b01      	ldr	r3, [sp, #4]
 80051fa:	9504      	str	r5, [sp, #16]
 80051fc:	9307      	str	r3, [sp, #28]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80051fe:	b672      	cpsid	i
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8005200:	a802      	add	r0, sp, #8
 8005202:	f7fb f92d 	bl	8000460 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 8005206:	2201      	movs	r2, #1
 8005208:	2321      	movs	r3, #33	; 0x21
  chSchWakeupS(tp, MSG_OK);
 800520a:	2100      	movs	r1, #0
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
  tp->flags = CH_FLAG_MODE_HEAP;
 800520c:	54c2      	strb	r2, [r0, r3]
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 800520e:	1c04      	adds	r4, r0, #0
  tp->flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 8005210:	f7fb f9be 	bl	8000590 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005214:	b662      	cpsie	i
 8005216:	1c20      	adds	r0, r4, #0
  chSysUnlock();

  return tp;
}
 8005218:	b009      	add	sp, #36	; 0x24
 800521a:	bc3c      	pop	{r2, r3, r4, r5}
 800521c:	4690      	mov	r8, r2
 800521e:	4699      	mov	r9, r3
 8005220:	46a2      	mov	sl, r4
 8005222:	46ab      	mov	fp, r5
 8005224:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005226:	46b2      	mov	sl, r6
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005228:	4693      	mov	fp, r2
 800522a:	1c26      	adds	r6, r4, #0

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800522c:	4655      	mov	r5, sl
 800522e:	4664      	mov	r4, ip

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 8005230:	429a      	cmp	r2, r3
 8005232:	d910      	bls.n	8005256 <chThdCreateFromHeap.constprop.9+0xf6>
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8005234:	1b51      	subs	r1, r2, r5
 8005236:	10c9      	asrs	r1, r1, #3
 8005238:	6059      	str	r1, [r3, #4]
        if (bpages > pages) {
 800523a:	4284      	cmp	r4, r0
 800523c:	d208      	bcs.n	8005250 <chThdCreateFromHeap.constprop.9+0xf0>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 800523e:	1c61      	adds	r1, r4, #1
 8005240:	43e4      	mvns	r4, r4
 8005242:	00c9      	lsls	r1, r1, #3
 8005244:	1851      	adds	r1, r2, r1
          H_PAGES(fp) = (bpages - pages) - 1U;
 8005246:	1820      	adds	r0, r4, r0
 8005248:	6048      	str	r0, [r1, #4]

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 800524a:	6818      	ldr	r0, [r3, #0]
 800524c:	6008      	str	r0, [r1, #0]
          H_NEXT(hp) = fp;
 800524e:	6019      	str	r1, [r3, #0]
 8005250:	3208      	adds	r2, #8
 8005252:	1c15      	adds	r5, r2, #0
 8005254:	e00c      	b.n	8005270 <chThdCreateFromHeap.constprop.9+0x110>
        hp = ahp;
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
 8005256:	42b4      	cmp	r4, r6
 8005258:	d017      	beq.n	800528a <chThdCreateFromHeap.constprop.9+0x12a>
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 800525a:	469b      	mov	fp, r3
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 800525c:	3401      	adds	r4, #1
          H_NEXT(fp) = H_NEXT(hp);
 800525e:	6818      	ldr	r0, [r3, #0]
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 8005260:	00e4      	lsls	r4, r4, #3
 8005262:	191a      	adds	r2, r3, r4
          H_NEXT(fp) = H_NEXT(hp);
 8005264:	6010      	str	r0, [r2, #0]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8005266:	1a98      	subs	r0, r3, r2
 8005268:	1841      	adds	r1, r0, r1
 800526a:	10c9      	asrs	r1, r1, #3
 800526c:	6051      	str	r1, [r2, #4]
          H_NEXT(qp) = fp;
 800526e:	603a      	str	r2, [r7, #0]
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
 8005270:	465b      	mov	r3, fp
 8005272:	464a      	mov	r2, r9
 8005274:	605a      	str	r2, [r3, #4]
      H_HEAP(hp) = heapp;
 8005276:	4a07      	ldr	r2, [pc, #28]	; (8005294 <chThdCreateFromHeap.constprop.9+0x134>)

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 8005278:	1c10      	adds	r0, r2, #0
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
      H_HEAP(hp) = heapp;
 800527a:	601a      	str	r2, [r3, #0]

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 800527c:	300c      	adds	r0, #12
 800527e:	f7fb fa47 	bl	8000710 <chMtxUnlock>
                              tfunc_t pf, void *arg) {
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
 8005282:	2d00      	cmp	r5, #0
 8005284:	d1b0      	bne.n	80051e8 <chThdCreateFromHeap.constprop.9+0x88>
    return NULL;
 8005286:	2000      	movs	r0, #0
 8005288:	e7c6      	b.n	8005218 <chThdCreateFromHeap.constprop.9+0xb8>
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 800528a:	681a      	ldr	r2, [r3, #0]
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 800528c:	469b      	mov	fp, r3
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 800528e:	603a      	str	r2, [r7, #0]
 8005290:	e7ee      	b.n	8005270 <chThdCreateFromHeap.constprop.9+0x110>
 8005292:	46c0      	nop			; (mov r8, r8)
 8005294:	20000f3c 	.word	0x20000f3c
 8005298:	08002701 	.word	0x08002701
 800529c:	46c0      	nop			; (mov r8, r8)
 800529e:	46c0      	nop			; (mov r8, r8)

080052a0 <chPoolAlloc.constprop.8>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 80052a0:	b508      	push	{r3, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80052a2:	b672      	cpsid	i
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
 80052a4:	4b07      	ldr	r3, [pc, #28]	; (80052c4 <chPoolAlloc.constprop.8+0x24>)
 80052a6:	6818      	ldr	r0, [r3, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 80052a8:	2800      	cmp	r0, #0
 80052aa:	d003      	beq.n	80052b4 <chPoolAlloc.constprop.8+0x14>
    mp->next = mp->next->next;
 80052ac:	6802      	ldr	r2, [r0, #0]
 80052ae:	601a      	str	r2, [r3, #0]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80052b0:	b662      	cpsie	i
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 80052b2:	bd08      	pop	{r3, pc}
  objp = mp->next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->next = mp->next->next;
  }
  else if (mp->provider != NULL) {
 80052b4:	68da      	ldr	r2, [r3, #12]
 80052b6:	2a00      	cmp	r2, #0
 80052b8:	d0fa      	beq.n	80052b0 <chPoolAlloc.constprop.8+0x10>
    objp = mp->provider(mp->object_size, mp->align);
 80052ba:	6858      	ldr	r0, [r3, #4]
 80052bc:	6899      	ldr	r1, [r3, #8]
 80052be:	4790      	blx	r2
 80052c0:	e7f6      	b.n	80052b0 <chPoolAlloc.constprop.8+0x10>
 80052c2:	46c0      	nop			; (mov r8, r8)
 80052c4:	20000f00 	.word	0x20000f00
 80052c8:	46c0      	nop			; (mov r8, r8)
 80052ca:	46c0      	nop			; (mov r8, r8)
 80052cc:	46c0      	nop			; (mov r8, r8)
 80052ce:	46c0      	nop			; (mov r8, r8)

080052d0 <chThdCreateFromMemoryPool.constprop.7>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 80052d0:	b570      	push	{r4, r5, r6, lr}
 80052d2:	b086      	sub	sp, #24
 80052d4:	1c05      	adds	r5, r0, #0
 80052d6:	1c0e      	adds	r6, r1, #0
 80052d8:	1c14      	adds	r4, r2, #0
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80052da:	f7ff ffe1 	bl	80052a0 <chPoolAlloc.constprop.8>
  if (wsp == NULL) {
 80052de:	2800      	cmp	r0, #0
 80052e0:	d01a      	beq.n	8005318 <chThdCreateFromMemoryPool.constprop.7+0x48>
    return NULL;
  }

  thread_descriptor_t td = {
 80052e2:	9500      	str	r5, [sp, #0]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 80052e4:	4d0d      	ldr	r5, [pc, #52]	; (800531c <chThdCreateFromMemoryPool.constprop.7+0x4c>)
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 80052e6:	9001      	str	r0, [sp, #4]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 80052e8:	686b      	ldr	r3, [r5, #4]
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 80052ea:	9603      	str	r6, [sp, #12]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 80052ec:	469c      	mov	ip, r3
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 80052ee:	4b0c      	ldr	r3, [pc, #48]	; (8005320 <chThdCreateFromMemoryPool.constprop.7+0x50>)
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 80052f0:	4460      	add	r0, ip
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 80052f2:	9002      	str	r0, [sp, #8]
 80052f4:	9304      	str	r3, [sp, #16]
 80052f6:	9405      	str	r4, [sp, #20]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80052f8:	b672      	cpsid	i
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 80052fa:	4668      	mov	r0, sp
 80052fc:	f7fb f8b0 	bl	8000460 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_MPOOL;
 8005300:	2202      	movs	r2, #2
 8005302:	2321      	movs	r3, #33	; 0x21
  tp->mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 8005304:	2100      	movs	r1, #0
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
  tp->flags = CH_FLAG_MODE_MPOOL;
 8005306:	54c2      	strb	r2, [r0, r3]
  tp->mpool = mp;
 8005308:	6405      	str	r5, [r0, #64]	; 0x40
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 800530a:	1c04      	adds	r4, r0, #0
  tp->flags = CH_FLAG_MODE_MPOOL;
  tp->mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 800530c:	f7fb f940 	bl	8000590 <chSchWakeupS>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005310:	b662      	cpsie	i
 8005312:	1c20      	adds	r0, r4, #0
  chSysUnlock();

  return tp;
}
 8005314:	b006      	add	sp, #24
 8005316:	bd70      	pop	{r4, r5, r6, pc}

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
 8005318:	2000      	movs	r0, #0
 800531a:	e7fb      	b.n	8005314 <chThdCreateFromMemoryPool.constprop.7+0x44>
 800531c:	20000f00 	.word	0x20000f00
 8005320:	08002701 	.word	0x08002701
 8005324:	46c0      	nop			; (mov r8, r8)
 8005326:	46c0      	nop			; (mov r8, r8)
 8005328:	46c0      	nop			; (mov r8, r8)
 800532a:	46c0      	nop			; (mov r8, r8)
 800532c:	46c0      	nop			; (mov r8, r8)
 800532e:	46c0      	nop			; (mov r8, r8)

08005330 <_test_assert_sequence.constprop.3>:
  if (!condition)
    return _test_fail(msg);
  return false;
}

bool _test_assert_sequence(char *expected, const char *msg) {
 8005330:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005332:	4e0f      	ldr	r6, [pc, #60]	; (8005370 <_test_assert_sequence.constprop.3+0x40>)
 8005334:	4f0f      	ldr	r7, [pc, #60]	; (8005374 <_test_assert_sequence.constprop.3+0x44>)
 8005336:	6835      	ldr	r5, [r6, #0]
 8005338:	1c3b      	adds	r3, r7, #0
 800533a:	e005      	b.n	8005348 <_test_assert_sequence.constprop.3+0x18>
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
    if (*cp++ != *expected++)
 800533c:	7814      	ldrb	r4, [r2, #0]
 800533e:	780a      	ldrb	r2, [r1, #0]
 8005340:	3301      	adds	r3, #1
 8005342:	3001      	adds	r0, #1
 8005344:	4294      	cmp	r4, r2
 8005346:	d109      	bne.n	800535c <_test_assert_sequence.constprop.3+0x2c>
 8005348:	1c01      	adds	r1, r0, #0
 800534a:	1c1a      	adds	r2, r3, #0
}

bool _test_assert_sequence(char *expected, const char *msg) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
 800534c:	429d      	cmp	r5, r3
 800534e:	d8f5      	bhi.n	800533c <_test_assert_sequence.constprop.3+0xc>
    if (*cp++ != *expected++)
     return _test_fail(msg);
  }

  if (*expected)
 8005350:	7803      	ldrb	r3, [r0, #0]
 8005352:	2b00      	cmp	r3, #0
 8005354:	d102      	bne.n	800535c <_test_assert_sequence.constprop.3+0x2c>
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8005356:	6037      	str	r7, [r6, #0]
  if (*expected)
    return _test_fail(msg);

  clear_tokens();

  return false;
 8005358:	2000      	movs	r0, #0
 800535a:	e008      	b.n	800536e <_test_assert_sequence.constprop.3+0x3e>
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 800535c:	2301      	movs	r3, #1
bool _test_assert_sequence(char *expected, const char *msg) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
    if (*cp++ != *expected++)
     return _test_fail(msg);
 800535e:	2001      	movs	r0, #1
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8005360:	4a05      	ldr	r2, [pc, #20]	; (8005378 <_test_assert_sequence.constprop.3+0x48>)
 8005362:	7013      	strb	r3, [r2, #0]
  test_global_fail     = true;
 8005364:	4a05      	ldr	r2, [pc, #20]	; (800537c <_test_assert_sequence.constprop.3+0x4c>)
 8005366:	7013      	strb	r3, [r2, #0]
  test_failure_message = msg;
 8005368:	4a05      	ldr	r2, [pc, #20]	; (8005380 <_test_assert_sequence.constprop.3+0x50>)
 800536a:	4b06      	ldr	r3, [pc, #24]	; (8005384 <_test_assert_sequence.constprop.3+0x54>)
 800536c:	601a      	str	r2, [r3, #0]
    return _test_fail(msg);

  clear_tokens();

  return false;
}
 800536e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005370:	20000efc 	.word	0x20000efc
 8005374:	20000f2c 	.word	0x20000f2c
 8005378:	20000ef8 	.word	0x20000ef8
 800537c:	20000f58 	.word	0x20000f58
 8005380:	080070bc 	.word	0x080070bc
 8005384:	20000e80 	.word	0x20000e80
 8005388:	46c0      	nop			; (mov r8, r8)
 800538a:	46c0      	nop			; (mov r8, r8)
 800538c:	46c0      	nop			; (mov r8, r8)
 800538e:	46c0      	nop			; (mov r8, r8)

08005390 <_test_assert_time_window.constprop.2>:
 8005390:	2380      	movs	r3, #128	; 0x80
 8005392:	05db      	lsls	r3, r3, #23
 8005394:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((time - start) < (end - start));
 8005396:	1a09      	subs	r1, r1, r0
 8005398:	1a1b      	subs	r3, r3, r0

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
 800539a:	2000      	movs	r0, #0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 800539c:	428b      	cmp	r3, r1
 800539e:	d308      	bcc.n	80053b2 <_test_assert_time_window.constprop.2+0x22>
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 80053a0:	2301      	movs	r3, #1
 80053a2:	4a04      	ldr	r2, [pc, #16]	; (80053b4 <_test_assert_time_window.constprop.2+0x24>)
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
 80053a4:	3001      	adds	r0, #1
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 80053a6:	7013      	strb	r3, [r2, #0]
  test_global_fail     = true;
 80053a8:	4a03      	ldr	r2, [pc, #12]	; (80053b8 <_test_assert_time_window.constprop.2+0x28>)
 80053aa:	7013      	strb	r3, [r2, #0]
  test_failure_message = msg;
 80053ac:	4a03      	ldr	r2, [pc, #12]	; (80053bc <_test_assert_time_window.constprop.2+0x2c>)
 80053ae:	4b04      	ldr	r3, [pc, #16]	; (80053c0 <_test_assert_time_window.constprop.2+0x30>)
 80053b0:	601a      	str	r2, [r3, #0]
                              systime_t end,
                              const char *msg) {

  return _test_assert(osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end),
                      msg);
}
 80053b2:	4770      	bx	lr
 80053b4:	20000ef8 	.word	0x20000ef8
 80053b8:	20000f58 	.word	0x20000f58
 80053bc:	080070d0 	.word	0x080070d0
 80053c0:	20000e80 	.word	0x20000e80
 80053c4:	46c0      	nop			; (mov r8, r8)
 80053c6:	46c0      	nop			; (mov r8, r8)
 80053c8:	46c0      	nop			; (mov r8, r8)
 80053ca:	46c0      	nop			; (mov r8, r8)
 80053cc:	46c0      	nop			; (mov r8, r8)
 80053ce:	46c0      	nop			; (mov r8, r8)

080053d0 <memcpy>:
 80053d0:	b570      	push	{r4, r5, r6, lr}
 80053d2:	2a0f      	cmp	r2, #15
 80053d4:	d932      	bls.n	800543c <memcpy+0x6c>
 80053d6:	1c04      	adds	r4, r0, #0
 80053d8:	430c      	orrs	r4, r1
 80053da:	1c0b      	adds	r3, r1, #0
 80053dc:	07a4      	lsls	r4, r4, #30
 80053de:	d131      	bne.n	8005444 <memcpy+0x74>
 80053e0:	1c15      	adds	r5, r2, #0
 80053e2:	1c04      	adds	r4, r0, #0
 80053e4:	3d10      	subs	r5, #16
 80053e6:	092d      	lsrs	r5, r5, #4
 80053e8:	3501      	adds	r5, #1
 80053ea:	012d      	lsls	r5, r5, #4
 80053ec:	1949      	adds	r1, r1, r5
 80053ee:	681e      	ldr	r6, [r3, #0]
 80053f0:	6026      	str	r6, [r4, #0]
 80053f2:	685e      	ldr	r6, [r3, #4]
 80053f4:	6066      	str	r6, [r4, #4]
 80053f6:	689e      	ldr	r6, [r3, #8]
 80053f8:	60a6      	str	r6, [r4, #8]
 80053fa:	68de      	ldr	r6, [r3, #12]
 80053fc:	3310      	adds	r3, #16
 80053fe:	60e6      	str	r6, [r4, #12]
 8005400:	3410      	adds	r4, #16
 8005402:	4299      	cmp	r1, r3
 8005404:	d1f3      	bne.n	80053ee <memcpy+0x1e>
 8005406:	230f      	movs	r3, #15
 8005408:	1945      	adds	r5, r0, r5
 800540a:	4013      	ands	r3, r2
 800540c:	2b03      	cmp	r3, #3
 800540e:	d91b      	bls.n	8005448 <memcpy+0x78>
 8005410:	1f1c      	subs	r4, r3, #4
 8005412:	2300      	movs	r3, #0
 8005414:	08a4      	lsrs	r4, r4, #2
 8005416:	3401      	adds	r4, #1
 8005418:	00a4      	lsls	r4, r4, #2
 800541a:	58ce      	ldr	r6, [r1, r3]
 800541c:	50ee      	str	r6, [r5, r3]
 800541e:	3304      	adds	r3, #4
 8005420:	42a3      	cmp	r3, r4
 8005422:	d1fa      	bne.n	800541a <memcpy+0x4a>
 8005424:	18ed      	adds	r5, r5, r3
 8005426:	18c9      	adds	r1, r1, r3
 8005428:	2303      	movs	r3, #3
 800542a:	401a      	ands	r2, r3
 800542c:	d005      	beq.n	800543a <memcpy+0x6a>
 800542e:	2300      	movs	r3, #0
 8005430:	5ccc      	ldrb	r4, [r1, r3]
 8005432:	54ec      	strb	r4, [r5, r3]
 8005434:	3301      	adds	r3, #1
 8005436:	4293      	cmp	r3, r2
 8005438:	d1fa      	bne.n	8005430 <memcpy+0x60>
 800543a:	bd70      	pop	{r4, r5, r6, pc}
 800543c:	1c05      	adds	r5, r0, #0
 800543e:	2a00      	cmp	r2, #0
 8005440:	d1f5      	bne.n	800542e <memcpy+0x5e>
 8005442:	e7fa      	b.n	800543a <memcpy+0x6a>
 8005444:	1c05      	adds	r5, r0, #0
 8005446:	e7f2      	b.n	800542e <memcpy+0x5e>
 8005448:	1c1a      	adds	r2, r3, #0
 800544a:	e7f8      	b.n	800543e <memcpy+0x6e>
